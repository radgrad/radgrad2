[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "api/.external-ecmascript.js",
    "static": true,
    "longname": "api/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "api/academic-term/AcademicTermCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport 'mocha';\nimport { AcademicTerms } from './AcademicTermCollection';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { Slugs } from '../slug/SlugCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('AcademicTermCollection', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(5000);\n      fc.assert(\n        fc.property(fc.integer(2017, 2027), fc.boolean(), (fcYear, fcRetired) => {\n          const term = AcademicTerms.terms[faker.random.number({ min: 0, max: AcademicTerms.terms.length - 1 })];\n          const docID = AcademicTerms.define({ term, year: fcYear, retired: fcRetired });\n          expect(AcademicTerms.isDefined(docID)).to.be.true;\n          AcademicTerms.removeIt(docID);\n          expect(AcademicTerms.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicates', function test2() {\n      const termID = AcademicTerms.define({ term: AcademicTerms.FALL, year: 2019 });\n      const termID2 = AcademicTerms.define({ term: AcademicTerms.FALL, year: 2019 });\n      expect(termID).to.equal(termID2);\n      expect(AcademicTerms.isDefined(termID)).to.be.true;\n      expect(AcademicTerms.isDefined(termID2)).to.be.true;\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      let doc = AcademicTerms.findOne({});\n      const docID = doc._id;\n      fc.assert(\n        fc.property(fc.boolean(), (fcRetired) => {\n          AcademicTerms.update(docID, { retired: fcRetired });\n          doc = AcademicTerms.findDoc(docID);\n          expect(doc.retired).to.equal(fcRetired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      let doc = AcademicTerms.findOne({});\n      let docID = doc._id;\n      const dumpObject = AcademicTerms.dumpOne(docID);\n      AcademicTerms.removeIt(docID);\n      expect(AcademicTerms.isDefined(docID)).to.be.false;\n      docID = AcademicTerms.restoreOne(dumpObject);\n      expect(AcademicTerms.isDefined(docID)).to.be.true;\n      doc = AcademicTerms.findDoc(docID);\n      expect(doc.term).to.equal(dumpObject.term);\n      expect(doc.year).to.equal(dumpObject.year);\n      expect(doc.retired).to.equal(dumpObject.retired);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const errors = AcademicTerms.checkIntegrity();\n      expect(errors).to.have.lengthOf(0);\n    });\n\n    /* ===================== AcademicTerm method tests ===================== */\n\n    it('Can assertAcademicTerm', function test6() {\n      const academicTermDoc = AcademicTerms.findOne({});\n      const termID = academicTermDoc._id;\n      const slug = Slugs.getNameFromID(academicTermDoc.slugID);\n      expect(() => { AcademicTerms.assertAcademicTerm(termID); }).to.not.throw();\n      expect(() => { AcademicTerms.assertAcademicTerm(slug); }).to.not.throw();\n      expect(() => { AcademicTerms.assertAcademicTerm(''); }).to.throw();\n    });\n\n    it('Can findIdBySlug', function test7() {\n      const academicTermDoc = AcademicTerms.findOne({});\n      const termID = academicTermDoc._id;\n      const slug = Slugs.getNameFromID(academicTermDoc.slugID);\n      const id = AcademicTerms.findIdBySlug(slug);\n      expect(id).to.equal(termID);\n      expect(() => AcademicTerms.findIdBySlug('badSlug')).to.throw();\n    });\n\n    it('Can toString', function test5() {\n      const termID = AcademicTerms.define({ term: AcademicTerms.SPRING, year: 2010 });\n      expect(AcademicTerms.toString(termID)).to.equal('Spring 2010');\n      AcademicTerms.removeIt(termID);\n    });\n\n    it('Can get the right termNumber', function test6() {\n      let termID = AcademicTerms.define({ term: AcademicTerms.SPRING, year: 2011 });\n      expect(AcademicTerms.findDoc(termID).termNumber).to.equal(1);\n\n      termID = AcademicTerms.define({ term: AcademicTerms.SUMMER, year: 2011 });\n      expect(AcademicTerms.findDoc(termID).termNumber).to.equal(2);\n\n      termID = AcademicTerms.define({ term: AcademicTerms.FALL, year: 2011 });\n      expect(AcademicTerms.findDoc(termID).termNumber).to.equal(3);\n\n      termID = AcademicTerms.define({ term: AcademicTerms.SPRING, year: 2012 });\n      expect(AcademicTerms.findDoc(termID).termNumber).to.equal(4);\n\n      termID = AcademicTerms.define({ term: AcademicTerms.SUMMER, year: 2012 });\n      expect(AcademicTerms.findDoc(termID).termNumber).to.equal(5);\n\n      termID = AcademicTerms.define({ term: AcademicTerms.FALL, year: 2012 });\n      expect(AcademicTerms.findDoc(termID).termNumber).to.equal(6);\n    });\n\n    it('Can getID', function test7() {\n      expect(AcademicTerms.getID('Summer-2010')).to.be.a('string');\n      expect(AcademicTerms.getID('Summer-2040')).to.be.a('string');\n      expect(function () { AcademicTerms.getID('foobar'); }).to.throw();\n    });\n\n    it('Can getShortName', function test8() {\n      const termID = AcademicTerms.getID('Summer-2010');\n      expect(AcademicTerms.getShortName(termID)).to.equal('Sum 10');\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/academic-term/AcademicTermCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "file",
    "name": "api/academic-term/AcademicTermCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport moment from 'moment';\nimport _ from 'lodash';\nimport { Slugs } from '../slug/SlugCollection';\nimport BaseSlugCollection from '../base/BaseSlugCollection';\nimport { IAcademicTermDefine, IAcademicTermUpdate } from '../../typings/radgrad';\nimport { RadGradProperties } from '../radgrad/RadGradProperties';\nimport { OpportunityInstances } from '../opportunity/OpportunityInstanceCollection';\nimport { CourseInstances } from '../course/CourseInstanceCollection';\nimport { Opportunities } from '../opportunity/OpportunityCollection';\n\n/**\n * Represents a specific academicTerm, such as \"Spring, 2016\", \"Fall, 2017\", or \"Summer, 2015\".\n * @extends BaseSlugCollection\n */\nclass AcademicTermCollection extends BaseSlugCollection {\n  public SPRING: string;\n  public SUMMER: string;\n  public FALL: string;\n  public WINTER: string;\n  public readonly terms: string[];\n  private readonly fallStart: number;\n  private readonly springStart: number;\n  private readonly summerStart: number;\n\n  /**\n   * Creates the AcademicTerm collection.\n   */\n  constructor() {\n    super('AcademicTerm', new SimpleSchema({\n      term: { type: String },\n      year: { type: SimpleSchema.Integer, min: 1991, max: 2050, defaultValue: moment().year() },\n      termNumber: { type: Number },\n      slugID: { type: SimpleSchema.RegEx.Id },\n      retired: { type: Boolean, optional: true },\n    }));\n    this.SPRING = 'Spring';\n    this.SUMMER = 'Summer';\n    this.FALL = 'Fall';\n    this.WINTER = 'Winter';\n    // console.log(settingsDoc, Meteor.settings);\n    if (RadGradProperties.getQuarterSystem()) {\n      this.terms = [this.FALL, this.WINTER, this.SPRING, this.SUMMER];\n      this.fallStart = parseInt(moment('09-26-2015', 'MM-DD-YYYY').format('DDD'), 10);\n      this.springStart = parseInt(moment('04-01-2015', 'MM-DD-YYYY').format('DDD'), 10);\n      this.summerStart = parseInt(moment('06-20-2015', 'MM-DD-YYYY').format('DDD'), 10);\n    } else {\n      this.terms = [this.FALL, this.SPRING, this.SUMMER];\n      this.fallStart = parseInt(moment('08-15-2015', 'MM-DD-YYYY').format('DDD'), 10);\n      this.springStart = parseInt(moment('01-01-2015', 'MM-DD-YYYY').format('DDD'), 10);\n      this.summerStart = parseInt(moment('05-15-2015', 'MM-DD-YYYY').format('DDD'), 10);\n    }\n    this.defineSchema = new SimpleSchema({\n      term: { type: String, allowedValues: this.terms, defaultValue: this.FALL },\n      year: {\n        type: SimpleSchema.Integer,\n        min: moment().year() - 5,\n        max: moment().year() + 10,\n        defaultValue: moment().year(),\n      },\n    });\n    this.updateSchema = new SimpleSchema({\n      retired: Boolean,\n    });\n  }\n\n  /**\n   * Returns an object representing the AcademicTerm docID in a format acceptable to define().\n   * @param docID The docID of a Academic Term.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IAcademicTermDefine {\n    const doc = this.findDoc(docID);\n    const term = doc.term;\n    const year = doc.year;\n    const retired = doc.retired;\n    return { term, year, retired };\n  }\n\n  /**\n   * Retrieves the docID for the specified Academic Term, or defines it if not yet present.\n   * Implicitly defines the corresponding slug: Spring, 2016 academicTerm is \"Spring-2016\".\n   * @example\n   * AcademicTerms.define({ term: AcademicTerms.FALL, year: 2015 });\n   * @param { Object } Object with keys term, academicTerm.\n   * Term must be one of AcademicTerms.FALL, AcademicTerms.SPRING, or AcademicTerms.SUMMER.\n   * Year must be between 1990 and 2050.\n   * @throws { Meteor.Error } If the term or year are not correctly specified.\n   * @returns The docID for this academicTerm instance.\n   */\n  public define({ term, year, retired = false }: IAcademicTermDefine) {\n    // Check that term and year are valid.\n    if (this.terms.indexOf(term) < 0) {\n      throw new Meteor.Error(`Invalid term: ${term}`);\n    }\n    if ((year < 1990) || (year > 2050)) {\n      throw new Meteor.Error(`Invalid year: ${year}`);\n    }\n\n    // Return immediately if academicTerm is already defined.\n    const doc = this.collection.findOne({ term, year });\n    if (doc) {\n      return doc._id;\n    }\n\n    // Otherwise define a new academicTerm and add it to the collection if successful.\n\n    // Compute termNumber, another number that puts academicTerms into chronological order.\n    // Epoch is Fall-2010\n    let termNumber = 0;\n    const yearDiff = year - 2010;\n    if (RadGradProperties.getQuarterSystem()) {\n      if (term === this.WINTER) {\n        termNumber = (4 * yearDiff) - 3;\n      } else if (term === this.SPRING) {\n        termNumber = (4 * yearDiff) - 2;\n      } else if (term === this.SUMMER) {\n        termNumber = (4 * yearDiff) - 1;\n      } else {\n        termNumber = 4 * yearDiff;\n      }\n    } else if (term === this.SPRING) {\n      termNumber = (3 * yearDiff) - 2;\n    } else if (term === this.SUMMER) {\n      termNumber = (3 * yearDiff) - 1;\n    } else {\n      termNumber = 3 * yearDiff;\n    }\n\n    // Determine what the slug looks like.\n    const slug = `${term}-${year}`;\n\n    if (Slugs.isDefined(slug)) {\n      throw new Meteor.Error(`Slug is already defined for undefined AcademicTerm: ${slug}`);\n    }\n    const slugID = Slugs.define({ name: slug, entityName: 'AcademicTerm' });\n    const termID = this.collection.insert({ term, year, termNumber, slugID, retired });\n    Slugs.updateEntityID(slugID, termID);\n    return termID;\n  }\n\n  /**\n   * Updates the retired flag.\n   * @param docID the id of the academicTerm.\n   * @param retired optional boolean.\n   */\n  public update(docID, { retired }: IAcademicTermUpdate) {\n    // console.log(`AcademicTerm.update(${docID}, ${retired})`);\n    const updateData: IAcademicTermUpdate = {};\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n      this.collection.update(docID, { $set: updateData });\n    }\n  }\n\n  /**\n   * Ensures the passed object is a Academic Term instance.\n   * @param term Should be a defined termID or academic term doc.\n   * @throws {Meteor.Error} If academicTerm is not a Academic Term.\n   */\n  public assertAcademicTerm(term: string) {\n    if (!term || !this.isDefined(term)) {\n      throw new Meteor.Error(`${term} is not a valid Academic Term.`);\n    }\n  }\n\n  public findIdBySlug(slug): { optional: boolean; type: any } | string | any {\n    // console.log('findIdBySlug', slug);\n    if (this.isDefined(slug)) {\n      return super.findIdBySlug(slug);\n    }\n    const split = slug.split('-');\n    const term = split[0];\n    const year = parseInt(split[1], 10);\n    return this.define({ term, year });\n  }\n\n  /**\n   * Returns the termID associated with the current academicTerm based upon the current timestamp.\n   * See AcademicTerms.FALL_START_DATE, SPRING_START_DATE, and SUMMER_START_DATE.\n   */\n  public getCurrentTermID() {\n    const year = moment().year();\n    const day = moment().dayOfYear();\n    let term = '';\n    if (RadGradProperties.getQuarterSystem()) {\n      if (day >= this.fallStart) {\n        term = this.FALL;\n      } else if (day >= this.summerStart) {\n        term = this.SUMMER;\n      } else if (day >= this.springStart) {\n        term = this.SPRING;\n      } else {\n        term = this.WINTER;\n      }\n    } else if (day >= this.fallStart) {\n      term = this.FALL;\n    } else if (day >= this.summerStart) {\n      term = this.SUMMER;\n    } else {\n      term = this.SPRING;\n    }\n    return this.define({ term, year });\n  }\n\n  public getAcademicTermFromToString(termToString: string) {\n    const split = termToString.split(' ');\n    if (split.length !== 2) {\n      throw new Meteor.Error('Invalid AcademicTerm toString value');\n    }\n    const term = split[0];\n    const year = parseInt(split[1], 10);\n    return this.findDoc({ term, year });\n  }\n\n  /**\n   * Returns true if the passed academicTerm occurs now or in the future.\n   * @param term The academic term (slug or termID).\n   * @returns True if academic term is in the future.\n   */\n  public isUpcomingTerm(term: string) {\n    const termID = this.getID(term);\n    return this.findDoc(termID).termNumber >= this.getCurrentAcademicTermDoc().termNumber;\n  }\n\n  /**\n   * Returns the academicTerm doc associated with the current academicTerm based upon the current timestamp.\n   * See AcademicTerms.FALL_START_DATE, SPRING_START_DATE, and SUMMER_START_DATE.\n   */\n  public getCurrentAcademicTermDoc() {\n    const id = this.getCurrentTermID();\n    return this.findDoc(id);\n  }\n\n  /**\n   * Returns the academicTerm ID corresponding to the given date.\n   * @param date The date as a string. Must be able to be parsed by moment();\n   * @returns {String} The termID that the date falls in.\n   */\n  public getAcademicTerm(date: string | Date) {\n    const d = moment(date);\n    const year = d.year();\n    const day = d.dayOfYear();\n    let term = '';\n    if (day >= this.fallStart) {\n      term = this.FALL;\n    } else if (day >= this.summerStart) {\n      term = this.SUMMER;\n    } else if (day >= this.springStart) {\n      term = this.SPRING;\n    } else {\n      term = this.WINTER;\n    }\n    return this.define({ term, year });\n  }\n\n  /**\n   * Returns the academicTerm document corresponding to the given date.\n   * @param date The date.\n   * @returns Object The academicTerm that the date falls in.\n   */\n  public getAcademicTermDoc(date: string) {\n    const id = this.getAcademicTerm(date);\n    return this.findDoc(id);\n  }\n\n  /**\n   * Returns the academicTerm docID associated with the passed academicTerm slug or docID.\n   * If the academicTerm does not exist, it is defined.\n   * @param academicTerm The Slug or docID associated with a academicTerm\n   * @returns The academicTerm ID.\n   * @throws { Meteor.Error } If the passed academicTerm is not a valid academicTerm slug.\n   */\n  public getID(academicTerm: string) {\n    // console.log('getID', academicTerm);\n    if (this.isDefined(academicTerm)) {\n      // console.log('isDefined');\n      return super.getID(academicTerm);\n    }\n    // Otherwise academicTerm should be a slug.  Try to define it.\n    const split = academicTerm.split('-');\n    const term = split[0];\n    const year = parseInt(split[1], 10);\n    // console.log('define', term, year);\n    return this.define({ term, year });\n  }\n\n  /**\n   * Returns the passed academicTerm, formatted as a string.\n   * @param termID The academicTerm.\n   * @param nospace If true, then term and year are concatenated without a space in between.\n   * @returns { String } The academicTerm as a string.\n   */\n  public toString(termID: string, nospace?: boolean) {\n    this.assertAcademicTerm(termID);\n    const academicTermDoc = this.findDoc(termID);\n    return (nospace) ? `${academicTermDoc.term}${academicTermDoc.year}` : `${academicTermDoc.term} ${academicTermDoc.year}`;\n  }\n\n  /**\n   * Returns a four character \"shortname\" for a academicTerm and year: Fa18, Sp19, Su20\n   * @param termID The academicTerm\n   * @returns {string} The shortname.\n   */\n  public getShortName(termID: string) {\n    this.assertAcademicTerm(termID);\n    const academicTermDoc = this.findDoc(termID);\n    const yearString = `${academicTermDoc.year}`.substring(2, 4);\n    const termString = (academicTermDoc.term === 'Fall') ? 'Fall' : academicTermDoc.term.substring(0, 3);\n    return `${termString} ${yearString}`;\n  }\n\n  /**\n   * Remove the Course.\n   * @param instance The docID or slug of the entity to be removed.\n   * @throws { Meteor.Error } If docID is not a Course, or if this course has any associated course instances.\n   */\n  public removeIt(instance: string) {\n    const docID = this.getID(instance);\n    // Check that this term is not referenced by any Opportunity Instance.\n    OpportunityInstances.find().map((opportunityInstance) => {\n      if (opportunityInstance.termID === docID) {\n        throw new Meteor.Error(`AcademicTerm ${instance} referenced by a opportunity instance.`);\n      }\n      return true;\n    });\n    // Check that this term in not referenced by any Course Instance\n    CourseInstances.find().map((courseInstance) => {\n      if (courseInstance.termID === docID) {\n        throw new Meteor.Error(`AcademicTerm ${instance} referenced by a course instance.`);\n      }\n      return true;\n    });\n    // Check that this term is not referenced by any Opportunity\n    Opportunities.find().map((opportunity) => {\n      if (_.includes(opportunity.termIDs, docID)) {\n        throw new Meteor.Error(`AcademicTerm ${instance} referenced by an opportunity.`);\n      }\n      return true;\n    });\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks slugID.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find({}, {}).forEach((doc) => {\n      if (!Slugs.isDefined(doc.slugID)) {\n        problems.push(`Bad slugID: ${doc.slugID}`);\n      }\n    });\n    return problems;\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @type {api/academicTerm.AcademicTermCollection}\n * @memberOf api/academic-term\n */\nexport const AcademicTerms = new AcademicTermCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/academic-term/AcademicTermCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 50,
    "kind": "variable",
    "name": "AcademicTerms",
    "memberof": "api/academic-term/AcademicTermCollection.ts",
    "static": true,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTerms",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/academic-term/AcademicTermCollection.ts",
    "importStyle": "{AcademicTerms}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 408,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/academic-term"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/academicTerm.AcademicTermCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 51,
    "kind": "class",
    "name": "AcademicTermCollection",
    "memberof": "api/academic-term/AcademicTermCollection.ts",
    "static": true,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/academic-term/AcademicTermCollection.ts",
    "importStyle": null,
    "description": "Represents a specific academicTerm, such as \"Spring, 2016\", \"Fall, 2017\", or \"Summer, 2015\".",
    "lineNumber": 17,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseSlugCollection.js~BaseSlugCollection"
    ]
  },
  {
    "__docId__": 52,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#constructor",
    "access": "public",
    "description": "Creates the AcademicTerm collection.",
    "lineNumber": 21
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "SPRING",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#SPRING",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "SUMMER",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#SUMMER",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "member",
    "name": "FALL",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#FALL",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "member",
    "name": "WINTER",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#WINTER",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 57,
    "kind": "member",
    "name": "terms",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#terms",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 58,
    "kind": "member",
    "name": "fallStart",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#fallStart",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 59,
    "kind": "member",
    "name": "springStart",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#springStart",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "member",
    "name": "summerStart",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#summerStart",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the AcademicTerm docID in a format acceptable to define().",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IAcademicTermDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "define",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#define",
    "access": "public",
    "description": "Retrieves the docID for the specified Academic Term, or defines it if not yet present.\nImplicitly defines the corresponding slug: Spring, 2016 academicTerm is \"Spring-2016\".",
    "lineNumber": 92,
    "params": [
      {
        "nullable": null,
        "types": [
          "IAcademicTermDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "method",
    "name": "update",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#update",
    "access": "public",
    "description": "Updates the retired flag.",
    "lineNumber": 148,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IAcademicTermUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "assertAcademicTerm",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#assertAcademicTerm",
    "access": "public",
    "description": "Ensures the passed object is a Academic Term instance.",
    "lineNumber": 162,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "term",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 71,
    "kind": "method",
    "name": "findIdBySlug",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#findIdBySlug",
    "access": "public",
    "description": "",
    "lineNumber": 168,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "slug",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "method",
    "name": "getCurrentTermID",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#getCurrentTermID",
    "access": "public",
    "description": "Returns the termID associated with the current academicTerm based upon the current timestamp.\nSee AcademicTerms.FALL_START_DATE, SPRING_START_DATE, and SUMMER_START_DATE.",
    "lineNumber": 183,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 73,
    "kind": "method",
    "name": "getAcademicTermFromToString",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#getAcademicTermFromToString",
    "access": "public",
    "description": "",
    "lineNumber": 207,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "termToString",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "method",
    "name": "isUpcomingTerm",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#isUpcomingTerm",
    "access": "public",
    "description": "Returns true if the passed academicTerm occurs now or in the future.",
    "lineNumber": 222,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "term",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "method",
    "name": "getCurrentAcademicTermDoc",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#getCurrentAcademicTermDoc",
    "access": "public",
    "description": "Returns the academicTerm doc associated with the current academicTerm based upon the current timestamp.\nSee AcademicTerms.FALL_START_DATE, SPRING_START_DATE, and SUMMER_START_DATE.",
    "lineNumber": 231,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "method",
    "name": "getAcademicTerm",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#getAcademicTerm",
    "access": "public",
    "description": "Returns the academicTerm ID corresponding to the given date.",
    "lineNumber": 241,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 77,
    "kind": "method",
    "name": "getAcademicTermDoc",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#getAcademicTermDoc",
    "access": "public",
    "description": "Returns the academicTerm document corresponding to the given date.",
    "lineNumber": 263,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "date",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "getID",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#getID",
    "access": "public",
    "description": "Returns the academicTerm docID associated with the passed academicTerm slug or docID.\nIf the academicTerm does not exist, it is defined.",
    "lineNumber": 275,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "academicTerm",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "toString",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#toString",
    "access": "public",
    "description": "Returns the passed academicTerm, formatted as a string.",
    "lineNumber": 295,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "termID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "nospace",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "method",
    "name": "getShortName",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#getShortName",
    "access": "public",
    "description": "Returns a four character \"shortname\" for a academicTerm and year: Fa18, Sp19, Su20",
    "lineNumber": 306,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "termID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#removeIt",
    "access": "public",
    "description": "Remove the Course.",
    "lineNumber": 319,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/academic-term/AcademicTermCollection.ts~AcademicTermCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks slugID.",
    "lineNumber": 351,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "file",
    "name": "api/academic-term/AcademicTermUtilities.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport 'mocha';\nimport { defineAcademicTerms, nextAcademicTerm, upComingTerms } from './AcademicTermUtilities';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { AcademicTerms } from './AcademicTermCollection';\nimport { RadGradProperties } from '../radgrad/RadGradProperties';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('AcademicTermUtilities', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n      defineAcademicTerms();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can get nextAcademicTerm', function test1() {\n      const currentAcademicTerm = AcademicTerms.getCurrentAcademicTermDoc();\n      const next = nextAcademicTerm(currentAcademicTerm);\n      expect(next.termNumber).to.equal(currentAcademicTerm.termNumber + 1);\n    });\n\n    it('Can get upComingTerms', function test2() {\n      let termCount;\n      if (RadGradProperties.getQuarterSystem()) {\n        termCount = 20;\n      } else {\n        termCount = 15;\n      }\n      const count = AcademicTerms.find({}).count();\n      expect(count).to.be.equal(termCount);\n      const upComing = upComingTerms();\n      // console.log(upComing);\n      expect(upComing.length).to.be.equal(9);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/academic-term/AcademicTermUtilities.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 84,
    "kind": "file",
    "name": "api/academic-term/AcademicTermUtilities.ts",
    "content": "import _ from 'lodash';\nimport moment from 'moment';\nimport { AcademicTerms } from './AcademicTermCollection';\nimport { RadGradProperties } from '../radgrad/RadGradProperties';\n\n/**\n * Defines default academicTerms from 2014 till 2020.\n * @memberOf api/academic-term\n */\nexport function defineAcademicTerms() {\n  let year = moment().year() - 1;\n  if (AcademicTerms.find().count() === 0) {\n    for (let i = 0; i < 5; i++) {\n      AcademicTerms.define({ term: AcademicTerms.SPRING, year });\n      AcademicTerms.define({ term: AcademicTerms.SUMMER, year });\n      AcademicTerms.define({ term: AcademicTerms.FALL, year });\n      if (RadGradProperties.getQuarterSystem()) {\n        AcademicTerms.define({ term: AcademicTerms.WINTER, year });\n      }\n      year++;\n    }\n  }\n}\n\n/**\n * Returns the next AcademicTerm document given an AcademicTerm document.\n * @param termDoc the AcademicTerm doc.\n * @returns The next AcademicTerm doc.\n * @memberOf api/academic-term\n */\nexport function nextAcademicTerm(termDoc) {\n  const currentTerm = termDoc.term;\n  const currentYear = termDoc.year;\n  let term;\n  let year = currentYear;\n  if (currentTerm === AcademicTerms.FALL) {\n    if (RadGradProperties.getQuarterSystem()) {\n      term = AcademicTerms.WINTER;\n    } else {\n      term = AcademicTerms.SPRING;\n    }\n    year += 1;\n  } else if (currentTerm === AcademicTerms.WINTER) {\n    term = AcademicTerms.SPRING;\n  } else if (currentTerm === AcademicTerms.SPRING) {\n    term = AcademicTerms.SUMMER;\n  } else {\n    term = AcademicTerms.FALL;\n  }\n  return AcademicTerms.findDoc(AcademicTerms.define({ term, year }));\n}\n\n/**\n * Returns the next Fall, Winter or Spring academic term doc. Skips over Summer academic terms.\n * @param term the academic term doc.\n * @returns The next academic term doc (excluding summer).\n * @memberOf api/academic-term\n */\nexport function nextNonSummerTerm(term) {\n  let next: { term: string } = nextAcademicTerm(term);\n  if (next.term === AcademicTerms.SUMMER) {\n    next = nextAcademicTerm(next);\n  }\n  return next;\n}\n\n/**\n * Returns an array of the upcoming academicTerms.\n * @return {array} of the upcoming academicTerms.\n * @memberOf api/academic-term\n */\nexport function upComingTerms() {\n  const currentTerm = AcademicTerms.getCurrentAcademicTermDoc();\n  const nine = currentTerm.termNumber + 10;\n  return _.sortBy(AcademicTerms.find({\n    termNumber: {\n      $gt: currentTerm.termNumber,\n      $lt: nine,\n    },\n  }).fetch(), (sem) => sem.termNumber);\n}\n\nexport function termIDsToString(termIDs: string[]) {\n  const retVal = [];\n  termIDs.forEach((id) => {\n    retVal.push(AcademicTerms.toString(id));\n  });\n  return retVal;\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/academic-term/AcademicTermUtilities.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 85,
    "kind": "function",
    "name": "defineAcademicTerms",
    "memberof": "api/academic-term/AcademicTermUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/academic-term/AcademicTermUtilities.ts~defineAcademicTerms",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/academic-term/AcademicTermUtilities.ts",
    "importStyle": "{defineAcademicTerms}",
    "description": "Defines default academicTerms from 2014 till 2020.",
    "lineNumber": 10,
    "params": [],
    "return": null
  },
  {
    "__docId__": 86,
    "kind": "function",
    "name": "nextAcademicTerm",
    "memberof": "api/academic-term/AcademicTermUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/academic-term/AcademicTermUtilities.ts~nextAcademicTerm",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/academic-term/AcademicTermUtilities.ts",
    "importStyle": "{nextAcademicTerm}",
    "description": "Returns the next AcademicTerm document given an AcademicTerm document.",
    "lineNumber": 31,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "termDoc",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "function",
    "name": "nextNonSummerTerm",
    "memberof": "api/academic-term/AcademicTermUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/academic-term/AcademicTermUtilities.ts~nextNonSummerTerm",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/academic-term/AcademicTermUtilities.ts",
    "importStyle": "{nextNonSummerTerm}",
    "description": "Returns the next Fall, Winter or Spring academic term doc. Skips over Summer academic terms.",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "term",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "function",
    "name": "upComingTerms",
    "memberof": "api/academic-term/AcademicTermUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/academic-term/AcademicTermUtilities.ts~upComingTerms",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/academic-term/AcademicTermUtilities.ts",
    "importStyle": "{upComingTerms}",
    "description": "Returns an array of the upcoming academicTerms.",
    "lineNumber": 72,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "function",
    "name": "termIDsToString",
    "memberof": "api/academic-term/AcademicTermUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/academic-term/AcademicTermUtilities.ts~termIDsToString",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/academic-term/AcademicTermUtilities.ts",
    "importStyle": "{termIDsToString}",
    "description": "",
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "termIDs",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "file",
    "name": "api/academic-term/SampleAcademicTerms.ts",
    "content": "import faker from 'faker';\nimport { AcademicTerms } from './AcademicTermCollection';\nimport { Slugs } from '../slug/SlugCollection';\n\nexport const getRandomTerm = () => {\n  const index = faker.random.number({ max: AcademicTerms.terms.length - 1 });\n  return AcademicTerms.terms[index];\n};\n\nexport const makeSampleAcademicTerm = () => {\n  const term = getRandomTerm();\n  const year = faker.random.number({ min: 2017, max: 2027 });\n  return AcademicTerms.define({ term, year });\n};\n\nexport const makeSampleAcademicTermArray = (numTerms = 2) => {\n  const retVal = [];\n  for (let i = 0; i < numTerms; i++) {\n    retVal.push(makeSampleAcademicTerm());\n  }\n  return retVal;\n};\n\nexport const makeSampleAcademicTermSlug = () => {\n  const termID = makeSampleAcademicTerm();\n  return Slugs.getNameFromID(AcademicTerms.findDoc(termID).slugID);\n};\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/academic-term/SampleAcademicTerms.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 91,
    "kind": "function",
    "name": "getRandomTerm",
    "memberof": "api/academic-term/SampleAcademicTerms.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/academic-term/SampleAcademicTerms.ts~getRandomTerm",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/academic-term/SampleAcademicTerms.ts",
    "importStyle": "{getRandomTerm}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "function",
    "name": "makeSampleAcademicTerm",
    "memberof": "api/academic-term/SampleAcademicTerms.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/academic-term/SampleAcademicTerms.ts~makeSampleAcademicTerm",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/academic-term/SampleAcademicTerms.ts",
    "importStyle": "{makeSampleAcademicTerm}",
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "function",
    "name": "makeSampleAcademicTermArray",
    "memberof": "api/academic-term/SampleAcademicTerms.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/academic-term/SampleAcademicTerms.ts~makeSampleAcademicTermArray",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/academic-term/SampleAcademicTerms.ts",
    "importStyle": "{makeSampleAcademicTermArray}",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "params": [
      {
        "name": "numTerms",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 2,
        "defaultValue": "2"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "function",
    "name": "makeSampleAcademicTermSlug",
    "memberof": "api/academic-term/SampleAcademicTerms.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/academic-term/SampleAcademicTerms.ts~makeSampleAcademicTermSlug",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/academic-term/SampleAcademicTerms.ts",
    "importStyle": "{makeSampleAcademicTermSlug}",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "file",
    "name": "api/academic-term/index.ts",
    "content": "/** @namespace api/academic-term */\n\nimport './AcademicTermCollection';\nimport './AcademicTermUtilities';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/academic-term/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 96,
    "kind": "file",
    "name": "api/analytic/Email.methods.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { Roles } from 'meteor/alanning:roles';\nimport { ValidatedMethod } from 'meteor/mdg:validated-method';\nimport { sendEmail } from './Email';\nimport { ROLE } from '../role/Role';\n\n/**\n * The Email sendEmail ValidatedMethod.\n * @memberOf api/analytic\n */\nexport const sendEmailMethod = new ValidatedMethod({\n  name: 'Email.sendEmail',\n  validate: null,\n  run(emailData) {\n    // Let other method calls from the same client start running,\n    // without waiting for the email sending to complete.\n    this.unblock();\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to send emails.', Error().stack);\n    } else if (!Roles.userIsInRole(this.userId, [ROLE.ADMIN])) {\n      throw new Meteor.Error('unauthorized', 'You must be an Admin to send emails.', Error().stack);\n    }\n    sendEmail(emailData);\n  },\n});\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/analytic/Email.methods.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 97,
    "kind": "variable",
    "name": "sendEmailMethod",
    "memberof": "api/analytic/Email.methods.ts",
    "static": true,
    "longname": "api/analytic/Email.methods.ts~sendEmailMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/analytic/Email.methods.ts",
    "importStyle": "{sendEmailMethod}",
    "description": "The Email sendEmail ValidatedMethod.",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/analytic"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 98,
    "kind": "file",
    "name": "api/analytic/Email.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { Email } from 'meteor/email'; // non-relative module\nimport { SSR } from 'meteor/meteorhacks:ssr'; // non-relative module\n// global for Meteor but you have to declare it in file to use it\n/* eslint-disable no-unused-vars */\ndeclare const Assets: any;\n\n// use typescript to your advantage and make an interface that requires those props passed in\n// utilizing the interfaces\n/**\n * Email sender to distribute RadGrad newsletter. Utilizes SSR to compile and render HTML/CSS code within the email.\n * @param to The recipient.\n * @param cc The cc recipients.\n * @param from The sender.\n * @param subject The email subject line.\n * @param templateData Custom data to be rendered in the email template. SSR is used to compile and\n * render the final content.\n */\nexport function sendEmail({ to, bcc, from, replyTo, subject, templateData, filename }) {\n  if (Meteor.isServer) {\n    SSR.compileTemplate('htmlEmail', Assets.getText(`email/${filename}`));\n    const html = SSR.render('htmlEmail', templateData);\n    Email.send({\n      to,\n      bcc,\n      replyTo,\n      from,\n      subject,\n      html,\n    });\n  }\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/analytic/Email.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 99,
    "kind": "function",
    "name": "sendEmail",
    "memberof": "api/analytic/Email.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/analytic/Email.ts~sendEmail",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/analytic/Email.ts",
    "importStyle": "{sendEmail}",
    "description": "Email sender to distribute RadGrad newsletter. Utilizes SSR to compile and render HTML/CSS code within the email.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 100,
    "kind": "file",
    "name": "api/analytic/IceSnapshotCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport 'mocha';\nimport moment from 'moment';\nimport { Users } from '../user/UserCollection';\nimport { IceSnapshots } from './IceSnapshotCollection';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { removeAllEntities } from '../base/BaseUtilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('IceSnapshotCollection', function testSuite() {\n    let username;\n\n    before(function setup() {\n      removeAllEntities();\n      const userID = makeSampleUser();\n      username = Users.getProfile(userID).username;\n    });\n\n    after(function tearDown() {\n      removeAllEntities();\n    });\n\n    it('Can define and remove', function test1() {\n      fc.assert(\n        fc.property(fc.integer(1, 6), fc.nat(100), fc.nat(100), fc.nat(100), (level, i, c, e) => {\n          const docID = IceSnapshots.define({ username, level, i, c, e, updated: moment().toDate() });\n          expect(IceSnapshots.isDefined(docID)).to.be.true;\n          IceSnapshots.removeIt(docID);\n          expect(IceSnapshots.isDefined(docID)).to.be.false;\n        }),\n      );\n    });\n\n    it('Can checkIntegrity no errors', function test2() {\n      const level = faker.random.number({ min: 1, max: 6 });\n      const i = faker.random.number({ min: 0, max: 150 });\n      const c = faker.random.number({ min: 0, max: 150 });\n      const e = faker.random.number({ min: 0, max: 150 });\n      IceSnapshots.define({ username, level, i, c, e, updated: moment().toDate() });\n      const errors = IceSnapshots.checkIntegrity();\n      expect(errors).to.have.lengthOf(0);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/analytic/IceSnapshotCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 101,
    "kind": "file",
    "name": "api/analytic/IceSnapshotCollection.ts",
    "content": "import SimpleSchema from 'simpl-schema';\nimport BaseCollection from '../base/BaseCollection';\nimport { Users } from '../user/UserCollection';\nimport { IIceSnapshotDefine } from '../../typings/radgrad';\n\n/**\n * Represents a snapshot of a student's ICE points and their level. Used to check if a student\n * has leveled up and/or achieved 100 ICE points (complete plan).\n * @extends api/base.BaseCollection\n * @memberOf api/analytic\n */\nclass IceSnapshotCollection extends BaseCollection {\n\n  /**\n   * Creates the IceSnapshot collection.\n   */\n  constructor() {\n    super('IceSnapshot', new SimpleSchema({\n      c: { type: Number },\n      e: { type: Number },\n      i: { type: Number },\n      level: { type: Number },\n      updated: { type: Date },\n      username: { type: String },\n    }));\n  }\n\n  /**\n   * Defines a snapshot of a Student's level and ICE.\n   * @param username The student's username.\n   * @param level The student's current level.\n   * @param i The student's current innovation points.\n   * @param c The student's current competency points.\n   * @param e The student's current experience points.\n   * @param updated Timestamp of most recent snapshot.\n   */\n  public define({ username, level, i, c, e, updated }: IIceSnapshotDefine) {\n    return this.collection.insert({ username, level, i, c, e, updated });\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find({}, {}).forEach((doc) => {\n      if (!Users.isDefined(doc.username)) {\n        problems.push(`Bad user: ${doc.username}`);\n      } else if (this.find({ username: doc.username }).count() > 1) {\n        problems.push(`More than one document found for user: ${doc.username}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the IceSnapshotCollection docID in a format acceptable to define().\n   * @param docID The docID of a IceSnapshot.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IIceSnapshotDefine {\n    const doc = this.findDoc(docID);\n    const username = doc.username;\n    const updated = doc.updated;\n    const level = doc.level;\n    const i = doc.i;\n    const c = doc.c;\n    const e = doc.e;\n    return { username, level, i, c, e, updated };\n  }\n}\n\nexport const IceSnapshots = new IceSnapshotCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/analytic/IceSnapshotCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 102,
    "kind": "variable",
    "name": "IceSnapshots",
    "memberof": "api/analytic/IceSnapshotCollection.ts",
    "static": true,
    "longname": "api/analytic/IceSnapshotCollection.ts~IceSnapshots",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/analytic/IceSnapshotCollection.ts",
    "importStyle": "{IceSnapshots}",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "type": {
      "types": [
        "api/analytic/IceSnapshotCollection.ts~IceSnapshotCollection"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "class",
    "name": "IceSnapshotCollection",
    "memberof": "api/analytic/IceSnapshotCollection.ts",
    "static": true,
    "longname": "api/analytic/IceSnapshotCollection.ts~IceSnapshotCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/analytic/IceSnapshotCollection.ts",
    "importStyle": null,
    "description": "Represents a snapshot of a student's ICE points and their level. Used to check if a student\nhas leveled up and/or achieved 100 ICE points (complete plan).",
    "lineNumber": 12,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 104,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/analytic/IceSnapshotCollection.ts~IceSnapshotCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/analytic/IceSnapshotCollection.ts~IceSnapshotCollection#constructor",
    "access": "public",
    "description": "Creates the IceSnapshot collection.",
    "lineNumber": 15
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "define",
    "memberof": "api/analytic/IceSnapshotCollection.ts~IceSnapshotCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/analytic/IceSnapshotCollection.ts~IceSnapshotCollection#define",
    "access": "public",
    "description": "Defines a snapshot of a Student's level and ICE.",
    "lineNumber": 37,
    "params": [
      {
        "nullable": null,
        "types": [
          "IIceSnapshotDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/analytic/IceSnapshotCollection.ts~IceSnapshotCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/analytic/IceSnapshotCollection.ts~IceSnapshotCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.",
    "lineNumber": 46,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/analytic/IceSnapshotCollection.ts~IceSnapshotCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/analytic/IceSnapshotCollection.ts~IceSnapshotCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the IceSnapshotCollection docID in a format acceptable to define().",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IIceSnapshotDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 108,
    "kind": "file",
    "name": "api/analytic/UserInteractionCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { userInteractionDefineMethod, userInteractionRemoveUserMethod } from './UserInteractionCollection.methods';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('UserInteractionCollection Meteor Methods ', function test() {\n    const student = 'abi@hawaii.edu';\n    const definitionData = {\n      username: student,\n      type: 'interaction-type',\n      typeData: 'interaction-data',\n    };\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal', 'abi.student'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      await userInteractionDefineMethod.callPromise(definitionData);\n    });\n\n    it('Remove Method', async function () {\n      await userInteractionRemoveUserMethod.callPromise(student);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/analytic/UserInteractionCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 109,
    "kind": "file",
    "name": "api/analytic/UserInteractionCollection.methods.ts",
    "content": "import { CallPromiseMixin } from 'meteor/didericis:callpromise-mixin';\nimport { ValidatedMethod } from 'meteor/mdg:validated-method';\nimport { UserInteractions } from './UserInteractionCollection';\n\n/**\n * The validated method for defining UserInteractions.\n * @memberOf api/analytic\n */\nexport const userInteractionDefineMethod = new ValidatedMethod({\n  name: 'UserInteraction.define',\n  validate: null,\n  mixins: [CallPromiseMixin],\n  run(interactionData) {\n    UserInteractions.assertValidRoleForMethod(this.userId);\n    return UserInteractions.define(interactionData);\n  },\n});\n\n/**\n * The validated method for removing UserInteractions.\n * @memberOf api/analytic\n */\nexport const userInteractionRemoveUserMethod = new ValidatedMethod({\n  name: 'UserInteraction.removeUser',\n  validate: null,\n  mixins: [CallPromiseMixin],\n  run(instances) {\n    UserInteractions.assertAdminRoleForMethod(this.userId);\n    return UserInteractions.removeUser(instances);\n  },\n});\n\n/**\n * The validated method for finding UserInteractions.\n * @memberOf api/analytic\n */\nexport const userInteractionFindMethod = new ValidatedMethod({\n  name: 'UserInteraction.find',\n  validate: null,\n  mixins: [CallPromiseMixin],\n  run({ selector, options }) {\n    UserInteractions.assertAdminRoleForMethod(this.userId);\n    const results = UserInteractions.find(selector, options);\n    return results.fetch();\n  },\n});\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/analytic/UserInteractionCollection.methods.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 110,
    "kind": "variable",
    "name": "userInteractionDefineMethod",
    "memberof": "api/analytic/UserInteractionCollection.methods.ts",
    "static": true,
    "longname": "api/analytic/UserInteractionCollection.methods.ts~userInteractionDefineMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/analytic/UserInteractionCollection.methods.ts",
    "importStyle": "{userInteractionDefineMethod}",
    "description": "The validated method for defining UserInteractions.",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/analytic"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 111,
    "kind": "variable",
    "name": "userInteractionRemoveUserMethod",
    "memberof": "api/analytic/UserInteractionCollection.methods.ts",
    "static": true,
    "longname": "api/analytic/UserInteractionCollection.methods.ts~userInteractionRemoveUserMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/analytic/UserInteractionCollection.methods.ts",
    "importStyle": "{userInteractionRemoveUserMethod}",
    "description": "The validated method for removing UserInteractions.",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/analytic"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 112,
    "kind": "variable",
    "name": "userInteractionFindMethod",
    "memberof": "api/analytic/UserInteractionCollection.methods.ts",
    "static": true,
    "longname": "api/analytic/UserInteractionCollection.methods.ts~userInteractionFindMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/analytic/UserInteractionCollection.methods.ts",
    "importStyle": "{userInteractionFindMethod}",
    "description": "The validated method for finding UserInteractions.",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/analytic"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 113,
    "kind": "file",
    "name": "api/analytic/UserInteractionCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport faker from 'faker';\nimport fc from 'fast-check';\nimport 'mocha';\nimport { Users } from '../user/UserCollection';\nimport { UserInteractions } from './UserInteractionCollection';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { IUserInteraction } from '../../typings/radgrad';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('UserInteractionCollection', function testSuite() {\n    let username;\n\n    before(function setup() {\n      removeAllEntities();\n      const userID = makeSampleUser();\n      username = Users.getProfile(userID).username;\n    });\n\n    after(function tearDown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1() {\n      fc.assert(\n        fc.property(fc.lorem(1), fc.array(fc.lorem(1), 1, 5), (type, typeData) => {\n          const docID = UserInteractions.define({ username, type, typeData });\n          expect(UserInteractions.isDefined(docID)).to.be.true;\n          UserInteractions.removeIt(docID);\n          expect(UserInteractions.isDefined(docID)).to.be.false;\n        }),\n      );\n    });\n\n    it('Cannot define duplicates', function test2() {\n      const type: string = faker.lorem.word();\n      const typeData: string[] = [faker.lorem.word(), faker.lorem.word()];\n      const docID1: string = UserInteractions.define({ username, type, typeData });\n      const docID1Object: IUserInteraction = UserInteractions.findOne({ _id: docID1 });\n      const docID1Timestamp: Date = docID1Object.timestamp;\n      const docID2: string = UserInteractions.define({ username, type, typeData, timestamp: docID1Timestamp });\n\n      expect(docID1).to.equal(docID2);\n      expect(UserInteractions.isDefined(docID1)).to.be.true;\n      UserInteractions.removeIt(docID2);\n      expect(UserInteractions.isDefined(docID1)).to.be.false;\n    });\n\n    it('Can restoreOne then dumpOne', function test3() {\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(1), fc.array(fc.lorem(1), 1, 5), fc.date(), (name, type, typeData, timestamp) => {\n          const dumpObject = {\n            username: name,\n            type,\n            typeData,\n            timestamp,\n          };\n          const docID = UserInteractions.restoreOne(dumpObject);\n          expect(UserInteractions.isDefined(docID)).to.be.true;\n          const dumpObject2 = UserInteractions.dumpOne(docID);\n          expect(dumpObject2.username).to.equal(dumpObject.username);\n          expect(dumpObject2.type).to.equal(dumpObject.type);\n          expect(dumpObject2.typeData.length).to.equal(dumpObject.typeData.length);\n          for (let i = 0; i < dumpObject2.typeData.length; i++) {\n            expect(dumpObject2.typeData[i]).to.equal(dumpObject.typeData[i]);\n          }\n        }),\n      );\n    });\n\n    it('Can checkIntegrity all errors', function test4() {\n      fc.assert(\n        fc.property(fc.lorem(1), fc.array(fc.lorem(1), 1, 5), (type, typeData) => {\n          UserInteractions.define({ username, type, typeData });\n        }),\n      );\n      const errors = UserInteractions.checkIntegrity();\n      expect(errors).to.have.lengthOf(100);\n    });\n\n    it('Can removeUser', function test5() {\n      fc.assert(\n        fc.property(fc.lorem(1), fc.array(fc.lorem(1), 1, 5), (type, typeData) => {\n          UserInteractions.define({ username, type, typeData });\n        }),\n      );\n      UserInteractions.removeUser(username);\n      const interactions = UserInteractions.find({ username }).fetch();\n      expect(interactions).to.have.lengthOf(0);\n    });\n\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/analytic/UserInteractionCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 114,
    "kind": "file",
    "name": "api/analytic/UserInteractionCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport moment from 'moment';\nimport SimpleSchema from 'simpl-schema';\nimport BaseCollection from '../base/BaseCollection';\nimport { Users } from '../user/UserCollection';\nimport { ROLE } from '../role/Role';\nimport { IUserInteractionDefine } from '../../typings/radgrad';\n\n/**\n * Represents a log of user interactions with RadGrad.\n * An interaction may be a profile update or a page visit, such as a student updating their\n * career goals, or visiting the degree planner.\n *\n * username is the username of the user that performed the interaction.\n * type is one of the following:\n *   pageView: the user is now visiting a page.  (typeData: path to page)\n *   login: the user has just logged in. (typeData: \"N/A\").\n *   interestIDs, careerGoalIDs, academicPlanIDs, declaredAcademicTermID, picture, website: user modifies fields.\n *   (typeData: shows the new set of IDs after the modification).\n *   addCourse, addOpportunity, removeCourse, removeOpportunity: user added/removed an instance\n * @extends api/base.BaseCollection\n * @memberOf api/analytic\n */\nclass UserInteractionCollection extends BaseCollection {\n\n  /**\n   * Creates the UserInteraction collection\n   */\n  constructor() {\n    super('UserInteraction', new SimpleSchema({\n      username: { type: String },\n      type: { type: String },\n      typeData: Array,\n      'typeData.$': String,\n      timestamp: { type: Date },\n    }));\n    if (Meteor.isServer) {\n      this.collection.rawCollection().createIndex({ username: 1, type: 1 });\n    }\n\n  }\n\n  /**\n   * Defines a user interaction record.\n   * @param username The username.\n   * @param type The interaction type.\n   * @param typeData Any data associated with the interaction type.\n   * @param timestamp The time of interaction.\n   */\n  public define({ username, type, typeData, timestamp = moment().toDate() }: IUserInteractionDefine): string {\n    const doc = this.collection.findOne({ username, type, typeData, timestamp });\n    if (doc) {\n      return doc._id;\n    }\n    return this.collection.insert({ username, type, typeData, timestamp });\n  }\n\n  /**\n   * Removes all interaction documents from referenced user.\n   * @param username The username of user to be removed.\n   * @throws { Meteor.Error } If user is not an ID or username.\n   */\n  public removeUser(username: string) {\n    this.collection.remove({ username });\n  }\n\n  /**\n   * Asserts that the userID belongs to an admin role when running the find and removeUser method\n   * within this class.\n   * @param userId The userId of the logged in user.\n   */\n  public assertAdminRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN]);\n  }\n\n  /**\n   * Asserts that the userID belongs to a valid role when running the define method\n   * within this class.\n   * @param userId The userId of the logged in user.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.STUDENT, ROLE.ADVISOR, ROLE.MENTOR, ROLE.FACULTY]);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity(): string[] {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (!Users.isDefined(doc.username)) {\n        problems.push(`Bad user: ${doc.username}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the UserInteraction docID in a format acceptable to define().\n   * @param docID The docID of a UserInteraction.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IUserInteractionDefine {\n    const doc = this.findDoc(docID);\n    const username = doc.username;\n    const timestamp = doc.timestamp;\n    const type = doc.type;\n    const typeData = doc.typeData;\n    return { username, type, typeData, timestamp };\n  }\n\n  /**\n   * Publish a cursor to UserInteractions. Method calls are used to find interactions and we do not subscribe to\n   * UserInteractions on the client. However, we would still like this to be on the list of collections\n   * for integrity check, etc.\n   */\n  public publish() {\n    if (Meteor.isServer) {\n      Meteor.publish(this.collectionName, () => this.collection.find());\n    }\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @type {api/log.UserInteractionCollection}\n * @memberOf api/analytic\n */\nexport const UserInteractions = new UserInteractionCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/analytic/UserInteractionCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 115,
    "kind": "variable",
    "name": "UserInteractions",
    "memberof": "api/analytic/UserInteractionCollection.ts",
    "static": true,
    "longname": "api/analytic/UserInteractionCollection.ts~UserInteractions",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/analytic/UserInteractionCollection.ts",
    "importStyle": "{UserInteractions}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 144,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/analytic"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/log.UserInteractionCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 116,
    "kind": "class",
    "name": "UserInteractionCollection",
    "memberof": "api/analytic/UserInteractionCollection.ts",
    "static": true,
    "longname": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/analytic/UserInteractionCollection.ts",
    "importStyle": null,
    "description": "Represents a log of user interactions with RadGrad.\nAn interaction may be a profile update or a page visit, such as a student updating their\ncareer goals, or visiting the degree planner.\n\nusername is the username of the user that performed the interaction.\ntype is one of the following:\npageView: the user is now visiting a page.  (typeData: path to page)\nlogin: the user has just logged in. (typeData: \"N/A\").\ninterestIDs, careerGoalIDs, academicPlanIDs, declaredAcademicTermID, picture, website: user modifies fields.\n(typeData: shows the new set of IDs after the modification).\naddCourse, addOpportunity, removeCourse, removeOpportunity: user added/removed an instance",
    "lineNumber": 24,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 117,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection#constructor",
    "access": "public",
    "description": "Creates the UserInteraction collection",
    "lineNumber": 27
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "define",
    "memberof": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection#define",
    "access": "public",
    "description": "Defines a user interaction record.",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "IUserInteractionDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 119,
    "kind": "method",
    "name": "removeUser",
    "memberof": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection#removeUser",
    "access": "public",
    "description": "Removes all interaction documents from referenced user.",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "assertAdminRoleForMethod",
    "memberof": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection#assertAdminRoleForMethod",
    "access": "public",
    "description": "Asserts that the userID belongs to an admin role when running the find and removeUser method\nwithin this class.",
    "lineNumber": 72,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Asserts that the userID belongs to a valid role when running the define method\nwithin this class.",
    "lineNumber": 81,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 122,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.",
    "lineNumber": 90,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the UserInteraction docID in a format acceptable to define().",
    "lineNumber": 105,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IUserInteractionDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 124,
    "kind": "method",
    "name": "publish",
    "memberof": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/analytic/UserInteractionCollection.ts~UserInteractionCollection#publish",
    "access": "public",
    "description": "Publish a cursor to UserInteractions. Method calls are used to find interactions and we do not subscribe to\nUserInteractions on the client. However, we would still like this to be on the list of collections\nfor integrity check, etc.",
    "lineNumber": 119,
    "params": [],
    "return": null
  },
  {
    "__docId__": 125,
    "kind": "file",
    "name": "api/analytic/UserInteractionsTypes.ts",
    "content": "// UserInteraction Types\nexport enum UserInteractionsTypes {\n  /* General Tracking */\n  PAGEVIEW = 'pageView',\n  LOGIN = 'login',\n  LOGOUT = 'logout',\n  LEVEL = 'level',\n  COMPLETEPLAN = 'completePlan',\n  /* Student About Me Page */\n  PICTURE = 'picture',\n  WEBSITE = 'website',\n  SHAREINFORMATION = 'shareInformation',\n  /* Degree Planner */\n  // Dragging a course/opportunity to the planner\n  ADDCOURSE = 'addCourse',\n  ADDOPPORTUNITY = 'addOpportunity',\n  // Moving a course/opportunity from a term to another term\n  UPDATECOURSE = 'updateCourse',\n  UPDATEOPPORTUNITY = 'updateOpportunity',\n  // Removing a course/opportunity from the planner\n  REMOVECOURSE = 'removeCourse',\n  REMOVEOPPORTUNITY = 'removeOpportunity',\n  /* Favorites */\n  FAVORITEITEM = 'favoriteItem',\n  UNFAVORITEITEM = 'unFavoriteItem',\n  /* Reviews */\n  ADDREVIEW = 'addReview',\n  EDITREVIEW = 'editReview',\n  /* Mentor Space */\n  ASKQUESTION = 'askQuestion',\n  /* Degree Planner */\n  VERIFYREQUEST = 'verifyRequest',\n}\n\n// Default string if we do not need to store a typeData for that User Interaction\nexport const USERINTERACTIONSNOTYPEDATA = 'N/A';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/analytic/UserInteractionsTypes.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 126,
    "kind": "variable",
    "name": "USERINTERACTIONSNOTYPEDATA",
    "memberof": "api/analytic/UserInteractionsTypes.ts",
    "static": true,
    "longname": "api/analytic/UserInteractionsTypes.ts~USERINTERACTIONSNOTYPEDATA",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/analytic/UserInteractionsTypes.ts",
    "importStyle": "{USERINTERACTIONSNOTYPEDATA}",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 127,
    "kind": "file",
    "name": "api/analytic/index.ts",
    "content": "/** @namespace api/analytic */\nimport './UserInteractionCollection';\nimport './UserInteractionsTypes';\nimport './UserInteractionCollection.methods';\nimport './IceSnapshotCollection';\nimport './Email';\nimport './Email.methods';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/analytic/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 128,
    "kind": "file",
    "name": "api/base/BaseCollection.methods.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { CallPromiseMixin } from 'meteor/didericis:callpromise-mixin';\nimport { ValidatedMethod } from 'meteor/mdg:validated-method';\nimport _ from 'lodash';\nimport { RadGrad } from '../radgrad/RadGrad';\nimport { ROLE } from '../role/Role';\nimport { Users } from '../user/UserCollection';\nimport { loadCollectionNewDataOnly } from '../utilities/load-fixtures';\n\n/**\n * Allows admins to create and return a JSON object to the client representing a snapshot of the RadGrad database.\n * @memberOf api/base\n */\nexport const dumpDatabaseMethod = new ValidatedMethod({\n  name: 'base.dumpDatabase',\n  validate: null,\n  run() {\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to dump the database..');\n    } else {\n      const profile = Users.getProfile(this.userId);\n      if (profile.role !== ROLE.ADMIN) {\n        throw new Meteor.Error('unauthorized', 'You must be an admin to dump the database.');\n      }\n    }\n    // Don't do the dump except on server side (disable client-side simulation).\n    // Return an object with fields timestamp and collections.\n    if (Meteor.isServer) {\n      const collections = _.sortBy(RadGrad.collectionLoadSequence.map((collection) => collection.dumpAll()),\n        (entry) => entry.name);\n      const timestamp = new Date();\n      return { timestamp, collections };\n    }\n    return null;\n  },\n});\n\n/**\n * Meteor method used to define new instances of the given collection name.\n * @param collectionName the name of the collection.\n * @param definitionDate the object used in the collection.define method.\n * @memberOf api/base\n */\nexport const defineMethod = new ValidatedMethod({\n  name: 'BaseCollection.define',\n  mixins: [CallPromiseMixin],\n  validate: null,\n  run({ collectionName, definitionData }) {\n    // console.log(collectionName, this.userId, definitionData);\n    const collection = RadGrad.getCollection(collectionName);\n    collection.assertValidRoleForMethod(this.userId);\n    return collection.define(definitionData);\n  },\n});\n\nexport const updateMethod = new ValidatedMethod({\n  name: 'BaseCollection.update',\n  mixins: [CallPromiseMixin],\n  validate: null,\n  run({ collectionName, updateData }) {\n    // console.log('updateMethod(%o, %o)', collectionName, updateData);\n    const collection = RadGrad.getCollection(collectionName);\n    collection.assertValidRoleForMethod(this.userId);\n    collection.update(updateData.id, updateData);\n    return true;\n  },\n});\n\nexport const removeItMethod = new ValidatedMethod({\n  name: 'BaseCollection.removeIt',\n  mixins: [CallPromiseMixin],\n  validate: null,\n  run({ collectionName, instance }) {\n    const collection = RadGrad.getCollection(collectionName);\n    collection.assertValidRoleForMethod(this.userId);\n    collection.removeIt(instance);\n    return true;\n  },\n});\n\nexport const loadFixtureMethod = new ValidatedMethod({\n  name: 'base.loadFixture',\n  validate: null,\n  run(fixtureData) {\n    // console.log('loadFixtureMethod', fixtureData);\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to load a fixture.', '');\n    } else if (!Roles.userIsInRole(this.userId, [ROLE.ADMIN])) {\n      throw new Meteor.Error('unauthorized', 'You must be an admin to load a fixture.', '');\n    }\n    if (Meteor.isServer) {\n      let ret = '';\n      // console.log(RadGrad.collectionLoadSequence);\n      _.forEach(RadGrad.collectionLoadSequence, (collection) => {\n        const result = loadCollectionNewDataOnly(collection, fixtureData, true);\n        // console.log(collection.getCollectionName(), result);\n        if (result) {\n          ret = `${ret} ${result},`;\n        }\n      });\n      // console.log(`loadFixtureMethod ${ret}`);\n      const trimmed = ret.trim();\n      if (trimmed.length === 0) {\n        ret = 'Defined no new instances.';\n      } else {\n        ret = ret.substring(0, ret.length - 1); // trim off trailing ,\n      }\n      return ret;\n    }\n    return '';\n  },\n});\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/base/BaseCollection.methods.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 129,
    "kind": "variable",
    "name": "dumpDatabaseMethod",
    "memberof": "api/base/BaseCollection.methods.ts",
    "static": true,
    "longname": "api/base/BaseCollection.methods.ts~dumpDatabaseMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/base/BaseCollection.methods.ts",
    "importStyle": "{dumpDatabaseMethod}",
    "description": "Allows admins to create and return a JSON object to the client representing a snapshot of the RadGrad database.",
    "lineNumber": 13,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/base"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 130,
    "kind": "variable",
    "name": "defineMethod",
    "memberof": "api/base/BaseCollection.methods.ts",
    "static": true,
    "longname": "api/base/BaseCollection.methods.ts~defineMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/base/BaseCollection.methods.ts",
    "importStyle": "{defineMethod}",
    "description": "Meteor method used to define new instances of the given collection name.",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/base"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "collectionName",
        "description": "the name of the collection."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "definitionDate",
        "description": "the object used in the collection.define method."
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 131,
    "kind": "variable",
    "name": "updateMethod",
    "memberof": "api/base/BaseCollection.methods.ts",
    "static": true,
    "longname": "api/base/BaseCollection.methods.ts~updateMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/base/BaseCollection.methods.ts",
    "importStyle": "{updateMethod}",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 132,
    "kind": "variable",
    "name": "removeItMethod",
    "memberof": "api/base/BaseCollection.methods.ts",
    "static": true,
    "longname": "api/base/BaseCollection.methods.ts~removeItMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/base/BaseCollection.methods.ts",
    "importStyle": "{removeItMethod}",
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 133,
    "kind": "variable",
    "name": "loadFixtureMethod",
    "memberof": "api/base/BaseCollection.methods.ts",
    "static": true,
    "longname": "api/base/BaseCollection.methods.ts~loadFixtureMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/base/BaseCollection.methods.ts",
    "importStyle": "{loadFixtureMethod}",
    "description": null,
    "lineNumber": 106,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 134,
    "kind": "file",
    "name": "api/base/BaseCollection.ts",
    "content": "import { Roles } from 'meteor/alanning:roles';\nimport { check } from 'meteor/check';\nimport _ from 'lodash';\nimport { Meteor } from 'meteor/meteor';\nimport { Mongo } from 'meteor/mongo';\nimport { ROLE } from '../role/Role';\nimport { IDumpOne } from '../../typings/radgrad';\n\n/**\n * BaseCollection is an abstract superclass of all RadGrad data model entities.\n * It is the direct superclass for SlugCollection and AcademicTermCollection.\n * Other collection classes are derived from BaseSlugCollection or BaseTypeCollection, which are abstract\n * classes that inherit from this one.\n */\nclass BaseCollection {\n  protected collection: Mongo.Collection<any>;\n  protected collectionName: string;\n  protected schema: any;\n  protected type: string;\n  protected defineSchema: any;\n  protected updateSchema: any;\n\n  /**\n   * Superclass constructor for all RadGrad entities.\n   * Defines internal fields needed by all entities: type, collectionName, collection, and schema.\n   * @param {String} type The name of the entity defined by the subclass.\n   * @param {SimpleSchema} schema The schema for validating fields on insertion to the DB.\n   */\n  constructor(type: string, schema: any) {\n    this.type = type;\n    this.collectionName = `${type}Collection`;\n    this.collection = new Mongo.Collection(`${type}Collection`);\n    this.schema = schema;\n    this.collection.attachSchema(this.schema);\n  }\n\n  /**\n   * Define documents for the collection.\n   * @param obj the document.\n   * @throws Meteor.Error since shouldn't call this method on the base class.\n   */\n  public define(obj: object): string {\n    throw new Meteor.Error(`Default define method invoked by collection ${this.collectionName} ${obj}`);\n  }\n\n  /**\n   * Returns the number of documents in this collection.\n   * @returns { Number } The number of elements in this collection.\n   */\n  public count() {\n    return this.collection.find().count();\n  }\n\n  /**\n   * Returns the number of non-retired documents in this collection.\n   * @returns { Number } The number of non-retired elements in this collection.\n   */\n  public countNonRetired() {\n    return _.filter(this.collection.find().fetch(), (doc) => !doc.retired).length;\n  }\n\n  /**\n   * Default publication method for entities.\n   * It publishes the entire collection.\n   */\n  public publish() {\n    if (Meteor.isServer) {\n      Meteor.publish(this.collectionName, () => this.collection.find());\n    }\n  }\n\n  /**\n   * Default subscription method for entities.\n   * It subscribes to the entire collection.\n   */\n  public subscribe(userID = undefined) {\n    if (Meteor.isClient) {\n      // console.log(`${this.collectionName}.subscribe`, userID);\n      Meteor.subscribe(this.collectionName, userID);\n    }\n  }\n\n  /**\n   * A stricter form of findOne, in that it throws an exception if the entity isn't found in the collection.\n   * @param { String | Object } name Either the docID, or an object selector, or the 'name' field value.\n   * @returns { Object } The document associated with name.\n   * @throws { Meteor.Error } If the document cannot be found.\n   */\n  public findDoc(name: string | object | { name } | { _id: string; } | { username: string; }) {\n    if (_.isNull(name) || _.isUndefined(name)) {\n      throw new Meteor.Error(`${name} is not a defined ${this.type}`);\n    }\n    const doc = (\n      this.collection.findOne(name) ||\n      this.collection.findOne({ name }) ||\n      this.collection.findOne({ _id: name }) ||\n      this.collection.findOne({ username: name }));\n    if (!doc) {\n      if (typeof name !== 'string') {\n        throw new Meteor.Error(`${JSON.stringify(name)} is not a defined ${this.type}`);\n      } else {\n        throw new Meteor.Error(`${name} is not a defined ${this.type}`);\n      }\n    }\n    return doc;\n  }\n\n  /**\n   * Runs find on this collection.\n   * @see {@link http://docs.meteor.com/#/full/find|Meteor Docs on Mongo Find}\n   * @param { Object } selector A MongoDB selector.\n   * @param { Object } options MongoDB options.\n   * @returns {Mongo.Cursor}\n   */\n  public find(selector?: object, options?: object) {\n    const theSelector = (typeof selector === 'undefined') ? {} : selector;\n    return this.collection.find(theSelector, options);\n  }\n\n  /**\n   * Runs find on this collection and returns the non-retired documents.\n   * @see {@link http://docs.meteor.com/#/full/find|Meteor Docs on Mongo Find}\n   * @param selector { Object } A MongoDB selector.\n   * @param options { Object } MongoDB options.\n   * @returns { Array } non-retired documents.\n   */\n  public findNonRetired(selector?: object, options?: object) {\n    const theSelector = (typeof selector === 'undefined') ? {} : selector;\n    return _.filter(this.collection.find(theSelector, options).fetch(), (doc) => !doc.retired);\n  }\n\n  /**\n   * Runs findOne on this collection.\n   * @see {@link http://docs.meteor.com/#/full/findOne|Meteor Docs on Mongo Find}\n   * @param { Object } selector A MongoDB selector.\n   * @param { Object } options MongoDB options.\n   * @returns {Mongo.Cursor}\n   */\n  public findOne(selector: object, options?: object) {\n    const theSelector = (typeof selector === 'undefined') ? {} : selector;\n    return this.collection.findOne(theSelector, options);\n  }\n\n  /**\n   * Runs a simplified version of update on this collection.\n   * @see {@link http://docs.meteor.com/api/collections.html#Mongo-Collection-update}\n   * @param { Object } selector A MongoDB selector.\n   * @param { Object } modifier A MongoDB modifier\n   * @returns true\n   */\n  // public update(selector, modifier) {\n  //   const theSelector = (typeof selector === 'undefined') ? {} : selector;\n  //   this.collection.update(theSelector, modifier);\n  //   return true;\n  // }\n\n  /**\n   * Returns true if the passed entity is in this collection.\n   * @param { String | Object } name The docID, or an object specifying a documennt.\n   * @returns {boolean} True if name exists in this collection.\n   */\n  public isDefined(name: string) {\n    if (_.isUndefined(name)) {\n      return false;\n    }\n    return (\n      !!this.collection.findOne(name) ||\n      !!this.collection.findOne({ name }) ||\n      !!this.collection.findOne({ _id: name }));\n  }\n\n  /**\n   * A stricter form of remove that throws an error if the document or docID could not be found in this collection.\n   * @param { String | Object } name A document or docID in this collection.\n   * @returns true\n   */\n  public removeIt(name: string | object): boolean {\n    const doc = this.findDoc(name);\n    check(doc, Object);\n    // @ts-ignore\n    this.collection.remove(doc._id);\n    return true;\n  }\n\n  /**\n   * Removes all elements of this collection.\n   * This is implemented by mapping through all elements because mini-mongo does not implement the remove operation.\n   * So this approach can be used on both client and server side.\n   * removeAll should only used for testing purposes, so it doesn't need to be efficient.\n   * @returns true\n   */\n  public removeAll() {\n    const items = this.collection.find().fetch();\n    const instance = this;\n    _.forEach(items, (i) => {\n      instance.removeIt(i._id);\n    });\n    return true;\n  }\n\n  /**\n   * Return the type of this collection.\n   * @returns { String } The type, as a string.\n   */\n  public getType() {\n    return this.type;\n  }\n\n  /**\n   * Returns the schema applied to the collection.\n   * @return { SimpleSchema }.\n   */\n  public getCollectionSchema() {\n    return this.schema;\n  }\n\n  /**\n   * Returns a schema for the define method's parameter.\n   * @returns { SimpleSchema } the define method's parameter.\n   */\n  public getDefineSchema() {\n    return this.defineSchema;\n  }\n\n  /**\n   * Returns a schema for the update method's second parameter.\n   * @returns { SimpleSchema }.\n   */\n  public getUpdateSchema() {\n    return this.updateSchema;\n  }\n\n  /**\n   * Return the publication name.\n   * @returns { String } The publication name, as a string.\n   */\n  public getPublicationName() {\n    return this.collectionName;\n  }\n\n  /**\n   * Returns the collection name.\n   * @return {string} The collection name as a string.\n   */\n  public getCollectionName() {\n    return this.collectionName;\n  }\n\n  /**\n   * Returns the Mongo collection.\n   * @return {Mongo.Collection} The collection.\n   */\n  public getCollection() {\n    return this.collection;\n  }\n\n  /**\n   * Returns a string representing all of the documents in this collection.\n   * @returns {String}\n   */\n  public toString(...rest: any[]): string {\n    return this.collection.find().fetch().toString();\n  }\n\n  /**\n   * Verifies that the passed object is one of this collection's instances.\n   * @param { String | List } name Should be a defined ID or doc in this collection.\n   * @throws { Meteor.Error } If not defined.\n   */\n  public assertDefined(name: string) {\n    if (!this.isDefined(name)) {\n      throw new Meteor.Error(`${name} is not a valid instance of ${this.type}.`);\n    }\n  }\n\n  /**\n   * Verifies that the list of passed instances are all members of this collection.\n   * @param names Should be a list of docs and/or docIDs.\n   * @throws { Meteor.Error } If instances is not an array, or if any instance is not in this collection.\n   */\n  public assertAllDefined(names: string[]) {\n    if (!_.isArray(names)) {\n      throw new Meteor.Error(`${names} is not an array.`);\n    }\n    names.map((name) => this.assertDefined(name));\n  }\n\n  /**\n   * Default implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin or Advisor.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR]);\n  }\n\n  /**\n   * Define the default integrity checker for all applications.\n   * Returns an array with a string indicating that this method is not overridden.\n   * @returns { array } An array containing a string indicating the use of the default integrity checker.\n   */\n  public checkIntegrity() {\n    return ['There is no integrity checker defined for this collection.'];\n  }\n\n  /**\n   * Returns an object with two fields: name and contents.\n   * Name is the name of this collection.\n   * Contents is an array of objects suitable for passing to the restore() method.\n   * @returns {Object} An object representing the contents of this collection.\n   */\n  public dumpAll() {\n    const dumpObject: { name: string; contents: IDumpOne[]; } = {\n      name: this.collectionName,\n      contents: this.find().map((docID): IDumpOne => this.dumpOne(docID)),\n    };\n    // If a collection doesn't want to be dumped, it can just return null from dumpOne.\n    dumpObject.contents = _.without(dumpObject.contents, null);\n    // sort the contents array by slug (if present)\n    if (dumpObject.contents[0] && dumpObject.contents[0].slug) {\n      dumpObject.contents = _.sortBy(dumpObject.contents, (obj) => obj.slug);\n    }\n    return dumpObject;\n  }\n\n  /**\n   * Returns an object representing the definition of docID in a format appropriate to the restoreOne function.\n   * Must be overridden by each collection.\n   * @param docID A docID from this collection.\n   * @returns { Object } An object representing this document.\n   */\n  public dumpOne(docID): IDumpOne {\n    throw new Meteor.Error(`Default dumpOne method invoked by collection ${this.collectionName} on ${docID}`);\n  }\n\n  /**\n   * Defines the entity represented by dumpObject.\n   * Defaults to calling the define() method if it exists.\n   * @param dumpObject An object representing one document in this collection.\n   * @returns { String } The docID of the newly created document.\n   */\n  public restoreOne(dumpObject): string {\n    if (typeof this.define === 'function') {\n      return this.define(dumpObject);\n    }\n    return null;\n  }\n\n  /**\n   * Defines all the entities in the passed array of objects.\n   * @param dumpObjects The array of objects representing the definition of a document in this collection.\n   */\n  public restoreAll(dumpObjects) {\n    _.each(dumpObjects, (dumpObject) => this.restoreOne(dumpObject));\n  }\n\n  /**\n   * Internal helper function to simplify definition of the assertValidRoleForMethod method.\n   * @param userId The userID.\n   * @param roles An array of roles.\n   * @throws { Meteor.Error } If userId is not defined or user is not in the specified roles.\n   * @returns True if no error is thrown.\n   * @ignore\n   */\n  protected assertRole(userId: string, roles: string[]): boolean {\n    // console.log(userId, roles, Roles.userIsInRole(userId, roles));\n    if (!userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in.');\n    } else if (!Roles.userIsInRole(userId, roles)) {\n      throw new Meteor.Error('unauthorized', `You must be one of the following roles: ${roles}`);\n    }\n    return true;\n  }\n\n  /**\n   * Internal helper function to simplify definition of the updateData for updateMethod.\n   * @param userId The userID.\n   * @param roles An array of roles.\n   * @returns true if the user is in the roles, false otherwise.\n   * @ignore\n   */\n  protected hasRole(userId, roles) {\n    if (!userId) {\n      return false;\n    }\n    return Roles.userIsInRole(userId, roles);\n  }\n}\n\n/**\n * The BaseCollection used by all RadGrad entities.\n */\nexport default BaseCollection;\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/base/BaseCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 135,
    "kind": "class",
    "name": "BaseCollection",
    "memberof": "api/base/BaseCollection.ts",
    "static": true,
    "longname": "api/base/BaseCollection.ts~BaseCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/base/BaseCollection.ts",
    "importStyle": "BaseCollection",
    "description": "BaseCollection is an abstract superclass of all RadGrad data model entities.\nIt is the direct superclass for SlugCollection and AcademicTermCollection.\nOther collection classes are derived from BaseSlugCollection or BaseTypeCollection, which are abstract\nclasses that inherit from this one.",
    "lineNumber": 15,
    "interface": false
  },
  {
    "__docId__": 136,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#constructor",
    "access": "public",
    "description": "Superclass constructor for all RadGrad entities.\nDefines internal fields needed by all entities: type, collectionName, collection, and schema.",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "The name of the entity defined by the subclass."
      },
      {
        "nullable": null,
        "types": [
          "SimpleSchema"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "The schema for validating fields on insertion to the DB."
      }
    ]
  },
  {
    "__docId__": 137,
    "kind": "member",
    "name": "type",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#type",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "member",
    "name": "collectionName",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#collectionName",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 139,
    "kind": "member",
    "name": "collection",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#collection",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "member",
    "name": "schema",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#schema",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "method",
    "name": "define",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#define",
    "access": "public",
    "description": "Define documents for the collection.",
    "lineNumber": 42,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 142,
    "kind": "method",
    "name": "count",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#count",
    "access": "public",
    "description": "Returns the number of documents in this collection.",
    "lineNumber": 50,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "method",
    "name": "countNonRetired",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#countNonRetired",
    "access": "public",
    "description": "Returns the number of non-retired documents in this collection.",
    "lineNumber": 58,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "publish",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#publish",
    "access": "public",
    "description": "Default publication method for entities.\nIt publishes the entire collection.",
    "lineNumber": 66,
    "params": [],
    "return": null
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "subscribe",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#subscribe",
    "access": "public",
    "description": "Default subscription method for entities.\nIt subscribes to the entire collection.",
    "lineNumber": 76,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "userID",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 146,
    "kind": "method",
    "name": "findDoc",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#findDoc",
    "access": "public",
    "description": "A stricter form of findOne, in that it throws an exception if the entity isn't found in the collection.",
    "lineNumber": 89,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "method",
    "name": "find",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#find",
    "access": "public",
    "description": "Runs find on this collection.",
    "lineNumber": 115,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "selector",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "findNonRetired",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#findNonRetired",
    "access": "public",
    "description": "Runs find on this collection and returns the non-retired documents.",
    "lineNumber": 127,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "selector",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "findOne",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#findOne",
    "access": "public",
    "description": "Runs findOne on this collection.",
    "lineNumber": 139,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "selector",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "isDefined",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#isDefined",
    "access": "public",
    "description": "Runs a simplified version of update on this collection.",
    "see": [
      "{@link http://docs.meteor.com/api/collections.html#Mongo-Collection-update}"
    ],
    "lineNumber": 176,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "true"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          " Object "
        ],
        "spread": false,
        "optional": false,
        "name": "selector",
        "description": "A MongoDB selector."
      },
      {
        "nullable": null,
        "types": [
          " Object "
        ],
        "spread": false,
        "optional": false,
        "name": "modifier",
        "description": "A MongoDB modifier"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "true"
    }
  },
  {
    "__docId__": 151,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#removeIt",
    "access": "public",
    "description": "A stricter form of remove that throws an error if the document or docID could not be found in this collection.",
    "lineNumber": 177,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 152,
    "kind": "method",
    "name": "removeAll",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#removeAll",
    "access": "public",
    "description": "Removes all elements of this collection.\nThis is implemented by mapping through all elements because mini-mongo does not implement the remove operation.\nSo this approach can be used on both client and server side.\nremoveAll should only used for testing purposes, so it doesn't need to be efficient.",
    "lineNumber": 192,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 153,
    "kind": "method",
    "name": "getType",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#getType",
    "access": "public",
    "description": "Return the type of this collection.",
    "lineNumber": 205,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 154,
    "kind": "method",
    "name": "getCollectionSchema",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#getCollectionSchema",
    "access": "public",
    "description": "Returns the schema applied to the collection.",
    "lineNumber": 213,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 155,
    "kind": "method",
    "name": "getDefineSchema",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#getDefineSchema",
    "access": "public",
    "description": "Returns a schema for the define method's parameter.",
    "lineNumber": 221,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 156,
    "kind": "method",
    "name": "getUpdateSchema",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#getUpdateSchema",
    "access": "public",
    "description": "Returns a schema for the update method's second parameter.",
    "lineNumber": 229,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 157,
    "kind": "method",
    "name": "getPublicationName",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#getPublicationName",
    "access": "public",
    "description": "Return the publication name.",
    "lineNumber": 237,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "getCollectionName",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#getCollectionName",
    "access": "public",
    "description": "Returns the collection name.",
    "lineNumber": 245,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 159,
    "kind": "method",
    "name": "getCollection",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#getCollection",
    "access": "public",
    "description": "Returns the Mongo collection.",
    "lineNumber": 253,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 160,
    "kind": "method",
    "name": "toString",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#toString",
    "access": "public",
    "description": "Returns a string representing all of the documents in this collection.",
    "lineNumber": 261,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "rest",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "assertDefined",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#assertDefined",
    "access": "public",
    "description": "Verifies that the passed object is one of this collection's instances.",
    "lineNumber": 270,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "assertAllDefined",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#assertAllDefined",
    "access": "public",
    "description": "Verifies that the list of passed instances are all members of this collection.",
    "lineNumber": 281,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "names",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Default implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin or Advisor.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 294,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#checkIntegrity",
    "access": "public",
    "description": "Define the default integrity checker for all applications.\nReturns an array with a string indicating that this method is not overridden.",
    "lineNumber": 303,
    "params": [],
    "return": {
      "types": [
        "string[]"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "dumpAll",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#dumpAll",
    "access": "public",
    "description": "Returns an object with two fields: name and contents.\nName is the name of this collection.\nContents is an array of objects suitable for passing to the restore() method.",
    "lineNumber": 313,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 166,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the definition of docID in a format appropriate to the restoreOne function.\nMust be overridden by each collection.",
    "lineNumber": 333,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IDumpOne"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "restoreOne",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#restoreOne",
    "access": "public",
    "description": "Defines the entity represented by dumpObject.\nDefaults to calling the define() method if it exists.",
    "lineNumber": 343,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "dumpObject",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 168,
    "kind": "method",
    "name": "restoreAll",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#restoreAll",
    "access": "public",
    "description": "Defines all the entities in the passed array of objects.",
    "lineNumber": 354,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "dumpObjects",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 169,
    "kind": "method",
    "name": "assertRole",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#assertRole",
    "access": "public",
    "description": "Internal helper function to simplify definition of the assertValidRoleForMethod method.",
    "lineNumber": 366,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "roles",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 170,
    "kind": "method",
    "name": "hasRole",
    "memberof": "api/base/BaseCollection.ts~BaseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseCollection.ts~BaseCollection#hasRole",
    "access": "public",
    "description": "Internal helper function to simplify definition of the updateData for updateMethod.",
    "lineNumber": 383,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "roles",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 171,
    "kind": "file",
    "name": "api/base/BaseSlugCollection.ts",
    "content": "import { check } from 'meteor/check';\nimport _ from 'lodash';\nimport { Meteor } from 'meteor/meteor';\nimport BaseCollection from './BaseCollection';\nimport { Slugs } from '../slug/SlugCollection';\n\n/**\n * BaseSlugCollection is an abstract superclass for use by entities that have a slug.\n * It provides an API where the user can provide either a slug or docID (or document-specifying object).\n * Note it does not define a constructor; subclasses should invoke super(type, schema) to get the\n * BaseCollection constructor.\n * @extends BaseCollection\n */\nclass BaseSlugCollection extends BaseCollection {\n\n  /**\n   * Returns the docID associated with instance, or throws an error if it cannot be found.\n   * If instance is an object with an _id field, then that value is checked to see if it's in the collection.\n   * If instance is the value for the username field in this collection, then return that document's ID.\n   * If instance is a docID, then it is returned unchanged. If instance is a slug, its corresponding docID is returned.\n   * @param { String } instance Either a valid docID or a valid slug string.\n   * @returns { String } The docID associated with instance.\n   * @throws { Meteor.Error } If instance is not a docID or a slug.\n   */\n  public getID(instance) {\n    // console.log(`BaseSlugCollection.getID(${instance})`);\n    let id;\n    // If we've been passed a document, check to see if it has an _id field and make instance the value of _id.\n    if (_.isObject(instance) && _.has(instance, '_id')) {\n      instance = instance['_id']; // eslint-disable-line no-param-reassign, dot-notation\n    }\n    // If instance is the value of the username field for some document in the collection, then return its ID.\n    const usernameBasedDoc = this.collection.findOne({ username: instance });\n    if (usernameBasedDoc) {\n      return usernameBasedDoc._id;\n    }\n    // Otherwise see if we can find instance as a docID or as a slug.\n    try {\n      // console.log(instance, this.collection.findOne({ _id: instance }));\n      id = (this.collection.findOne({ _id: instance })) ? instance : this.findIdBySlug(instance);\n    } catch (err) {\n      throw new Meteor.Error(`Error in ${this.collectionName} getID(): Failed to convert ${instance} to an ID. ${err}`);\n    }\n    return id;\n  }\n\n  /**\n   * Returns the docIDs associated with instances, or throws an error if any cannot be found.\n   * If an instance is a docID, then it is returned unchanged. If a slug, its corresponding docID is returned.\n   * If nothing is passed, then an empty array is returned.\n   * @param { String[] } instances An array of valid docIDs, slugs, or a combination.\n   * @returns { String[] } The docIDs associated with instances.\n   * @throws { Meteor.Error } If any instance is not a docID or a slug.\n   */\n  public getIDs(instances) {\n    let ids;\n    try {\n      ids = (instances) ? instances.map((instance) => this.getID(instance)) : [];\n    } catch (err) {\n      throw new Meteor.Error(`Error in getIDs(): Failed to convert one of ${instances} an ${this.type} to an ID. ${err}`);\n    }\n    return ids;\n  }\n\n  /**\n   * Removes the passed instance from its collection.\n   * Also removes the associated Slug.\n   * Note that prior to calling this method, the subclass should do additional checks to see if any dependent\n   * objects have been deleted.\n   * @param { String } instance A docID or slug representing the instance.\n   * @throws { Meteor.Error} If the instance (and its associated slug) cannot be found.\n   */\n  public removeIt(instance) {\n    const docID = this.getID(instance);\n    const doc = super.findDoc(docID);\n    check(doc, Object);\n    // @ts-ignore\n    if (Slugs.isDefined(doc.slugID)) {\n      // @ts-ignore\n      const slugDoc = Slugs.findDoc(doc.slugID);\n      check(slugDoc, Object);\n      Slugs.removeIt(slugDoc);\n    }\n    return super.removeIt(doc);\n  }\n\n  /**\n   * Return true if instance is a docID or a slug for this entity.\n   * @param { String } instance A docID or a slug.\n   * @returns {boolean} True if instance is a docID or slug for this entity.\n   */\n  public isDefined(instance) {\n    // console.log('isDefined(%o)', instance);\n    return (super.isDefined(instance) || this.hasSlug(instance));\n  }\n\n  /**\n   * Returns true if the passed slug is associated with an entity of this type.\n   * @param { String } slug Either the name of a slug or a slugID.\n   * @returns {boolean} True if the slug is in this collection.\n   */\n  public hasSlug(slug) {\n    return (!!(this.collection.findOne({ slug })) || Slugs.isSlugForEntity(slug, this.type));\n  }\n\n  /**\n   * Return the docID of the instance associated with this slug.\n   * @param { String } slug The slug (string or docID).\n   * @returns { String } The docID.\n   * @throws { Meteor.Error } If the slug cannot be found, or is not associated with an instance in this collection.\n   */\n  public findIdBySlug(slug) {\n    // console.log(`findIdBySlug(${slug})`);\n    return Slugs.getEntityID(slug, this.type);\n  }\n\n  /**\n   * Returns a list of docIDs associated with the instances associated with the list of slugs.\n   * @param { Array } slugs A list or collection of slugs.\n   * @return { Array } A list of docIDs.\n   * @throws { Meteor.Error } If the slug cannot be found, or is not associated with an instance in this collection.\n   */\n  public findIdsBySlugs(slugs) {\n    return slugs.map((slug) => this.findIdBySlug(slug));\n  }\n\n  /**\n   * Returns the instance associated with the passed slug.\n   * @param { String } slug The slug (string or docID).\n   * @returns { Object } The document representing the instance.\n   * @throws { Meteor.Error } If the slug cannot be found, or is not associated with an instance in this collection.\n   */\n  public findDocBySlug(slug: string) {\n    return this.findDoc(this.findIdBySlug(slug));\n  }\n\n  /**\n   * Returns the slug name associated with this docID.\n   * @param docID The docID\n   * @returns { String } The slug name\n   * @throws { Meteor.Error } If docID is not associated with this entity.\n   */\n  public findSlugByID(docID: string) {\n    this.assertDefined(docID);\n    return Slugs.findDoc(this.findDoc(docID).slugID).name;\n  }\n}\n\n/**\n * Provide this class for use by instance collections such as Interest.\n */\nexport default BaseSlugCollection;\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/base/BaseSlugCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 172,
    "kind": "class",
    "name": "BaseSlugCollection",
    "memberof": "api/base/BaseSlugCollection.ts",
    "static": true,
    "longname": "api/base/BaseSlugCollection.ts~BaseSlugCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/base/BaseSlugCollection.ts",
    "importStyle": "BaseSlugCollection",
    "description": "BaseSlugCollection is an abstract superclass for use by entities that have a slug.\nIt provides an API where the user can provide either a slug or docID (or document-specifying object).\nNote it does not define a constructor; subclasses should invoke super(type, schema) to get the\nBaseCollection constructor.",
    "lineNumber": 14,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 173,
    "kind": "method",
    "name": "getID",
    "memberof": "api/base/BaseSlugCollection.ts~BaseSlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseSlugCollection.ts~BaseSlugCollection#getID",
    "access": "public",
    "description": "Returns the docID associated with instance, or throws an error if it cannot be found.\nIf instance is an object with an _id field, then that value is checked to see if it's in the collection.\nIf instance is the value for the username field in this collection, then return that document's ID.\nIf instance is a docID, then it is returned unchanged. If instance is a slug, its corresponding docID is returned.",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 174,
    "kind": "method",
    "name": "getIDs",
    "memberof": "api/base/BaseSlugCollection.ts~BaseSlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseSlugCollection.ts~BaseSlugCollection#getIDs",
    "access": "public",
    "description": "Returns the docIDs associated with instances, or throws an error if any cannot be found.\nIf an instance is a docID, then it is returned unchanged. If a slug, its corresponding docID is returned.\nIf nothing is passed, then an empty array is returned.",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instances",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/base/BaseSlugCollection.ts~BaseSlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseSlugCollection.ts~BaseSlugCollection#removeIt",
    "access": "public",
    "description": "Removes the passed instance from its collection.\nAlso removes the associated Slug.\nNote that prior to calling this method, the subclass should do additional checks to see if any dependent\nobjects have been deleted.",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "method",
    "name": "isDefined",
    "memberof": "api/base/BaseSlugCollection.ts~BaseSlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseSlugCollection.ts~BaseSlugCollection#isDefined",
    "access": "public",
    "description": "Return true if instance is a docID or a slug for this entity.",
    "lineNumber": 92,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "method",
    "name": "hasSlug",
    "memberof": "api/base/BaseSlugCollection.ts~BaseSlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseSlugCollection.ts~BaseSlugCollection#hasSlug",
    "access": "public",
    "description": "Returns true if the passed slug is associated with an entity of this type.",
    "lineNumber": 102,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "slug",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 178,
    "kind": "method",
    "name": "findIdBySlug",
    "memberof": "api/base/BaseSlugCollection.ts~BaseSlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseSlugCollection.ts~BaseSlugCollection#findIdBySlug",
    "access": "public",
    "description": "Return the docID of the instance associated with this slug.",
    "lineNumber": 112,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "slug",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 179,
    "kind": "method",
    "name": "findIdsBySlugs",
    "memberof": "api/base/BaseSlugCollection.ts~BaseSlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseSlugCollection.ts~BaseSlugCollection#findIdsBySlugs",
    "access": "public",
    "description": "Returns a list of docIDs associated with the instances associated with the list of slugs.",
    "lineNumber": 123,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "slugs",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 180,
    "kind": "method",
    "name": "findDocBySlug",
    "memberof": "api/base/BaseSlugCollection.ts~BaseSlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseSlugCollection.ts~BaseSlugCollection#findDocBySlug",
    "access": "public",
    "description": "Returns the instance associated with the passed slug.",
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "slug",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "findSlugByID",
    "memberof": "api/base/BaseSlugCollection.ts~BaseSlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseSlugCollection.ts~BaseSlugCollection#findSlugByID",
    "access": "public",
    "description": "Returns the slug name associated with this docID.",
    "lineNumber": 143,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 182,
    "kind": "file",
    "name": "api/base/BaseTypeCollection.ts",
    "content": "import { check } from 'meteor/check';\nimport _ from 'lodash';\nimport { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport { Slugs } from '../slug/SlugCollection';\nimport BaseCollection from './BaseCollection';\n\n/**\n * BaseType is an abstract superclass that factors out common code for the \"type\" entities: OpportunityType and TagType.\n * @extends BaseCollection\n */\nclass BaseTypeCollection extends BaseCollection {\n\n  /**\n   * Creates the BaseType collection.\n   */\n  constructor(collectionType) {\n    super(collectionType, new SimpleSchema({\n      description: { type: String },\n      name: { type: String },\n      slugID: { type: SimpleSchema.RegEx.Id },\n      retired: { type: Boolean, optional: true },\n    }));\n    this.defineSchema = new SimpleSchema({\n      name: String,\n      slug: String,\n      description: String,\n      retired: { type: Boolean, optional: true },\n    });\n    this.updateSchema = new SimpleSchema({\n      name: { type: String, optional: true },\n      description: { type: String, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines a new BaseType with its name, slug, and description.\n   * @param { Object } description Object with keys name, slug, and description.\n   * Slug must be globally unique and previously undefined.\n   * @throws { Meteor.Error } If the slug already exists.\n   * @returns The newly created docID.\n   */\n  public define({ name, slug, description, retired }) {\n    const slugID = Slugs.define({ name: slug, entityName: this.type });\n    const baseTypeID = this.collection.insert({ name, description, slugID, retired });\n    Slugs.updateEntityID(slugID, baseTypeID);\n    return baseTypeID;\n  }\n\n  /**\n   * Returns the docID associated with instance, or throws an error if it cannot be found.\n   * If instance is a docID, then it is returned unchanged. If instance is a slug, its corresponding docID is returned.\n   * If instance is an object with an _id field, then that value is checked to see if it's in the collection.\n   * @param { String } instance Either a valid docID or a valid slug string.\n   * @returns { String } The docID associated with instance.\n   * @throws { Meteor.Error } If instance is not a docID or a slug.\n   */\n  public getID(instance) {\n    let id;\n    if (_.isObject(instance) && _.has(instance, '_id')) {\n      // eslint-disable-next-line no-param-reassign, dot-notation\n      instance = instance['_id'];\n    }\n    try {\n      id = (this.collection.findOne({ _id: instance })) ? instance : this.findIdBySlug(instance);\n    } catch (err) {\n      throw new Meteor.Error(`Error in ${this.collectionName} getID(): Failed to convert ${instance} to an ID.`);\n    }\n    return id;\n  }\n\n  /**\n   * Returns the docIDs associated with instances, or throws an error if any cannot be found.\n   * If an instance is a docID, then it is returned unchanged. If a slug, its corresponding docID is returned.\n   * @param { String[] } instances An array of valid docIDs, slugs, or a combination.\n   * @returns { String[] } The docIDs associated with instances.\n   * @throws { Meteor.Error } If any instance is not a docID or a slug.\n   */\n  public getIDs(instances) {\n    let ids;\n    try {\n      ids = (instances) ? instances.map((instance) => this.getID(instance)) : [];\n    } catch (err) {\n      throw new Meteor.Error(`Error in getIDs(): Failed to convert one of ${instances} to an ID.`);\n    }\n    return ids;\n  }\n\n  /**\n   * Removes the passed instance from its collection.\n   * Also removes the associated Slug.\n   * Note that prior to calling this method, the subclass should do additional checks to see if any dependent\n   * objects have been deleted.\n   * @param { String } instance A docID or slug representing the instance.\n   * @throws { Meteor.Error} If the instance (and its associated slug) cannot be found.\n   */\n  public removeIt(instance) {\n    const docID = this.getID(instance);\n    const doc = super.findDoc(docID);\n    check(doc, Object);\n    if (Slugs.isDefined(doc.slugID)) {\n      const slugDoc = Slugs.findDoc(doc.slugID);\n      check(slugDoc, Object);\n      Slugs.removeIt(slugDoc);\n    }\n    return super.removeIt(doc);\n  }\n\n  /**\n   * Return true if instance is a docID or a slug for this entity.\n   * @param { String } instance A docID or a slug.\n   * @returns {boolean} True if instance is a docID or slug for this entity.\n   */\n  public isDefined(instance) {\n    return (super.isDefined(instance) || this.hasSlug(instance));\n  }\n\n  /**\n   * Returns true if the passed slug is associated with an entity of this type.\n   * @param { String } slug Either the name of a slug or a slugID.\n   * @returns {boolean} True if the slug is in this collection.\n   */\n  public hasSlug(slug) {\n    return (!!(this.collection.findOne({ slug })) || Slugs.isSlugForEntity(slug, this.type));\n  }\n\n  /**\n   * Returns the document associated with the passed slug.\n   * @param { String } slug The slug (string or docID).\n   * @returns { Object } The document.\n   * @throws { Meteor.Error } If the slug cannot be found, or is not associated with an\n   * instance in this collection.\n   */\n  public findDocBySlug(slug) {\n    const id = Slugs.getEntityID(slug, this.type);\n    return this.collection.findOne(id);\n  }\n\n  /**\n   * Returns the slug name associated with this docID.\n   * @param docID The docID\n   * @returns { String } The slug name\n   * @throws { Meteor.Error } If docID is not associated with this entity.\n   */\n  public findSlugByID(docID) {\n    this.assertDefined(docID);\n    return Slugs.findDoc(this.findDoc(docID).slugID).name;\n  }\n\n  /**\n   * Return the docID of the instance associated with this slug.\n   * @param { String } slug The slug (string or docID).\n   * @returns { String } The docID.\n   * @throws { Meteor.Error } If the slug cannot be found, or is not associated with an instance in this collection.\n   */\n  public findIdBySlug(slug) {\n    return Slugs.getEntityID(slug, this.type);\n  }\n\n  /**\n   * Returns the name associated with this docID.\n   * @param docID The docID for this \"type\".\n   * @returns The name of this \"type\" instance.\n   * @throws { Meteor.Error } If the passed docID is not valid.\n   */\n  public getNameFromID(docID) {\n    this.assertDefined(docID);\n    return this.findDoc(docID).name;\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks slugID.\n   * This is the default integrity checker for all BaseTypeCollection subclasses.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find({}, {}).forEach((doc) => {\n      if (!Slugs.isDefined(doc.slugID)) {\n        problems.push(`Bad slugID: ${doc.slugID}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the \"Type\" docID in a format acceptable to define().\n   * @param docID The docID of a \"Type\".\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID) {\n    const doc = this.findDoc(docID);\n    const name = doc.name;\n    const slug = Slugs.getNameFromID(doc.slugID);\n    const description = doc.description;\n    const retired = doc.retired;\n    return { name, slug, description, retired };\n  }\n}\n\n/**\n * Provide this class for use by OpportunityType and TagType.\n */\nexport default BaseTypeCollection;\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/base/BaseTypeCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 183,
    "kind": "class",
    "name": "BaseTypeCollection",
    "memberof": "api/base/BaseTypeCollection.ts",
    "static": true,
    "longname": "api/base/BaseTypeCollection.ts~BaseTypeCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/base/BaseTypeCollection.ts",
    "importStyle": "BaseTypeCollection",
    "description": "BaseType is an abstract superclass that factors out common code for the \"type\" entities: OpportunityType and TagType.",
    "lineNumber": 12,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 184,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/base/BaseTypeCollection.ts~BaseTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseTypeCollection.ts~BaseTypeCollection#constructor",
    "access": "public",
    "description": "Creates the BaseType collection.",
    "lineNumber": 17
  },
  {
    "__docId__": 185,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/base/BaseTypeCollection.ts~BaseTypeCollection",
    "static": false,
    "longname": "api/base/BaseTypeCollection.ts~BaseTypeCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 186,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/base/BaseTypeCollection.ts~BaseTypeCollection",
    "static": false,
    "longname": "api/base/BaseTypeCollection.ts~BaseTypeCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 187,
    "kind": "method",
    "name": "define",
    "memberof": "api/base/BaseTypeCollection.ts~BaseTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseTypeCollection.ts~BaseTypeCollection#define",
    "access": "public",
    "description": "Defines a new BaseType with its name, slug, and description.",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 188,
    "kind": "method",
    "name": "getID",
    "memberof": "api/base/BaseTypeCollection.ts~BaseTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseTypeCollection.ts~BaseTypeCollection#getID",
    "access": "public",
    "description": "Returns the docID associated with instance, or throws an error if it cannot be found.\nIf instance is a docID, then it is returned unchanged. If instance is a slug, its corresponding docID is returned.\nIf instance is an object with an _id field, then that value is checked to see if it's in the collection.",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "method",
    "name": "getIDs",
    "memberof": "api/base/BaseTypeCollection.ts~BaseTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseTypeCollection.ts~BaseTypeCollection#getIDs",
    "access": "public",
    "description": "Returns the docIDs associated with instances, or throws an error if any cannot be found.\nIf an instance is a docID, then it is returned unchanged. If a slug, its corresponding docID is returned.",
    "lineNumber": 80,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instances",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 190,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/base/BaseTypeCollection.ts~BaseTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseTypeCollection.ts~BaseTypeCollection#removeIt",
    "access": "public",
    "description": "Removes the passed instance from its collection.\nAlso removes the associated Slug.\nNote that prior to calling this method, the subclass should do additional checks to see if any dependent\nobjects have been deleted.",
    "lineNumber": 98,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 191,
    "kind": "method",
    "name": "isDefined",
    "memberof": "api/base/BaseTypeCollection.ts~BaseTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseTypeCollection.ts~BaseTypeCollection#isDefined",
    "access": "public",
    "description": "Return true if instance is a docID or a slug for this entity.",
    "lineNumber": 115,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 192,
    "kind": "method",
    "name": "hasSlug",
    "memberof": "api/base/BaseTypeCollection.ts~BaseTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseTypeCollection.ts~BaseTypeCollection#hasSlug",
    "access": "public",
    "description": "Returns true if the passed slug is associated with an entity of this type.",
    "lineNumber": 124,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "slug",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 193,
    "kind": "method",
    "name": "findDocBySlug",
    "memberof": "api/base/BaseTypeCollection.ts~BaseTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseTypeCollection.ts~BaseTypeCollection#findDocBySlug",
    "access": "public",
    "description": "Returns the document associated with the passed slug.",
    "lineNumber": 135,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "slug",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 194,
    "kind": "method",
    "name": "findSlugByID",
    "memberof": "api/base/BaseTypeCollection.ts~BaseTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseTypeCollection.ts~BaseTypeCollection#findSlugByID",
    "access": "public",
    "description": "Returns the slug name associated with this docID.",
    "lineNumber": 146,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 195,
    "kind": "method",
    "name": "findIdBySlug",
    "memberof": "api/base/BaseTypeCollection.ts~BaseTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseTypeCollection.ts~BaseTypeCollection#findIdBySlug",
    "access": "public",
    "description": "Return the docID of the instance associated with this slug.",
    "lineNumber": 157,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "slug",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "method",
    "name": "getNameFromID",
    "memberof": "api/base/BaseTypeCollection.ts~BaseTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseTypeCollection.ts~BaseTypeCollection#getNameFromID",
    "access": "public",
    "description": "Returns the name associated with this docID.",
    "lineNumber": 167,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 197,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/base/BaseTypeCollection.ts~BaseTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseTypeCollection.ts~BaseTypeCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks slugID.\nThis is the default integrity checker for all BaseTypeCollection subclasses.",
    "lineNumber": 179,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 198,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/base/BaseTypeCollection.ts~BaseTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/base/BaseTypeCollection.ts~BaseTypeCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the \"Type\" docID in a format acceptable to define().",
    "lineNumber": 194,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "{\"name\": *, \"slug\": *, \"description\": *, \"retired\": *}"
      ]
    }
  },
  {
    "__docId__": 199,
    "kind": "file",
    "name": "api/base/BaseUtilities.ts",
    "content": "import _ from 'lodash';\nimport { Meteor } from 'meteor/meteor';\nimport { RadGrad } from '../radgrad/RadGrad';\n// import { assertIntegrity } from '../integrity/IntegrityChecker';\n// import { Users } from '../user/UserCollection';\n\n/**\n * Deletes all documents from all RadGrad collections.\n * Checks the integrity of the database before doing the deletion.\n * To be used only in testing mode.\n * @memberOf api/base\n * @throws { Meteor.Error } If there is an integrity issue with the DB prior to deletion.\n * @returns true\n */\nexport function removeAllEntities() {\n  if (Meteor.isTest || Meteor.isAppTest) {\n    // assertIntegrity();  // this started failing after update to Meteor 1.6.1!\n    _.forEach(RadGrad.collections, (collection) => {\n      if (collection.type !== 'AdminProfile') {\n        collection.collection.remove({});\n      }\n    });\n    // Users is not part of RadGrad collections, so must deal with it individually.\n    // Users.removeAll();\n  } else {\n    throw new Meteor.Error('removeAllEntities not called in testing mode.');\n  }\n  return true;\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/base/BaseUtilities.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 200,
    "kind": "function",
    "name": "removeAllEntities",
    "memberof": "api/base/BaseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/base/BaseUtilities.ts~removeAllEntities",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/base/BaseUtilities.ts",
    "importStyle": "{removeAllEntities}",
    "description": "Deletes all documents from all RadGrad collections.\nChecks the integrity of the database before doing the deletion.\nTo be used only in testing mode.",
    "lineNumber": 15,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 201,
    "kind": "file",
    "name": "api/base/index.ts",
    "content": "/** @namespace api/base */\n\nimport './BaseCollection';\nimport './BaseCollection.methods';\nimport './BaseSlugCollection';\nimport './BaseTypeCollection';\nimport './BaseUtilities';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/base/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 202,
    "kind": "file",
    "name": "api/career/CareerGoalCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { CareerGoals } from './CareerGoalCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('CareerGoalCollection Meteor Methods ', function test() {\n    const collectionName = CareerGoals.getCollectionName();\n    const definitionData = {\n      name: 'name',\n      slug: 'career-goal-slug-example',\n      description: 'description',\n      interests: ['algorithms'],\n    };\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal', 'abi.student'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      const careerGoalID = await defineMethod.callPromise({ collectionName, definitionData });\n      expect(CareerGoals.isDefined(careerGoalID)).to.be.true;\n    });\n\n    it('Update Method', async function () {\n      const id = CareerGoals.findIdBySlug(definitionData.slug);\n      const name = 'updated CareerGoal name';\n      const description = 'updated CareerGoal description';\n      const interests = ['algorithms', 'java'];\n      await updateMethod.callPromise({ collectionName, updateData: { id, name, description, interests } });\n    });\n\n    it('Remove Method', async function () {\n      await removeItMethod.callPromise({ collectionName, instance: definitionData.slug });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/career/CareerGoalCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 203,
    "kind": "file",
    "name": "api/career/CareerGoalCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport faker from 'faker';\nimport fc from 'fast-check';\nimport 'mocha';\nimport { CareerGoals } from './CareerGoalCollection';\nimport { makeSampleInterest } from '../interest/SampleInterests';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport slugify from '../slug/SlugCollection';\nimport { Interests } from '../interest/InterestCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('CareerGoalCollection', function testSuite() {\n    const name = faker.lorem.words();\n    const slug = slugify(name);\n    const description = faker.lorem.paragraph();\n\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(15000);\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(1), fc.lorem(5, true), (fcName, fcSlug, fcDescription) => {\n          const interests = [makeSampleInterest(), makeSampleInterest()];\n          const docID = CareerGoals.define({ name: fcName, slug: fcSlug, description: fcDescription, interests });\n          expect(CareerGoals.isDefined(docID)).to.be.true;\n          expect(CareerGoals.findSlugByID(docID)).to.equal(fcSlug);\n          CareerGoals.removeIt(docID);\n          expect(CareerGoals.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Can define duplicates', function test2() {\n      const interests = [makeSampleInterest()];\n      const docId1 = CareerGoals.define({ name, slug, description, interests });\n      const docId2 = CareerGoals.define({ name, slug, description, interests });\n      expect(docId1).to.equal(docId2);\n      expect(CareerGoals.isDefined(docId1)).to.be.true;\n      expect(CareerGoals.isDefined(docId2)).to.be.true;\n      CareerGoals.removeIt(docId1);\n      expect(CareerGoals.isDefined(docId1)).to.be.false;\n      expect(CareerGoals.isDefined(docId2)).to.be.false;\n    });\n\n    it('Can find names', function test3() {\n      const interests = [makeSampleInterest()];\n      const docID = CareerGoals.define({ name, slug, description, interests });\n      expect(CareerGoals.findNames([docID])[0]).to.equal(name);\n      CareerGoals.removeIt(docID);\n    });\n\n    it('Can update', function test4(done) {\n      this.timeout(5000);\n      const interests = [makeSampleInterest()];\n      const interest2 = [makeSampleInterest(), makeSampleInterest()];\n      const docID = CareerGoals.define({ name, slug, description, interests });\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(5, true), fc.boolean(), (fcName, fcDescription, fcRetired) => {\n          CareerGoals.update(docID, { name: fcName, description: fcDescription, interests: interest2, retired: fcRetired });\n          const doc = CareerGoals.findDoc(docID);\n          expect(doc.name).to.equal(fcName);\n          expect(doc.description).to.equal(fcDescription);\n          expect(doc.interestIDs).to.have.lengthOf(2);\n          expect(doc.interestIDs[0]).to.equal(interest2[0]);\n          expect(doc.retired).to.equal(fcRetired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test5() {\n      let docID = CareerGoals.getID(slug);\n      const dumpObject = CareerGoals.dumpOne(docID);\n      CareerGoals.removeIt(docID);\n      expect(CareerGoals.isDefined(slug)).to.be.false;\n      docID = CareerGoals.restoreOne(dumpObject);\n      expect(CareerGoals.isDefined(slug)).to.be.true;\n    });\n\n    it('Can checkIntegrity no errors', function test6() {\n      const errors = CareerGoals.checkIntegrity();\n      expect(errors.length).to.equal(0);\n    });\n\n    it('Can get Interest', function test7() {\n      const docID = CareerGoals.getID(slug);\n      const careerGoal = CareerGoals.findDoc(docID);\n      const interest = Interests.findDoc(careerGoal.interestIDs[0]);\n      expect(CareerGoals.hasInterest(docID, interest._id)).to.be.true;\n    });\n\n    it('findDoc(undefined) throws', function test8() {\n      expect(() => CareerGoals.findDoc(undefined)).to.throw(Error);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/career/CareerGoalCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 204,
    "kind": "file",
    "name": "api/career/CareerGoalCollection.ts",
    "content": "import SimpleSchema from 'simpl-schema';\nimport { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport { Slugs } from '../slug/SlugCollection';\nimport { Interests } from '../interest/InterestCollection';\nimport BaseSlugCollection from '../base/BaseSlugCollection';\nimport { ICareerGoalDefine, ICareerGoalUpdate } from '../../typings/radgrad';\nimport { FavoriteCareerGoals } from '../favorite/FavoriteCareerGoalCollection';\n\n/**\n * CareerGoals represent the professional future(s) that the student wishes to work toward.\n * @memberOf api/career\n * @extends api/base.BaseSlugCollection\n */\nclass CareerGoalCollection extends BaseSlugCollection {\n\n  /**\n   * Creates the CareerGoal collection.\n   */\n  constructor() {\n    super('CareerGoal', new SimpleSchema({\n      name: { type: String },\n      slugID: { type: SimpleSchema.RegEx.Id },\n      description: { type: String },\n      interestIDs: [SimpleSchema.RegEx.Id],\n      retired: { type: Boolean, optional: true },\n    }));\n    this.defineSchema = new SimpleSchema({\n      name: { type: String },\n      slug: { type: String },\n      description: { type: String },\n      interests: [String],\n    });\n    // name, description, interests\n    this.updateSchema = new SimpleSchema({\n      name: { type: String, optional: true },\n      description: { type: String, optional: true },\n      interests: { type: Array, optional: true },\n      'interests.$': String,\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines a new CareerGoal with its name, slug, and description.\n   * @example\n   * CareerGoals.define({ name: 'Database Administrator',\n   *                      slug: 'database-administrator',\n   *                      description: 'Wrangler of SQL.',\n   *                      interests: ['application-development', 'software-engineering', 'databases'],\n   *                    });\n   * @param { Object } description Object with keys name, slug, description, interests.\n   * Slug must be globally unique and previously undefined.\n   * Interests is a (possibly empty) array of defined interest slugs or interestIDs.\n   * @throws { Meteor.Error } If the slug already exists.\n   * @returns The newly created docID.\n   */\n  public define({ name, slug, description, interests, retired = false }: ICareerGoalDefine) {\n    // Get Interests, throw error if any of them are not found.\n    const interestIDs = Interests.getIDs(interests);\n    const doc = this.collection.findOne({ name, description, interestIDs, retired });\n    if (doc) {\n      return doc._id;\n    }\n    // Get SlugID, throw error if found.\n    const slugID = Slugs.define({ name: slug, entityName: this.getType() });\n    const docID = this.collection.insert({ name, slugID, description, interestIDs, retired });\n    // Connect the Slug to this Interest\n    Slugs.updateEntityID(slugID, docID);\n    return docID;\n  }\n\n  /**\n   * Returns a list of Career Goal names corresponding to the passed list of CareerGoal docIDs.\n   * @param instanceIDs A list of Career Goal docIDs.\n   * @returns { Array } An array of name strings.\n   * @throws { Meteor.Error} If any of the instanceIDs cannot be found.\n   */\n  public findNames(instanceIDs: string[]) {\n    return instanceIDs.map((instanceID) => this.findDoc(instanceID).name);\n  }\n\n  /**\n   * Update a Career Goal.\n   * @param docID The docID to be updated.\n   * @param name The new name (optional).\n   * @param description The new description (optional).\n   * @param interests A new list of interest slugs or IDs. (optional).\n   * @throws { Meteor.Error } If docID is not defined, or if any interest is not a defined slug or ID.\n   */\n  public update(docID: string, { name, description, interests, retired }: ICareerGoalUpdate): void {\n    this.assertDefined(docID);\n    const updateData: {\n      name?: string;\n      description?: string;\n      interestIDs?: string[];\n      retired?: boolean;\n    } = {};\n    if (name) {\n      updateData.name = name;\n    }\n    if (description) {\n      updateData.description = description;\n    }\n    if (interests) {\n      const interestIDs = Interests.getIDs(interests);\n      updateData.interestIDs = interestIDs;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n      // Need to update the FavoriteCareerGoals\n      const favorites = FavoriteCareerGoals.find({ careerGoalID: docID }).fetch();\n      _.forEach(favorites, (fav) => {});\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the Career Goal.\n   * @param instance The docID or slug of the entity to be removed.\n   * @throws { Meteor.Error } If docID is not a CareerGoal, or if any User lists this as a Career Goal.\n   */\n  public removeIt(instance: string) {\n    const careerGoalID = this.getID(instance);\n    // Check that this is not referenced by any User.\n    const favorites = FavoriteCareerGoals.find({ careerGoalID }).fetch();\n    if (favorites.length > 0) {\n      throw new Meteor.Error(`Career Goal ${instance} is referenced.`);\n    }\n    // OK, clear to delete.\n    return super.removeIt(careerGoalID);\n  }\n\n  /**\n   * Returns true if CareerGoal has the specified interest.\n   * @param careerGoal The user (docID or slug)\n   * @param interest The Interest (docID or slug).\n   * @returns {boolean} True if the career goal has the associated Interest.\n   * @throws { Meteor.Error } If careerGoal is not a career goal or interest is not a Interest.\n   */\n  public hasInterest(careerGoal: string, interest: string) {\n    const interestID = Interests.getID(interest);\n    const doc = this.findDoc(careerGoal);\n    return _.includes(doc.interestIDs, interestID);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks slugID and interestIDs.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (!Slugs.isDefined(doc.slugID)) {\n        problems.push(`Bad slugID: ${doc.slugID}`);\n      }\n      _.forEach(doc.interestIDs, (interestID) => {\n        if (!Interests.isDefined(interestID)) {\n          problems.push(`Bad interestID: ${interestID}`);\n        }\n      });\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the CareerGoal docID in a format acceptable to define().\n   * @param docID The docID of a CareerGoal.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): ICareerGoalDefine {\n    const doc = this.findDoc(docID);\n    const name = doc.name;\n    const slug = Slugs.getNameFromID(doc.slugID);\n    const description = doc.description;\n    const interests = _.map(doc.interestIDs, (interestID) => Interests.findSlugByID(interestID));\n    const retired = doc.retired;\n    return { name, slug, interests, description, retired };\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @memberOf api/career\n */\nexport const CareerGoals = new CareerGoalCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/career/CareerGoalCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 205,
    "kind": "variable",
    "name": "CareerGoals",
    "memberof": "api/career/CareerGoalCollection.ts",
    "static": true,
    "longname": "api/career/CareerGoalCollection.ts~CareerGoals",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/career/CareerGoalCollection.ts",
    "importStyle": "{CareerGoals}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 184,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/career"
      }
    ],
    "type": {
      "types": [
        "api/career/CareerGoalCollection.ts~CareerGoalCollection"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "class",
    "name": "CareerGoalCollection",
    "memberof": "api/career/CareerGoalCollection.ts",
    "static": true,
    "longname": "api/career/CareerGoalCollection.ts~CareerGoalCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/career/CareerGoalCollection.ts",
    "importStyle": null,
    "description": "CareerGoals represent the professional future(s) that the student wishes to work toward.",
    "lineNumber": 15,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseSlugCollection.js~BaseSlugCollection"
    ]
  },
  {
    "__docId__": 207,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/career/CareerGoalCollection.ts~CareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/career/CareerGoalCollection.ts~CareerGoalCollection#constructor",
    "access": "public",
    "description": "Creates the CareerGoal collection.",
    "lineNumber": 18
  },
  {
    "__docId__": 208,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/career/CareerGoalCollection.ts~CareerGoalCollection",
    "static": false,
    "longname": "api/career/CareerGoalCollection.ts~CareerGoalCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 209,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/career/CareerGoalCollection.ts~CareerGoalCollection",
    "static": false,
    "longname": "api/career/CareerGoalCollection.ts~CareerGoalCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 210,
    "kind": "method",
    "name": "define",
    "memberof": "api/career/CareerGoalCollection.ts~CareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/career/CareerGoalCollection.ts~CareerGoalCollection#define",
    "access": "public",
    "description": "Defines a new CareerGoal with its name, slug, and description.",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "ICareerGoalDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 211,
    "kind": "method",
    "name": "findNames",
    "memberof": "api/career/CareerGoalCollection.ts~CareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/career/CareerGoalCollection.ts~CareerGoalCollection#findNames",
    "access": "public",
    "description": "Returns a list of Career Goal names corresponding to the passed list of CareerGoal docIDs.",
    "lineNumber": 79,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceIDs",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "method",
    "name": "update",
    "memberof": "api/career/CareerGoalCollection.ts~CareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/career/CareerGoalCollection.ts~CareerGoalCollection#update",
    "access": "public",
    "description": "Update a Career Goal.",
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ICareerGoalUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 213,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/career/CareerGoalCollection.ts~CareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/career/CareerGoalCollection.ts~CareerGoalCollection#removeIt",
    "access": "public",
    "description": "Remove the Career Goal.",
    "lineNumber": 123,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 214,
    "kind": "method",
    "name": "hasInterest",
    "memberof": "api/career/CareerGoalCollection.ts~CareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/career/CareerGoalCollection.ts~CareerGoalCollection#hasInterest",
    "access": "public",
    "description": "Returns true if CareerGoal has the specified interest.",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "careerGoal",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "interest",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 215,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/career/CareerGoalCollection.ts~CareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/career/CareerGoalCollection.ts~CareerGoalCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks slugID and interestIDs.",
    "lineNumber": 153,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/career/CareerGoalCollection.ts~CareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/career/CareerGoalCollection.ts~CareerGoalCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the CareerGoal docID in a format acceptable to define().",
    "lineNumber": 173,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ICareerGoalDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 217,
    "kind": "file",
    "name": "api/career/SampleCareerGoals.ts",
    "content": "import faker from 'faker';\nimport moment from 'moment';\nimport _ from 'lodash';\nimport { CareerGoals } from './CareerGoalCollection';\nimport { makeSampleInterest } from '../interest/SampleInterests';\nimport slugify, { Slugs } from '../slug/SlugCollection';\n\n/**\n * Defines a sample CareerGoal.\n * @return {string} the id of the defined CareerGoal.\n */\nexport function makeSampleCareerGoal(): string {\n  const name = faker.lorem.word();\n  const slug = slugify(`career-goal-${name}-${moment().format('YYYY-MM-DD-HH-mm-ss-SSSSS')}`);\n  const description = faker.lorem.paragraph();\n  const interests = [makeSampleInterest()];\n  return CareerGoals.define({ name, slug, description, interests });\n}\n\n/**\n * Returns an array of defined CareerGoal ids.\n * @param num the number of CareerGoals to define.\n * @return {string[]} An array of CareerGoal ids.\n */\nexport function makeSampleCareerGoalArray(num = 2) {\n  const retVal = [];\n  for (let i = 0; i < num; i++) {\n    retVal.push(makeSampleCareerGoal());\n  }\n  return retVal;\n}\n\n/**\n * Returns an array of defined CareerGoal slugs.\n * @param num the number of CareerGoals to define.\n * @return {string[]} An array of defined CareerGoal slugs.\n */\nexport function makeSampleCareerGoalSlugArray(num = 2) {\n  const ids = makeSampleCareerGoalArray(num);\n  return _.map(ids, (id) => {\n    const doc = CareerGoals.findDoc(id);\n    return Slugs.getNameFromID(doc.slugID);\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/career/SampleCareerGoals.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 218,
    "kind": "function",
    "name": "makeSampleCareerGoal",
    "memberof": "api/career/SampleCareerGoals.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/career/SampleCareerGoals.ts~makeSampleCareerGoal",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/career/SampleCareerGoals.ts",
    "importStyle": "{makeSampleCareerGoal}",
    "description": "Defines a sample CareerGoal.",
    "lineNumber": 12,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 219,
    "kind": "function",
    "name": "makeSampleCareerGoalArray",
    "memberof": "api/career/SampleCareerGoals.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/career/SampleCareerGoals.ts~makeSampleCareerGoalArray",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/career/SampleCareerGoals.ts",
    "importStyle": "{makeSampleCareerGoalArray}",
    "description": "Returns an array of defined CareerGoal ids.",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "num",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 220,
    "kind": "function",
    "name": "makeSampleCareerGoalSlugArray",
    "memberof": "api/career/SampleCareerGoals.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/career/SampleCareerGoals.ts~makeSampleCareerGoalSlugArray",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/career/SampleCareerGoals.ts",
    "importStyle": "{makeSampleCareerGoalSlugArray}",
    "description": "Returns an array of defined CareerGoal slugs.",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "num",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 221,
    "kind": "file",
    "name": "api/career/index.ts",
    "content": "/** @namespace api/career */\nimport './CareerGoalCollection';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/career/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 222,
    "kind": "file",
    "name": "api/course/CourseCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport {} from 'mocha';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { getFutureEnrollmentMethod } from './CourseCollection.methods';\nimport { Courses } from './CourseCollection';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { nextAcademicTerm } from '../academic-term/AcademicTermUtilities';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('CourseCollection Meteor Methods ', function test() {\n    const collectionName = Courses.getCollectionName();\n    const definitionData = {\n      name: 'Introduction to the theory and practice of scripting',\n      shortName: 'Intro to Scripting',\n      slug: 'ics_215',\n      num: 'ICS 215',\n      description: 'Introduction to scripting languages.',\n      creditHrs: 4,\n      interests: ['java'],\n      syllabus: 'http://courses.ics.hawaii.edu/syllabuses/ICS215.html',\n      prerequisites: ['ics_111'],\n    };\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal', 'abi.student'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      await defineMethod.callPromise({ collectionName, definitionData });\n    });\n\n    it('Update Method', async function () {\n      const id = Courses.findIdBySlug(definitionData.slug);\n      const name = 'updated CareerGoal name';\n      const description = 'updated CareerGoal description';\n      const interests = ['algorithms', 'java'];\n      const prerequisites = ['ics_111', 'ics_141'];\n      await updateMethod.callPromise({\n        collectionName,\n        updateData: { id, name, description, interests, prerequisites },\n      });\n    });\n\n    it('getFutureEnrollment Methods', async function () {\n      // First, just call this expecting that there is no future enrollment data.\n      let id = Courses.findIdBySlug(definitionData.slug);\n      let data = await getFutureEnrollmentMethod.callPromise(id);\n      expect(data.courseID).to.equal(id);\n      expect(data.enrollmentData[0][1]).to.equal(0);\n\n      // Now make a course instance for next academicTerm\n      // console.log(nextAcademicTerm(AcademicTerms.getCurrentAcademicTermDoc()));\n      const academicTerm = AcademicTerms.findIdBySlug(nextAcademicTerm(AcademicTerms.getCurrentAcademicTermDoc()).slugID);\n      const student = 'abi@hawaii.edu';\n      const course = 'ics_111';\n      const courseInstanceDefinitionData = {\n        academicTerm,\n        course,\n        student,\n        verified: true,\n        fromRegistrar: true,\n        grade: 'B',\n        note: '',\n        creditHrs: 3,\n      };\n      await defineMethod.callPromise({\n        collectionName: 'CourseInstanceCollection',\n        definitionData: courseInstanceDefinitionData,\n      });\n\n      // We'll now expect next academicTerm to have enrollment of 1.\n      id = Courses.findIdBySlug('ics_111');\n      data = await getFutureEnrollmentMethod.callPromise(id);\n      expect(data.courseID).to.equal(id);\n      expect(data.enrollmentData[0][1]).to.equal(1);\n    });\n\n    it('Remove Method', async function () {\n      await removeItMethod.callPromise({ collectionName, instance: definitionData.slug });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/course/CourseCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 223,
    "kind": "file",
    "name": "api/course/CourseCollection.methods.ts",
    "content": "import { CallPromiseMixin } from 'meteor/didericis:callpromise-mixin';\nimport { ValidatedMethod } from 'meteor/mdg:validated-method';\nimport _ from 'lodash';\nimport { Courses } from './CourseCollection';\nimport { CourseInstances } from './CourseInstanceCollection';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { nextAcademicTerm } from '../academic-term/AcademicTermUtilities';\nimport { RadGradProperties } from '../radgrad/RadGradProperties';\n\n/**\n * Returns an array with two elements: a string with the shortName of the academicTerm, and an integer indicating the\n * current planned enrollment for the course in that academicTerm.\n * @param courseID The ID of the course.\n * @param termID The ID of the academicTerm.\n * @memberOf api/course\n */\nfunction getEnrollmentData(courseID, termID) {\n  const academicTermShortName = AcademicTerms.getShortName(termID);\n  const enrollment = CourseInstances.getCollection().find({ termID, courseID }).count();\n  return [academicTermShortName, enrollment];\n}\n\n/**\n * Given a courseID, returns enrollment data for the upcoming 9 academicTerms.\n * The returned data is an object with fields courseID and enrollmentData.\n * CourseID is the course ID.\n * EnrollmentData is an array of arrays. Each interior array is a tuple: a string containing the shortname and an\n * integer indicating the enrollment data.\n * @memberOf api/course\n * @example\n * { courseID: 'xghuyf2132q3',\n *   enrollmentData: [['Sp19', 0], ['Su19', 1], ['Fa19', 5],\n *                    ['Sp20', 25], ['Su20', 2], ['Fa20', 0],\n *                    ['Sp21', 1], ['Su21', 0], ['Fa21', 1]]\n * }\n */\nexport const getFutureEnrollmentMethod = new ValidatedMethod({\n  name: 'CourseCollection.getFutureEnrollment',\n  mixins: [CallPromiseMixin],\n  validate: null,\n  run(courseID) {\n    // Throw error if an invalid courseID is passed.\n    Courses.assertDefined(courseID);\n    // Create an array of the upcoming 9 academicTerms after the current academicTerm.\n    let academicTermDoc = AcademicTerms.getCurrentAcademicTermDoc();\n    let termsPerYear = 3;\n    if (RadGradProperties.getQuarterSystem()) {\n      termsPerYear = 4;\n    }\n    const academicTermList = [];\n    for (let i = 0; i < 3 * termsPerYear; i++) {\n      academicTermDoc = nextAcademicTerm(academicTermDoc);\n      academicTermList.push(academicTermDoc);\n    }\n    // Map over these academicTerms and return a new list that includes the enrollment data for this course and academicTerm.\n    const enrollmentData = _.map(academicTermList, (doc) => getEnrollmentData(courseID, AcademicTerms.getID(doc)));\n    return { courseID, enrollmentData };\n  },\n});\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/course/CourseCollection.methods.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 224,
    "kind": "function",
    "name": "getEnrollmentData",
    "memberof": "api/course/CourseCollection.methods.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseCollection.methods.ts~getEnrollmentData",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/course/CourseCollection.methods.ts",
    "importStyle": null,
    "description": "Returns an array with two elements: a string with the shortName of the academicTerm, and an integer indicating the\ncurrent planned enrollment for the course in that academicTerm.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "courseID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "termID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 225,
    "kind": "variable",
    "name": "getFutureEnrollmentMethod",
    "memberof": "api/course/CourseCollection.methods.ts",
    "static": true,
    "longname": "api/course/CourseCollection.methods.ts~getFutureEnrollmentMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseCollection.methods.ts",
    "importStyle": "{getFutureEnrollmentMethod}",
    "description": "Given a courseID, returns enrollment data for the upcoming 9 academicTerms.\nThe returned data is an object with fields courseID and enrollmentData.\nCourseID is the course ID.\nEnrollmentData is an array of arrays. Each interior array is a tuple: a string containing the shortname and an\ninteger indicating the enrollment data.",
    "examples": [
      "{ courseID: 'xghuyf2132q3',\n  enrollmentData: [['Sp19', 0], ['Su19', 1], ['Fa19', 5],\n                   ['Sp20', 25], ['Su20', 2], ['Fa20', 0],\n                   ['Sp21', 1], ['Su21', 0], ['Fa21', 1]]\n}"
    ],
    "lineNumber": 39,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/course"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 226,
    "kind": "file",
    "name": "api/course/CourseCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport faker from 'faker';\nimport fc from 'fast-check';\nimport 'mocha';\nimport { Courses } from './CourseCollection';\nimport { makeSampleInterest, makeSampleInterestArray } from '../interest/SampleInterests';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { getRandomCourseSlug } from './CourseUtilities';\nimport { ICourse } from '../../typings/radgrad';\nimport { makeSampleCourse } from './SampleCourses';\nimport { Slugs } from '../slug/SlugCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('CourseCollection', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(5000);\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(1), fc.lorem(20, true), fc.integer(1, 6), (fcName, fcNum, fcDescription, fcCreditHrs) => {\n          const interests = makeSampleInterestArray();\n          const slug = getRandomCourseSlug();\n          const docID1 = Courses.define({ name: fcName, slug, num: fcNum, description: fcDescription, creditHrs: fcCreditHrs, interests });\n          expect(Courses.isDefined(docID1)).to.be.true;\n          Courses.removeIt(docID1);\n          expect(Courses.isDefined(docID1)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Can define duplicates', function test2(done) {\n      const name = faker.lorem.word();\n      const slug = getRandomCourseSlug();\n      const num = faker.lorem.word();\n      const description = faker.lorem.paragraph();\n      const creditHrs = faker.random.number({\n        min: 1,\n        max: 6,\n      });\n      const interests = makeSampleInterestArray(faker.random.number({\n        min: 1,\n        max: 6,\n      }));\n      const docID1 = Courses.define({ name, slug, num, description, creditHrs, interests });\n      const docID2 = Courses.define({ name, slug, num, description, creditHrs, interests });\n      expect(Courses.isDefined(slug)).to.be.true;\n      expect(Courses.isDefined(docID1)).to.be.true;\n      expect(Courses.isDefined(docID2)).to.be.true;\n      expect(docID1).to.equal(docID2);\n      expect(Courses.findDoc(docID1).shortName).to.equal(name);\n      Courses.removeIt(docID2);\n      expect(Courses.isDefined(slug)).to.be.false;\n      expect(Courses.isDefined(docID1)).to.be.false;\n      expect(Courses.isDefined(docID2)).to.be.false;\n      done();\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      const docID = makeSampleCourse();\n      // { name, shortName, num, description, creditHrs, interests, prerequisites, syllabus, retired }\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(1), fc.lorem(1), fc.lorem(20, true), fc.integer(1, 6), fc.lorem(20, true), fc.boolean(),\n          (fcName, fcShortName, fcNum, fcDescription, fcCreditHrs, fcSyllabus, fcRetired) => {\n          const interests2 = makeSampleInterestArray();\n          Courses.update(docID, { name: fcName, shortName: fcShortName, num: fcNum, description: fcDescription, creditHrs: fcCreditHrs, interests: interests2, syllabus: fcSyllabus, retired: fcRetired });\n          const course: ICourse = Courses.findDoc(docID);\n          expect(course.name).to.equal(fcName);\n          expect(course.shortName).to.equal(fcShortName);\n          expect(course.num).to.equal(fcNum);\n          expect(course.description).to.equal(fcDescription);\n          expect(course.creditHrs).to.equal(fcCreditHrs);\n          expect(course.interestIDs).to.have.lengthOf(interests2.length);\n          expect(course.syllabus).to.equal(fcSyllabus);\n          expect(course.retired).to.equal(fcRetired);\n        }),\n      );\n      Courses.removeIt(docID);\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test5() {\n      let docID = makeSampleCourse();\n      const origCourse: ICourse = Courses.findDoc(docID);\n      const dumpObject = Courses.dumpOne(docID);\n      Courses.removeIt(docID);\n      expect(Courses.isDefined(docID)).to.be.false;\n      docID = Courses.restoreOne(dumpObject);\n      const restored: ICourse = Courses.findDoc(docID);\n      expect(origCourse.name).to.equal(restored.name);\n      expect(origCourse.shortName).to.equal(restored.shortName);\n      expect(origCourse.num).to.equal(restored.num);\n      expect(origCourse.description).to.equal(restored.description);\n      expect(origCourse.creditHrs).to.equal(restored.creditHrs);\n      expect(origCourse.syllabus).to.equal(restored.syllabus);\n      expect(origCourse.retired).to.equal(restored.retired);\n    });\n\n    it('Can checkIntegrity no errors', function test6() {\n      const course = Courses.findOne({});\n      const errors = Courses.checkIntegrity();\n      // When we call makeSampleCourse we don't create the courses for the prereqs\n      expect(errors.length).to.equal(course.prerequisites.length);\n    });\n\n    it('Can get slug for course', function test7() {\n      const course = Courses.findOne({});\n      const slug = Slugs.getNameFromID(course.slugID);\n      const badSlug = faker.lorem.word();\n      expect(Courses.findSlugByID(course._id)).to.equal(slug);\n      expect(Courses.findSlugByID(course._id)).to.not.equal(badSlug);\n    });\n\n    it('Can detect if has interest', function test8() {\n      const interestID = makeSampleInterest();\n      const badInterestID = makeSampleInterest();\n      const courseID = makeSampleCourse({ interestID });\n      expect(Courses.hasInterest(courseID, interestID)).to.be.true;\n      expect(Courses.hasInterest(courseID, badInterestID)).to.be.false;\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/course/CourseCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 227,
    "kind": "file",
    "name": "api/course/CourseCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport SimpleSchema from 'simpl-schema';\nimport { Slugs } from '../slug/SlugCollection';\nimport { Interests } from '../interest/InterestCollection';\nimport { CourseInstances } from './CourseInstanceCollection';\nimport { Feeds } from '../feed/FeedCollection';\nimport BaseSlugCollection from '../base/BaseSlugCollection';\nimport { ICourseDefine, ICourseUpdate } from '../../typings/radgrad';\nimport { isSingleChoice, complexChoiceToArray } from '../degree-plan/PlanChoiceUtilities';\nimport { validateCourseSlugFormat } from './CourseUtilities';\nimport { PlanChoices } from '../degree-plan/PlanChoiceCollection';\n\n/**\n * Represents a specific course, such as \"ICS 311\".\n * To represent a specific course for a specific academicTerm, use CourseInstance.\n * @memberOf api/course\n * @extends api/base.BaseSlugCollection\n */\nclass CourseCollection extends BaseSlugCollection {\n  public unInterestingSlug: string;\n\n  /**\n   * Creates the Course collection.\n   */\n  constructor() {\n    super('Course', new SimpleSchema({\n      name: { type: String },\n      shortName: { type: String },\n      slugID: { type: SimpleSchema.RegEx.Id },\n      num: { type: String },\n      description: { type: String },\n      creditHrs: { type: Number },\n      interestIDs: [SimpleSchema.RegEx.Id],\n      // Optional data\n      syllabus: { type: String, optional: true },\n      corequisites: { type: Array },\n      'corequisites.$': String,\n      prerequisites: { type: Array },\n      'prerequisites.$': String,\n      retired: { type: Boolean, optional: true },\n    }));\n    this.defineSchema = new SimpleSchema({\n      name: String,\n      shortName: { type: String, optional: true },\n      slug: String,\n      description: String,\n      creditHrs: { type: SimpleSchema.Integer, optional: true },\n      interests: [String],\n      syllabus: String,\n      corequisites: { type: Array, optional: true },\n      'corequisites.$': String,\n      prerequisites: { type: Array, optional: true },\n      'prerequisites.$': String,\n      retired: { type: Boolean, optional: true },\n    });\n    this.updateSchema = new SimpleSchema({\n      name: { type: String, optional: true },\n      shortName: { type: String, optional: true },\n      description: { type: String, optional: true },\n      creditHrs: { type: SimpleSchema.Integer, optional: true },\n      interests: { type: Array, optional: true },\n      'interests.$': String,\n      syllabus: { type: String, optional: true },\n      prerequisites: { type: Array, optional: true },\n      'prerequisites.$': String,\n      retired: { type: Boolean, optional: true },\n    });\n    this.unInterestingSlug = 'other';\n  }\n\n  /**\n   * Defines a new Course.\n   * @example\n   * Courses.define({ name: 'Introduction to the theory and practice of scripting',\n   *                  shortName: 'Intro to Scripting',\n   *                  slug: 'ics_215',\n   *                  num: 'ICS 215',\n   *                  description: 'Introduction to scripting languages for the integration of applications.',\n   *                  creditHrs: 4,\n   *                  interests: ['perl', 'javascript', 'ruby'],\n   *                  syllabus: 'http://courses.ics.hawaii.edu/syllabuses/ICS215.html',\n   *                  prerequisites: ['ics_211'] });\n   * @param { Object } description Object with keys name, shortName, slug, num, description, creditHrs,\n   *                   interests, syllabus, and prerequisites.\n   * @param name is the official course name.\n   * @param shortName is an optional abbreviation. Defaults to name.\n   * @param slug must not be previously defined.\n   * @param num the course number.\n   * @param creditHrs is optional and defaults to 3. If supplied, must be a num between 1 and 15.\n   * @param interests is a (possibly empty) array of defined interest slugs or interestIDs.\n   * @param syllabus is optional. If supplied, should be a URL.\n   * @param corequisites is optional. If supplied, must be an array of Course slugs or courseIDs.\n   * @param prerequisites is optional. If supplied, must be an array of previously defined Course slugs or courseIDs.\n   * @param retired is optional, defaults to false.\n   * @throws {Meteor.Error} If the definition includes a defined slug or undefined interest or invalid creditHrs.\n   * @returns The newly created docID.\n   */\n  public define({ name, shortName = name, slug, num, description, creditHrs = 3, interests = [], syllabus, corequisites = [], prerequisites = [], retired = false }: ICourseDefine) {\n    // Make sure the slug has the right format <dept>_<number>\n    validateCourseSlugFormat(slug);\n    // check if slug is defined\n    if (Slugs.isSlugForEntity(slug, this.getType())) {\n      // console.log(`${slug} is already defined for ${this.getType()}`);\n      return Slugs.getEntityID(slug, this.getType());\n    }\n    // console.log(`Defining slug ${slug}`);\n    // Get SlugID, throw error if found.\n    const slugID = Slugs.define({ name: slug, entityName: this.getType() });\n    // Get Interests, throw error if any of them are not found.\n    const interestIDs = Interests.getIDs(interests);\n    // Make sure creditHrs is a num between 1 and 15.\n    if (!(typeof creditHrs === 'number') || (creditHrs < 1) || (creditHrs > 15)) {\n      throw new Meteor.Error(`CreditHrs ${creditHrs} is not a number between 1 and 15.`);\n    }\n    if (!Array.isArray(prerequisites)) {\n      throw new Meteor.Error(`Prerequisites ${prerequisites} is not an array.`);\n    }\n    // make sure each corequisite has a valid format.\n    _.forEach(corequisites, (c) => validateCourseSlugFormat(c));\n    // make sure each prerequisite has a valid format.\n    _.forEach(prerequisites, (p) => validateCourseSlugFormat(p));\n    // Currently we don't dump the DB is a way that prevents forward referencing of prereqs, so we\n    // can't check the validity of prereqs during a define, such as with:\n    //   _.each(prerequisites, (prerequisite) => this.getID(prerequisite));\n    // Instead, we check that prereqs are valid as part of checkIntegrity.\n    // We want to create a PlanChoice for all the courses.\n    if (slug !== 'other' && !PlanChoices.isDefined(slug)) {\n      PlanChoices.define({ choice: slug, retired });\n    }\n    const courseID =\n      this.collection.insert({\n        name,\n        shortName,\n        slugID,\n        num,\n        description,\n        creditHrs,\n        interestIDs,\n        syllabus,\n        corequisites,\n        prerequisites,\n        retired,\n      });\n    // Connect the Slug to this Interest\n    Slugs.updateEntityID(slugID, courseID);\n    return courseID;\n  }\n\n  /**\n   * Update a Course.\n   * @param instance The docID (or slug) associated with this course.\n   * @param name optional\n   * @param shortName optional\n   * @param num optional\n   * @param description optional\n   * @param creditHrs optional\n   * @param interests An array of interestIDs or slugs (optional)\n   * @param syllabus optional\n   * @param prerequisites An array of course slugs. (optional)\n   * @param retired optional boolean.\n   */\n  public update(instance: string, { name, shortName, num, description, creditHrs, interests, prerequisites, syllabus, retired }: ICourseUpdate) {\n    const docID = this.getID(instance);\n    const updateData: {\n      name?: string;\n      description?: string;\n      interestIDs?: [string];\n      shortName?: string;\n      num?: string;\n      creditHrs?: number;\n      syllabus?: string;\n      prerequisites?: string[];\n      retired?: boolean;\n    } = {};\n    if (name) {\n      updateData.name = name;\n    }\n    if (description) {\n      updateData.description = description;\n    }\n    if (interests) {\n      const interestIDs = Interests.getIDs(interests);\n      updateData.interestIDs = interestIDs;\n    }\n    if (shortName) {\n      updateData.shortName = shortName;\n    }\n    if (num) {\n      updateData.num = num;\n    }\n    if (creditHrs) {\n      updateData.creditHrs = creditHrs;\n    }\n    if (syllabus) {\n      updateData.syllabus = syllabus;\n    }\n    if (prerequisites) {\n      if (!Array.isArray(prerequisites)) {\n        throw new Meteor.Error(`Prerequisites ${prerequisites} is not an Array.`);\n      }\n      _.forEach(prerequisites, (prereq) => {\n        if (!this.hasSlug(prereq)) {\n          throw new Meteor.Error(`Prerequisite ${prereq} is not a slug for a course.`);\n        }\n      });\n      updateData.prerequisites = prerequisites;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the Course.\n   * @param instance The docID or slug of the entity to be removed.\n   * @throws { Meteor.Error } If docID is not a Course, or if this course has any associated course instances.\n   */\n  public removeIt(instance: string) {\n    const docID = this.getID(instance);\n    // Check that this is not referenced by any Course Instance.\n    CourseInstances.find().map((courseInstance) => {\n      if (courseInstance.courseID === docID) {\n        throw new Meteor.Error(`Course ${instance} is referenced by a course instance ${courseInstance}.`);\n      }\n      return true;\n    });\n    // OK to delete. First remove any Feeds that reference this course.\n    Feeds.find({ courseID: docID }).map((feed) => Feeds.removeIt(feed._id));\n    // Now remove the Course.\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Returns true if Course has the specified interest.\n   * @param course The user (docID or slug)\n   * @param interest The Interest (docID or slug).\n   * @returns {boolean} True if the course has the associated Interest.\n   * @throws { Meteor.Error } If course is not a course or interest is not a Interest.\n   */\n  public hasInterest(course: string, interest: string) {\n    const interestID = Interests.getID(interest);\n    const doc = this.findDoc(course);\n    return _.includes(doc.interestIDs, interestID);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks slugID and interestIDs.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find({}, {}).forEach((doc) => {\n      if (!Slugs.isDefined(doc.slugID)) {\n        problems.push(`Bad slugID: ${doc.slugID}`);\n      }\n      _.forEach(doc.interestIDs, (interestID) => {\n        if (!Interests.isDefined(interestID)) {\n          problems.push(`Bad interestID: ${interestID}`);\n        }\n      });\n      _.forEach(doc.corequisites, (coreq) => {\n        if (isSingleChoice(coreq)) {\n          if (!this.hasSlug(coreq)) {\n            problems.push(`Bad course corequisite slug: ${coreq}`);\n          }\n        } else {\n          const slugs = complexChoiceToArray(coreq);\n          _.forEach(slugs, (slug) => {\n            if (!this.hasSlug(slug)) {\n              problems.push(`Bad course corequisite slug in or: ${slug}`);\n            }\n          });\n        }\n      });\n      _.forEach(doc.prerequisites, (prereq) => {\n        if (isSingleChoice(prereq)) {\n          if (!this.hasSlug(prereq)) {\n            problems.push(`Bad course prerequisite slug: ${prereq}`);\n          }\n        } else {\n          const slugs = complexChoiceToArray(prereq);\n          _.forEach(slugs, (slug) => {\n            if (!this.hasSlug(slug)) {\n              problems.push(`Bad course prerequisite slug in or: ${slug}`);\n            }\n          });\n        }\n      });\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the Course docID in a format acceptable to define().\n   * @param docID The docID of a Course.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID): ICourseDefine {\n    const doc = this.findDoc(docID);\n    const name = doc.name;\n    const shortName = doc.shortName;\n    const slug = Slugs.getNameFromID(doc.slugID);\n    const num = doc.num;\n    const description = doc.description;\n    const creditHrs = doc.creditHrs;\n    const interests = _.map(doc.interestIDs, (interestID) => Interests.findSlugByID(interestID));\n    const syllabus = doc.syllabus;\n    const corequisites = doc.corequisites;\n    const prerequisites = doc.prerequisites;\n    const retired = doc.retired;\n    return {\n      name, shortName, slug, num, description, creditHrs, interests, syllabus, corequisites, prerequisites, retired,\n    };\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @memberOf api/course\n */\nexport const Courses = new CourseCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/course/CourseCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 228,
    "kind": "variable",
    "name": "Courses",
    "memberof": "api/course/CourseCollection.ts",
    "static": true,
    "longname": "api/course/CourseCollection.ts~Courses",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseCollection.ts",
    "importStyle": "{Courses}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 297,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/course"
      }
    ],
    "type": {
      "types": [
        "api/course/CourseCollection.ts~CourseCollection"
      ]
    }
  },
  {
    "__docId__": 229,
    "kind": "class",
    "name": "CourseCollection",
    "memberof": "api/course/CourseCollection.ts",
    "static": true,
    "longname": "api/course/CourseCollection.ts~CourseCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseCollection.ts",
    "importStyle": null,
    "description": "Represents a specific course, such as \"ICS 311\".\nTo represent a specific course for a specific academicTerm, use CourseInstance.",
    "lineNumber": 20,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseSlugCollection.js~BaseSlugCollection"
    ]
  },
  {
    "__docId__": 230,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/course/CourseCollection.ts~CourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseCollection.ts~CourseCollection#constructor",
    "access": "public",
    "description": "Creates the Course collection.",
    "lineNumber": 23
  },
  {
    "__docId__": 231,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/course/CourseCollection.ts~CourseCollection",
    "static": false,
    "longname": "api/course/CourseCollection.ts~CourseCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 232,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/course/CourseCollection.ts~CourseCollection",
    "static": false,
    "longname": "api/course/CourseCollection.ts~CourseCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 233,
    "kind": "member",
    "name": "unInterestingSlug",
    "memberof": "api/course/CourseCollection.ts~CourseCollection",
    "static": false,
    "longname": "api/course/CourseCollection.ts~CourseCollection#unInterestingSlug",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 234,
    "kind": "method",
    "name": "define",
    "memberof": "api/course/CourseCollection.ts~CourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseCollection.ts~CourseCollection#define",
    "access": "public",
    "description": "Defines a new Course.",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "ICourseDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 235,
    "kind": "method",
    "name": "update",
    "memberof": "api/course/CourseCollection.ts~CourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseCollection.ts~CourseCollection#update",
    "access": "public",
    "description": "Update a Course.",
    "lineNumber": 163,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ICourseUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 236,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/course/CourseCollection.ts~CourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseCollection.ts~CourseCollection#removeIt",
    "access": "public",
    "description": "Remove the Course.",
    "lineNumber": 220,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 237,
    "kind": "method",
    "name": "hasInterest",
    "memberof": "api/course/CourseCollection.ts~CourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseCollection.ts~CourseCollection#hasInterest",
    "access": "public",
    "description": "Returns true if Course has the specified interest.",
    "lineNumber": 242,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "course",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "interest",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 238,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/course/CourseCollection.ts~CourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseCollection.ts~CourseCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks slugID and interestIDs.",
    "lineNumber": 254,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 239,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/course/CourseCollection.ts~CourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseCollection.ts~CourseCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the Course docID in a format acceptable to define().",
    "lineNumber": 302,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ICourseDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 240,
    "kind": "file",
    "name": "api/course/CourseInstanceCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport {} from 'mocha';\nimport { expect } from 'chai';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { CourseInstances } from './CourseInstanceCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('CourseInstanceCollection Meteor Methods ', function test() {\n    const collectionName = CourseInstances.getCollectionName();\n    const academicTerm = 'Spring-2017';\n    const student = 'abi@hawaii.edu';\n    const course = 'ics_111';\n    const definitionData = {\n      academicTerm,\n      course,\n      student,\n      verified: true,\n      fromRegistrar: true,\n      grade: 'B',\n      note: '',\n      creditHrs: 3,\n    };\n\n    before(function (done) {\n      this.timeout(5000);\n      defineTestFixturesMethod.call(['minimal', 'abi.student'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions(student);\n      await defineMethod.callPromise({ collectionName, definitionData });\n    });\n\n    it('Update Method', async function () {\n      const id = CourseInstances.findCourseInstanceDoc(academicTerm, course, student)._id;\n      const verified = false;\n      const grade = 'A';\n      const creditHrs = 4;\n      await updateMethod.callPromise({\n        collectionName, updateData: {\n          id, verified, grade, creditHrs,\n        },\n      });\n    });\n\n    it('Remove Method', async function () {\n      const instance = CourseInstances.findCourseInstanceDoc(academicTerm, course, student)._id;\n      await removeItMethod.callPromise({ collectionName, instance });\n    });\n\n  it('Define, update, remove Methods', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      const id = await defineMethod.callPromise({ collectionName, definitionData });\n      expect(id).to.exist;\n      let instance = CourseInstances.findDoc(id);\n      expect(instance).to.exist;\n      expect(instance.grade).to.equal('B');\n      const verified = false;\n      const grade = 'A';\n      const creditHrs = 4;\n      await updateMethod.callPromise({ collectionName, updateData: { id, verified, grade, creditHrs } });\n      instance = CourseInstances.findCourseInstanceDoc(academicTerm, course, student);\n      expect(instance.grade).to.equal('A');\n      await removeItMethod.callPromise({ collectionName, instance });\n      expect(CourseInstances.count()).to.equal(0);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/course/CourseInstanceCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 241,
    "kind": "file",
    "name": "api/course/CourseInstanceCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\n// import faker from 'faker';\nimport fc from 'fast-check';\nimport 'mocha';\n// import { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { CourseInstances } from './CourseInstanceCollection';\nimport { getRandomGrade, makeSampleCourse } from './SampleCourses';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { removeAllEntities } from '../base/BaseUtilities';\n// import { Courses } from './CourseCollection';\nimport { makeSampleAcademicTerm } from '../academic-term/SampleAcademicTerms';\nimport { ICourseInstance } from '../../typings/radgrad';\nimport { Slugs } from '../slug/SlugCollection';\nimport { Courses } from './CourseCollection';\nimport { Users } from '../user/UserCollection';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('CourseInstanceCollection', function testSuite() {\n\n    before(function setup() {\n      this.timeout(5000);\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(5000);\n      const courseID = makeSampleCourse();\n      const termID = makeSampleAcademicTerm();\n      const grade = getRandomGrade();\n      const student = makeSampleUser();\n      fc.assert(\n        fc.property(fc.boolean(), fc.boolean(), fc.lorem(5), fc.integer(1, 15), fc.boolean(), (fcVerified, fcFromRegistrar, fcNote, fcCreditHrs, fcRetired) => {\n          const docID = CourseInstances.define({ academicTerm: termID, course: courseID, creditHrs: fcCreditHrs, fromRegistrar: fcFromRegistrar, grade, note: fcNote, student, retired: fcRetired, verified: fcVerified });\n          expect(CourseInstances.isDefined(docID)).to.be.true;\n          const ci: ICourseInstance = CourseInstances.findDoc(docID);\n          expect(ci.courseID).to.equal(courseID);\n          expect(ci.studentID).to.equal(student);\n          expect(ci.termID).to.equal(termID);\n          expect(ci.grade).to.equal(grade);\n          CourseInstances.removeIt(docID);\n          expect(CourseInstances.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicates', function test2() {\n      const course = makeSampleCourse();\n      const academicTerm = makeSampleAcademicTerm();\n      const grade = getRandomGrade();\n      const student = makeSampleUser();\n      const docID1 = CourseInstances.define({ course, student, academicTerm, grade });\n      const docID2 = CourseInstances.define({ course, student, academicTerm, grade });\n      expect(docID1).to.equal(docID2); // should not be able to take the same class twice in the same term.\n      expect(CourseInstances.isDefined(docID1)).to.be.true;\n      CourseInstances.removeIt(docID1);\n      expect(CourseInstances.isDefined(docID2)).to.be.false;\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      const course = makeSampleCourse();\n      const academicTerm = makeSampleAcademicTerm();\n      const student = makeSampleUser();\n      const grade = getRandomGrade();\n      const docID = CourseInstances.define({ course, student, academicTerm, grade });\n      fc.assert(\n        fc.property(fc.boolean(), fc.boolean(), fc.lorem(5), fc.integer(1, 15), fc.boolean(), (fcVerified, fcFromRegistrar, fcNote, fcCreditHrs, fcRetired) => {\n          const termID = makeSampleAcademicTerm();\n          const gradeChange = getRandomGrade();\n          CourseInstances.update(docID, { termID, creditHrs: fcCreditHrs, fromRegistrar: fcFromRegistrar, grade: gradeChange, note: fcNote, retired: fcRetired, verified: fcVerified });\n          const ci: ICourseInstance = CourseInstances.findDoc(docID);\n          // console.log(ci, gradeChange);\n          expect(ci.termID).to.equal(termID);\n          expect(ci.creditHrs).to.equal(fcCreditHrs);\n          expect(ci.fromRegistrar).to.equal(fcFromRegistrar);\n          expect(ci.grade).to.equal(gradeChange);\n          expect(ci.note).to.equal(fcNote);\n          expect(ci.retired).to.equal(fcRetired);\n          expect(ci.verified).to.equal(fcVerified);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      const ci = CourseInstances.findOne({});\n      let docID = ci._id;\n      const dumpObject = CourseInstances.dumpOne(docID);\n      CourseInstances.removeIt(docID);\n      expect(CourseInstances.isDefined(docID)).to.be.false;\n      docID = CourseInstances.restoreOne(dumpObject);\n      expect(CourseInstances.isDefined(docID)).to.be.true;\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const errors = CourseInstances.checkIntegrity();\n      expect(errors.length).to.equal(0);\n    });\n\n    it('Can removeUser', function test6() {\n      const ci: ICourseInstance = CourseInstances.findOne({});\n      const studentID = ci.studentID;\n      CourseInstances.removeUser(studentID);\n\n      expect(CourseInstances.find({ studentID }).count()).to.equal(0);\n    });\n\n    it('Can getCourseDoc, getCourseSlug, getAcademicTermDoc, getStudentDoc', function test7() {\n      const course = makeSampleCourse();\n      const doc = Courses.findDoc(course);\n      const academicTerm = makeSampleAcademicTerm();\n      const tDoc = AcademicTerms.findDoc(academicTerm);\n      const student = makeSampleUser();\n      const sDoc = Users.getProfile(student);\n      const grade = getRandomGrade();\n      const docID = CourseInstances.define({ course, student, academicTerm, grade });\n\n      /* getCourseDoc */\n      const courseDoc = CourseInstances.getCourseDoc(docID);\n\n      expect(doc.name).to.equal(courseDoc.name);\n      expect(doc.shortName).to.equal(courseDoc.shortName);\n      expect(doc.description).to.equal(courseDoc.description);\n\n      /* getCourseSlug */\n      const courseSlug = Slugs.getNameFromID(doc.slugID);\n\n      expect(CourseInstances.getCourseSlug(docID)).to.equal(courseSlug);\n\n      /* getAcademicTermDoc */\n      const termDoc = CourseInstances.getAcademicTermDoc(docID);\n\n      expect(tDoc.term).to.equal(termDoc.term);\n      expect(tDoc.year).to.equal(termDoc.year);\n\n      /* getStudentDoc */\n      const studentDoc = CourseInstances.getStudentDoc(docID);\n\n      expect(sDoc.username).to.equal(studentDoc.username);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/course/CourseInstanceCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 242,
    "kind": "file",
    "name": "api/course/CourseInstanceCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport SimpleSchema from 'simpl-schema';\nimport { ReactiveAggregate } from 'meteor/jcbernack:reactive-aggregate';\nimport { Courses } from './CourseCollection';\nimport { AcademicYearInstances } from '../degree-plan/AcademicYearInstanceCollection';\nimport { ROLE } from '../role/Role';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { Users } from '../user/UserCollection';\nimport BaseCollection from '../base/BaseCollection';\nimport { makeCourseICE, iceSchema } from '../ice/IceProcessor';\nimport { ICourseInstanceDefine, ICourseInstanceUpdate } from '../../typings/radgrad';\nimport { CourseScoreboardName } from '../../startup/both/names';\n\n/**\n * Represents the taking of a course by a specific student in a specific academicTerm.\n * @memberOf api/course\n * @extends api/base.BaseCollection\n */\nclass CourseInstanceCollection extends BaseCollection {\n  public validGrades: string[];\n  public readonly publicationNames: {\n    scoreboard: string;\n  };\n\n  /**\n   * Creates the CourseInstance collection.\n   */\n  constructor() {\n    super('CourseInstance', new SimpleSchema({\n      termID: SimpleSchema.RegEx.Id,\n      courseID: { type: SimpleSchema.RegEx.Id, optional: true },\n      verified: Boolean,\n      fromRegistrar: { type: Boolean, optional: true },\n      grade: { type: String, optional: true },\n      creditHrs: Number,\n      note: { type: String, optional: true },\n      studentID: SimpleSchema.RegEx.Id,\n      ice: { type: iceSchema, optional: true },\n      retired: { type: Boolean, optional: true },\n    }));\n    this.validGrades = ['', 'A', 'A+', 'A-',\n      'B', 'B+', 'B-', 'C', 'C+', 'C-', 'D', 'D+', 'D-', 'F', 'CR', 'NC', '***', 'W', 'TBD', 'OTHER'];\n    this.publicationNames = {\n      scoreboard: `${this.collectionName}.Scoreboard`,\n    };\n    this.defineSchema = new SimpleSchema({\n      academicTerm: String,\n      course: String,\n      verified: { type: Boolean, optional: true },\n      fromRegistrar: { type: Boolean, optional: true },\n      grade: { type: String, optional: true },\n      note: { type: String, optional: true },\n      student: String,\n      creditHrs: SimpleSchema.Integer,\n    });\n    this.updateSchema = new SimpleSchema({\n      termID: {\n        type: String,\n        optional: true,\n      },\n      verified: { type: Boolean, optional: true },\n      fromRegistrar: { type: Boolean, optional: true },\n      grade: { type: String, optional: true },\n      creditHrs: { type: SimpleSchema.Integer, optional: true },\n      note: { type: String, optional: true },\n      ice: { type: iceSchema, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n    if (Meteor.isServer) {\n      this.collection.rawCollection().createIndex({ _id: 1, studentID: 1, courseID: 1 });\n    }\n  }\n\n  /**\n   * Defines a new CourseInstance.\n   * @example\n   * // To define an instance of a CS course:\n   * CourseInstances.define({ academicTerm: 'Spring-2016',\n   *                          course: 'ics_311',\n   *                          verified: false,\n   *                          fromRegistrar: false,\n   *                          grade: 'B',\n   *                          note: '',\n   *                          student: 'joesmith@hawaii.edu',\n   *                          creditHrs: 3 });\n   * @param { Object } description Object with keys academicTerm, course, verified, fromRegistrar, grade,\n   * note, student, creditHrs.\n   * Required fields: academicTerm, student, course, which must all be valid slugs or instance IDs.\n   * If the course slug is 'other', then the note field will be used as the course number.\n   * Optional fields: note (defaults to ''), valid (defaults to false), grade (defaults to '').\n   * CreditHrs defaults to the creditHrs assigned to course, or can be provided explicitly.\n   * @throws {Meteor.Error} If the definition includes an undefined course or student.\n   * @returns The newly created docID.\n   */\n  public define({ academicTerm, course, verified = false, fromRegistrar = false, grade = '', note = '', student, creditHrs, retired = false }: ICourseInstanceDefine) {\n    // Check arguments\n    const termID = AcademicTerms.getID(academicTerm);\n    const academicTermDoc = AcademicTerms.findDoc(termID);\n    const courseID = Courses.getID(course);\n    const studentID = Users.getID(student);\n    const profile = Users.getProfile(studentID);\n    // ensure the AcademicYearInstance is defined.\n    if (academicTermDoc.term === AcademicTerms.SPRING || academicTermDoc.term === AcademicTerms.SUMMER || academicTermDoc.term === AcademicTerms.WINTER) {\n      AcademicYearInstances.define({ year: academicTermDoc.year - 1, student: profile.username });\n    } else {\n      AcademicYearInstances.define({ year: academicTermDoc.year, student: profile.username });\n    }\n    const doc = this.collection.findOne({ termID, courseID, studentID });\n    if (doc) {\n      return doc._id;\n    }\n    const ice = makeCourseICE(course, grade);\n    if ((typeof verified) !== 'boolean') {\n      throw new Meteor.Error(`${verified} is not a boolean.`);\n    }\n    if (!_.includes(this.validGrades, grade)) {\n      if (grade.startsWith('I')) {\n        grade = grade.substring(1); // eslint-disable-line no-param-reassign\n      }\n      if (!_.includes(this.validGrades, grade)) {\n        throw new Meteor.Error(`${grade} is not a valid grade.`);\n      }\n    }\n    if (!creditHrs) {\n      /* eslint-disable-next-line no-param-reassign */\n      creditHrs = Courses.findDoc(courseID).creditHrs;\n    }\n    // Define and return the CourseInstance\n    return this.collection.insert({\n      termID,\n      courseID,\n      verified,\n      fromRegistrar,\n      grade,\n      studentID,\n      creditHrs,\n      note,\n      ice,\n      retired,\n    });\n  }\n\n  /**\n   * Update the course instance. Only a subset of fields can be updated.\n   * @param docID The course instance docID (required).\n   * @param termID the termID for the course instance optional.\n   * @param verified boolean optional.\n   * @param fromRegistrar boolean optional.\n   * @param grade optional.\n   * @param creditHrs optional.\n   * @param note optional.\n   * @param ice an object with fields i, c, e (optional)\n   */\n  public update(docID: string, { termID, verified, fromRegistrar, grade, creditHrs, note, ice, retired }: ICourseInstanceUpdate) {\n    // console.log('CourseInstances.update', termID, verified, fromRegistrar, grade, creditHrs, note, ice);\n    this.assertDefined(docID);\n    const updateData: ICourseInstanceUpdate = {};\n    if (termID) {\n      updateData.termID = termID;\n    }\n    if (_.isBoolean(verified)) {\n      updateData.verified = verified;\n    }\n    if (_.isBoolean(fromRegistrar)) {\n      updateData.fromRegistrar = fromRegistrar;\n    }\n    if (grade) {\n      updateData.grade = grade;\n      const ci = this.findDoc(docID);\n      const slug = Courses.findSlugByID(ci.courseID);\n      updateData.ice = makeCourseICE(slug, grade);\n    }\n    if (creditHrs) {\n      updateData.creditHrs = creditHrs;\n    }\n    if (note) {\n      updateData.note = note;\n    }\n    if (ice) {\n      updateData.ice = ice;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the course instance.\n   * @param docID The docID of the course instance.\n   */\n  public removeIt(docID: string) {\n    this.assertDefined(docID);\n    // OK, clear to delete.\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Removes all CourseInstance documents referring to user.\n   * @param user The user, either the ID or the username.\n   * @throws { Meteor.Error } If user is not an ID or username.\n   */\n  public removeUser(user: string) {\n    const studentID = Users.getID(user);\n    this.collection.remove({ studentID });\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\n   * Student.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.STUDENT]);\n  }\n\n  /**\n   * Returns the Course associated with the CourseInstance with the given instanceID.\n   * @param instanceID The id of the CourseInstance.\n   * @returns {Object} The associated Course.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  public getCourseDoc(instanceID: string) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Courses.findDoc(instance.courseID);\n  }\n\n  /**\n   * Returns the Course slug for the instance's corresponding Course.\n   * @param instanceID The CourseInstanceID.\n   * @return {string} The course slug.\n   */\n  public getCourseSlug(instanceID: string) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Courses.findSlugByID(instance.courseID);\n  }\n\n  /**\n   * Gets the publication names.\n   * @returns {{student: string; perStudentAndAcademicTerm: string; publicStudent: string; publicSlugStudent: string; studentID: string}}\n   */\n  public getPublicationNames() {\n    return this.publicationNames;\n  }\n\n  /**\n   * Returns the AcademicTerm associated with the CourseInstance with the given instanceID.\n   * @param instanceID The id of the CourseInstance.\n   * @returns {Object} The associated AcademicTerm.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  public getAcademicTermDoc(instanceID: string) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return AcademicTerms.findDoc(instance.termID);\n  }\n\n  /**\n   * Returns a schema for the update method's second parameter.\n   * @returns { SimpleSchema }.\n   */\n  public getUpdateSchema() {\n    const terms = AcademicTerms.find({}, { sort: { termNumber: 1 }, fields: { _id: 1 } }).fetch();\n    // console.log(terms);\n    this.updateSchema = new SimpleSchema({\n      termID: {\n        type: String,\n        optional: true,\n        allowedValues: _.map(terms, (term) => term._id),\n      },\n      verified: { type: Boolean, optional: true },\n      fromRegistrar: { type: Boolean, optional: true },\n      grade: { type: String, optional: true },\n      creditHrs: { type: SimpleSchema.Integer, optional: true },\n      note: { type: String, optional: true },\n      ice: { type: iceSchema, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n\n    return this.updateSchema;\n  }\n\n  /**\n   * Returns the Student profile associated with the CourseInstance with the given instanceID.\n   * @param instanceID The id of the CourseInstance.\n   * @returns {Object} The associated Student profile.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  public getStudentDoc(instanceID: string) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Users.getProfile(instance.studentID);\n  }\n\n  /**\n   * @returns { String } The course name associated with courseInstanceID.\n   * @param courseInstanceID The course instance ID.\n   * @throws {Meteor.Error} If courseInstanceID is not a valid ID.\n   */\n  public findCourseName(courseInstanceID: string) {\n    this.assertDefined(courseInstanceID);\n    const courseID = this.findDoc(courseInstanceID).courseID;\n    return Courses.findDoc(courseID).name;\n  }\n\n  /**\n   * Returns the courseInstance document associated with academicTerm, course, and student.\n   * @param academicTerm The academicTerm (slug or ID).\n   * @param course The course (slug or ID).\n   * @param student The student (slug or ID)\n   * @returns { Object } Returns the document or null if not found.\n   * @throws { Meteor.Error } If academicTerm, course, or student does not exist.\n   */\n  public findCourseInstanceDoc(academicTerm: string, course: string, student: string) {\n    const termID = AcademicTerms.getID(academicTerm);\n    const studentID = Users.getID(student);\n    const courseID = Courses.getID(course);\n    return this.collection.findOne({ termID, studentID, courseID });\n  }\n\n  /**\n   * Returns true if there exists a CourseInstance for the given academicTerm, course, and student.\n   * @param academicTerm The academicTerm (slug or ID).\n   * @param course The course (slug or ID).\n   * @param student The student (slug or ID).\n   * @returns True if the course instance exists.\n   * @throws { Meteor.Error } If academicTerm, course, or student does not exist.\n   */\n  public isCourseInstance(academicTerm: string, course: string, student: string) {\n    return !!this.findCourseInstanceDoc(academicTerm, course, student);\n  }\n\n  /**\n   * @returns { boolean } If the course is an interesting course associated with courseInstanceID.\n   * @param courseInstanceID The course instance ID.\n   * @throws {Meteor.Error} If courseInstanceID is not a valid ID.\n   */\n  public isInteresting(courseInstanceID: string) {\n    this.assertDefined(courseInstanceID);\n    const instance = this.findDoc(courseInstanceID);\n    return Courses.findDoc(instance.courseID).num !== Courses.unInterestingSlug;\n  }\n\n  /**\n   * Depending on the logged in user publish only their CourseInstances. If\n   * the user is in the Role.ADMIN then publish all CourseInstances.\n   */\n  public publish() {\n    if (Meteor.isServer) {\n      const instance = this;\n      Meteor.publish(this.publicationNames.scoreboard, function publishCourseScoreboard() {\n        ReactiveAggregate(this, instance.collection, [\n          {\n            $addFields: { courseTerm: { $concat: ['$courseID', ' ', '$termID'] } },\n          },\n          {\n            $group: {\n              _id: '$courseTerm',\n              count: { $sum: 1 },\n            },\n          },\n          { $project: { count: 1, termID: 1, courseID: 1 } },\n        ], { clientCollection: CourseScoreboardName });\n      });\n      Meteor.publish(this.collectionName, function filterStudentID(studentID) { // eslint-disable-line meteor/audit-argument-checks\n        // console.log('publish studentID %o is admin = %o', studentID, Roles.userIsInRole(studentID, [ROLE.ADMIN]));\n        if (_.isNil(studentID)) {\n          return this.ready();\n        }\n        const profile = Users.getProfile(studentID);\n        if (profile.role === ROLE.ADMIN || Meteor.isAppTest) {\n          return instance.collection.find();\n        }\n        return instance.collection.find({ studentID, retired: { $not: { $eq: true } } });\n      });\n    }\n  }\n\n  /**\n   * @returns {string} A formatted string representing the course instance.\n   * @param courseInstanceID The course instance ID.\n   * @throws {Meteor.Error} If not a valid ID.\n   */\n  public toString(courseInstanceID: string) {\n    this.assertDefined(courseInstanceID);\n    const courseInstanceDoc = this.findDoc(courseInstanceID);\n    const courseName = this.findCourseName(courseInstanceID);\n    const academicTerm = AcademicTerms.toString(courseInstanceDoc.termID);\n    const grade = courseInstanceDoc.grade;\n    return `[CI ${academicTerm} ${courseName} ${grade}]`;\n  }\n\n  /**\n   * Updates the CourseInstance's grade. This should be used for planning purposes.\n   * @param courseInstanceID The course instance ID.\n   * @param grade The new grade.\n   * @throws {Meteor.Error} If courseInstanceID is not a valid ID.\n   */\n  public updateGrade(courseInstanceID: string, grade: string) {\n    this.assertDefined(courseInstanceID);\n    const ice = makeCourseICE(courseInstanceID, grade);\n    this.collection.update({ _id: courseInstanceID }, { $set: { grade, ice, verified: false } });\n  }\n\n  /**\n   * Updates the CourseInstance's AcademicTerm.\n   * @param courseInstanceID The course instance ID.\n   * @param termID The academicTerm id.\n   * @throws {Meteor.Error} If courseInstanceID is not a valid ID.\n   */\n  public updateAcademicTerm(courseInstanceID: string, termID: string) {\n    this.assertDefined(courseInstanceID);\n    AcademicTerms.assertAcademicTerm(termID);\n    this.collection.update({ _id: courseInstanceID }, { $set: { termID } });\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks termID, courseID, and studentID.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (!AcademicTerms.isDefined(doc.termID)) {\n        problems.push(`Bad termID: ${doc.termID}`);\n      }\n      if (!Courses.isDefined(doc.courseID)) {\n        problems.push(`Bad courseID: ${doc.courseID}`);\n      }\n      if (!Users.isDefined(doc.studentID)) {\n        problems.push(`Bad studentID: ${doc.studentID}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the CourseInstance docID in a format acceptable to define().\n   * @param docID The docID of a CourseInstance.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): ICourseInstanceDefine {\n    const doc = this.findDoc(docID);\n    const academicTerm = AcademicTerms.findSlugByID(doc.termID);\n    const course = Courses.findSlugByID(doc.courseID);\n    const note = doc.note;\n    const verified = doc.verified;\n    const creditHrs = doc.creditHrs;\n    const grade = doc.grade;\n    const fromRegistrar = doc.fromRegistrar;\n    const student = Users.getProfile(doc.studentID).username;\n    const retired = doc.retired;\n    return { academicTerm, course, note, verified, fromRegistrar, creditHrs, grade, student, retired };\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @memberOf api/course\n */\nexport const CourseInstances = new CourseInstanceCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/course/CourseInstanceCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 243,
    "kind": "variable",
    "name": "CourseInstances",
    "memberof": "api/course/CourseInstanceCollection.ts",
    "static": true,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstances",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseInstanceCollection.ts",
    "importStyle": "{CourseInstances}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 499,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/course"
      }
    ],
    "type": {
      "types": [
        "api/course/CourseInstanceCollection.ts~CourseInstanceCollection"
      ]
    }
  },
  {
    "__docId__": 244,
    "kind": "class",
    "name": "CourseInstanceCollection",
    "memberof": "api/course/CourseInstanceCollection.ts",
    "static": true,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseInstanceCollection.ts",
    "importStyle": null,
    "description": "Represents the taking of a course by a specific student in a specific academicTerm.",
    "lineNumber": 20,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 245,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#constructor",
    "access": "public",
    "description": "Creates the CourseInstance collection.",
    "lineNumber": 23
  },
  {
    "__docId__": 246,
    "kind": "member",
    "name": "validGrades",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#validGrades",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    }
  },
  {
    "__docId__": 247,
    "kind": "member",
    "name": "publicationNames",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#publicationNames",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "{\"scoreboard\": *}"
      ]
    }
  },
  {
    "__docId__": 248,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 249,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 250,
    "kind": "method",
    "name": "define",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#define",
    "access": "public",
    "description": "Defines a new CourseInstance.",
    "lineNumber": 96,
    "params": [
      {
        "nullable": null,
        "types": [
          "ICourseInstanceDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 251,
    "kind": "method",
    "name": "update",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#update",
    "access": "public",
    "description": "Update the course instance. Only a subset of fields can be updated.",
    "lineNumber": 155,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ICourseInstanceUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 252,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#removeIt",
    "access": "public",
    "description": "Remove the course instance.",
    "lineNumber": 193,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 253,
    "kind": "method",
    "name": "removeUser",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#removeUser",
    "access": "public",
    "description": "Removes all CourseInstance documents referring to user.",
    "lineNumber": 204,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 254,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\nStudent.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 216,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 255,
    "kind": "method",
    "name": "getCourseDoc",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#getCourseDoc",
    "access": "public",
    "description": "Returns the Course associated with the CourseInstance with the given instanceID.",
    "lineNumber": 226,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 256,
    "kind": "method",
    "name": "getCourseSlug",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#getCourseSlug",
    "access": "public",
    "description": "Returns the Course slug for the instance's corresponding Course.",
    "lineNumber": 237,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 257,
    "kind": "method",
    "name": "getPublicationNames",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#getPublicationNames",
    "access": "public",
    "description": "Gets the publication names.",
    "lineNumber": 247,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 258,
    "kind": "method",
    "name": "getAcademicTermDoc",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#getAcademicTermDoc",
    "access": "public",
    "description": "Returns the AcademicTerm associated with the CourseInstance with the given instanceID.",
    "lineNumber": 257,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 259,
    "kind": "method",
    "name": "getUpdateSchema",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#getUpdateSchema",
    "access": "public",
    "description": "Returns a schema for the update method's second parameter.",
    "lineNumber": 267,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 261,
    "kind": "method",
    "name": "getStudentDoc",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#getStudentDoc",
    "access": "public",
    "description": "Returns the Student profile associated with the CourseInstance with the given instanceID.",
    "lineNumber": 294,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 262,
    "kind": "method",
    "name": "findCourseName",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#findCourseName",
    "access": "public",
    "description": "",
    "lineNumber": 304,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ String } The course name associated with courseInstanceID."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "courseInstanceID",
        "description": "The course instance ID."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " String "
      ],
      "spread": false,
      "description": "The course name associated with courseInstanceID."
    },
    "throws": [
      {
        "types": [
          "Meteor.Error"
        ],
        "description": "If courseInstanceID is not a valid ID."
      }
    ]
  },
  {
    "__docId__": 263,
    "kind": "method",
    "name": "findCourseInstanceDoc",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#findCourseInstanceDoc",
    "access": "public",
    "description": "Returns the courseInstance document associated with academicTerm, course, and student.",
    "lineNumber": 319,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "academicTerm",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "course",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "student",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 264,
    "kind": "method",
    "name": "isCourseInstance",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#isCourseInstance",
    "access": "public",
    "description": "Returns true if there exists a CourseInstance for the given academicTerm, course, and student.",
    "lineNumber": 334,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "academicTerm",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "course",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "student",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 265,
    "kind": "method",
    "name": "isInteresting",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#isInteresting",
    "access": "public",
    "description": "",
    "lineNumber": 355,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ boolean } If the course is an interesting course associated with courseInstanceID."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "courseInstanceID",
        "description": "The course instance ID."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " boolean "
      ],
      "spread": false,
      "description": "If the course is an interesting course associated with courseInstanceID."
    },
    "throws": [
      {
        "types": [
          "Meteor.Error"
        ],
        "description": "If courseInstanceID is not a valid ID."
      }
    ]
  },
  {
    "__docId__": 266,
    "kind": "method",
    "name": "publish",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#publish",
    "access": "public",
    "description": "Depending on the logged in user publish only their CourseInstances. If\nthe user is in the Role.ADMIN then publish all CourseInstances.",
    "lineNumber": 353,
    "params": [],
    "return": null
  },
  {
    "__docId__": 267,
    "kind": "method",
    "name": "toString",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#toString",
    "access": "public",
    "description": "",
    "lineNumber": 410,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} A formatted string representing the course instance."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "courseInstanceID",
        "description": "The course instance ID."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "A formatted string representing the course instance."
    },
    "throws": [
      {
        "types": [
          "Meteor.Error"
        ],
        "description": "If not a valid ID."
      }
    ]
  },
  {
    "__docId__": 268,
    "kind": "method",
    "name": "updateGrade",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#updateGrade",
    "access": "public",
    "description": "Updates the CourseInstance's grade. This should be used for planning purposes.",
    "lineNumber": 404,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "courseInstanceID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "grade",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 269,
    "kind": "method",
    "name": "updateAcademicTerm",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#updateAcademicTerm",
    "access": "public",
    "description": "Updates the CourseInstance's AcademicTerm.",
    "lineNumber": 416,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "courseInstanceID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "termID",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 270,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks termID, courseID, and studentID.",
    "lineNumber": 428,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 271,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/course/CourseInstanceCollection.ts~CourseInstanceCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the CourseInstance docID in a format acceptable to define().",
    "lineNumber": 449,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ICourseInstanceDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 272,
    "kind": "file",
    "name": "api/course/CourseUtilities.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport faker from 'faker';\nimport { CourseInstances } from './CourseInstanceCollection';\nimport { Courses } from './CourseCollection';\nimport PreferredChoice from '../degree-plan/PreferredChoice';\nimport { Users } from '../user/UserCollection';\nimport { profileGetInterestIDs } from '../../ui/components/shared/data-model-helper-functions';\nimport { ICourse } from '../../typings/radgrad';\n\n/**\n * Returns true if the coursesTakenSlugs fulfills courseID's prerequisites.\n * @memberOf api/course\n * @param coursesTakenSlugs slugs of the courses taken.\n * @param courseID course ID.\n * @return {boolean}\n * @memberOf api/course\n */\nexport function prereqsMet(coursesTakenSlugs: string[], courseID: string) {\n  const course = Courses.findDoc(courseID);\n  let ret = true;\n  _.forEach(course.prerequisites, (prereq) => {\n    if (_.indexOf(coursesTakenSlugs, prereq) === -1) {\n      ret = false;\n      return false;\n    }\n    return true;\n  });\n  return ret;\n}\n\nfunction getRandomInt(min: number, max: number) {\n  min = Math.ceil(min); // eslint-disable-line no-param-reassign\n  max = Math.floor(max); // eslint-disable-line no-param-reassign\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n\nexport function clearPlannedCourseInstances(studentID: string) {\n  const courses = CourseInstances.find({ studentID, verified: false, fromRegistrar: false }).fetch();\n  _.forEach(courses, (ci) => {\n    CourseInstances.removeIt(ci);\n  });\n}\n\nexport function get300LevelDocs(): ICourse[] {\n  return Courses.find({ num: /3\\d\\d/ }).fetch();\n}\n\nexport function getStudent300LevelDocs(studentID: string, coursesTakenSlugs: string[]) {\n  let ret = [];\n  const courses: ICourse[] = get300LevelDocs();\n  const instances = CourseInstances.find({ studentID }).fetch();\n  const courseTakenIDs = [];\n  instances.forEach((courseInstance) => {\n    if (CourseInstances.isInteresting(courseInstance._id)) {\n      if (courseInstance.note !== 'ICS 499') { // TODO: hardcoded ICS string\n        courseTakenIDs.push(courseInstance.courseID);\n      }\n    }\n  });\n  ret = _.filter(courses, (c) => _.indexOf(courseTakenIDs, c._id) === -1);\n  ret = _.filter(ret, (c) => prereqsMet(coursesTakenSlugs, c._id)); // remove courses that don't have the prerequisites\n  return ret;\n}\n\nexport function bestStudent300LevelCourses(studentID: string, coursesTakenSlugs: string[]) {\n  const choices = getStudent300LevelDocs(studentID, coursesTakenSlugs);\n  const profile = Users.getProfile(studentID);\n  const interestIDs = profileGetInterestIDs(profile);\n  const preferred = new PreferredChoice(choices, interestIDs);\n  return preferred.getBestChoices();\n}\n\nexport function chooseStudent300LevelCourse(studentID: string, coursesTakenSlugs: string[]) {\n  const best = bestStudent300LevelCourses(studentID, coursesTakenSlugs);\n  return best[getRandomInt(0, best.length)];\n}\n\nexport function get400LevelDocs() {\n  return Courses.find({ number: /4\\d\\d/ }).fetch();\n}\n\nexport function getStudent400LevelDocs(studentID: string, coursesTakenSlugs: string[]) {\n  let ret = [];\n  const courses = get400LevelDocs();\n  const instances = CourseInstances.find({ studentID }).fetch();\n  const courseTakenIDs = [];\n  instances.forEach((courseInstance) => {\n    if (CourseInstances.isInteresting(courseInstance._id)) {\n      if (!courseInstance.note.endsWith('499')) {\n        courseTakenIDs.push(courseInstance.courseID);\n      }\n    }\n  });\n  ret = _.filter(courses, (c) => _.indexOf(courseTakenIDs, c._id) === -1);\n  ret = _.filter(ret, (c) => prereqsMet(coursesTakenSlugs, c._id)); // remove courses that don't have the prerequisites\n  return ret;\n}\n\nexport function bestStudent400LevelCourses(studentID, coursesTakenSlugs) {\n  const choices = getStudent400LevelDocs(studentID, coursesTakenSlugs);\n  const profile = Users.getProfile(studentID);\n  const interestIDs = profileGetInterestIDs(profile);\n  const preferred = new PreferredChoice(choices, interestIDs);\n  return preferred.getBestChoices();\n}\n\nexport function chooseStudent400LevelCourse(studentID, coursesTakenSlugs) {\n  const best = bestStudent400LevelCourses(studentID, coursesTakenSlugs);\n  return best[getRandomInt(0, best.length)];\n}\n\n/**\n * Chooses the 'best' course to take given an array of slugs, the student and the courses the student\n * has taken.\n * @param slugs an array of course slugs to choose between.\n * @param studentID the student's ID.\n * @param coursesTakenSlugs an array of the course slugs the student has taken.\n * @returns {*}\n * @memberOf api/course\n */\nexport function chooseBetween(slugs, studentID, coursesTakenSlugs) {\n  // console.log('chooseBetween', slugs, coursesTakenSlugs);\n  const courses = [];\n  _.forEach(slugs, (slug) => {\n    const courseID = Courses.getID(slug);\n    if (prereqsMet(coursesTakenSlugs, courseID)) {\n      courses.push(Courses.findDoc(courseID));\n    }\n  });\n  const profile = Users.getProfile(studentID);\n  const interestIDs = profileGetInterestIDs(profile);\n  const preferred = new PreferredChoice(courses, interestIDs);\n  const best = preferred.getBestChoices();\n  if (best) {\n    // console.log('chooseBetween', best, interestIDs);\n    return best[getRandomInt(0, best.length)];\n  }\n  return null;\n}\n\n/**\n * Checks the format of the getCourseSlug. Does not check to see if the slug is defined. Valid course\n * slugs have the format <dept>_<number>.\n * @param courseSlug the slug to check.\n * @returns {boolean}\n * @throws Meteor.Error if the slug doesn't have the right format.\n */\nexport function validateCourseSlugFormat(courseSlug): boolean {\n  if (courseSlug !== 'other' && courseSlug.indexOf('_') === -1) {\n    throw new Meteor.Error(`${courseSlug} is not a valid course slug.`);\n  }\n  return true;\n}\n\n/**\n * Returns the department from the given course slug.\n * @param courseSlug the course slug.\n * @returns {string}\n * @memberOf api/course\n */\nexport function getDepartment(courseSlug): string {\n  return courseSlug.split('_')[0].toUpperCase();\n}\n\n/**\n * Returns the number portion of the getCourseSlug.\n * @param courseSlug the course slug.\n * @returns {string}\n */\nexport function getCourseNumber(courseSlug): string {\n  return courseSlug.split('_')[1];\n}\n\n/**\n * Returns a random department string.\n * @param {number} length\n * @returns {string}\n */\nexport function getRandomDepartment(length: number = 3): string {\n  let retVal = '';\n  for (let i = 0; i < length; i++) {\n    retVal = `${retVal}${faker.random.alphaNumeric()}`;\n  }\n  return retVal;\n}\n\n/**\n * Returns a random course slug for the given department.\n * @param {string} dept the department\n * @param {number} min the minimum course number, (optional) defaults to 100.\n * @param {number} max the maximum course number, (optional) defaults to 800.\n * @returns {string}\n */\nexport function getRandomCourseSlugForDept(dept: string, min: number = 100, max: number = 800): string {\n  return `${dept}_${faker.random.number({\n    min,\n    max,\n  })}`;\n}\n\n/**\n * Returns a random course slug for a random department.\n * @param {number} deptLength the length of the department string, defaults to 3.\n * @param {number} min the minimum course number, (optional) defaults to 100.\n * @param {number} max the maximum course number, (optional) defaults to 800.\n * @returns {string}\n */\nexport function getRandomCourseSlug(deptLength: number = 3, min: number = 100, max: number = 800): string {\n  const deptName = getRandomDepartment(deptLength);\n  return getRandomCourseSlugForDept(deptName, min, max);\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/course/CourseUtilities.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 273,
    "kind": "function",
    "name": "prereqsMet",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~prereqsMet",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{prereqsMet}",
    "description": "Returns true if the coursesTakenSlugs fulfills courseID's prerequisites.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesTakenSlugs",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "courseID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 274,
    "kind": "function",
    "name": "getRandomInt",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~getRandomInt",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "min",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "max",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 275,
    "kind": "function",
    "name": "clearPlannedCourseInstances",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~clearPlannedCourseInstances",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{clearPlannedCourseInstances}",
    "description": "",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 276,
    "kind": "function",
    "name": "get300LevelDocs",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~get300LevelDocs",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{get300LevelDocs}",
    "description": "",
    "lineNumber": 45,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 277,
    "kind": "function",
    "name": "getStudent300LevelDocs",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~getStudent300LevelDocs",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{getStudent300LevelDocs}",
    "description": "",
    "lineNumber": 49,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesTakenSlugs",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 278,
    "kind": "function",
    "name": "bestStudent300LevelCourses",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~bestStudent300LevelCourses",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{bestStudent300LevelCourses}",
    "description": "",
    "lineNumber": 66,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesTakenSlugs",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 279,
    "kind": "function",
    "name": "chooseStudent300LevelCourse",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~chooseStudent300LevelCourse",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{chooseStudent300LevelCourse}",
    "description": "",
    "lineNumber": 74,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesTakenSlugs",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 280,
    "kind": "function",
    "name": "get400LevelDocs",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~get400LevelDocs",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{get400LevelDocs}",
    "description": "",
    "lineNumber": 79,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 281,
    "kind": "function",
    "name": "getStudent400LevelDocs",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~getStudent400LevelDocs",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{getStudent400LevelDocs}",
    "description": "",
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesTakenSlugs",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 282,
    "kind": "function",
    "name": "bestStudent400LevelCourses",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~bestStudent400LevelCourses",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{bestStudent400LevelCourses}",
    "description": "",
    "lineNumber": 100,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesTakenSlugs",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 283,
    "kind": "function",
    "name": "chooseStudent400LevelCourse",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~chooseStudent400LevelCourse",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{chooseStudent400LevelCourse}",
    "description": "",
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesTakenSlugs",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 284,
    "kind": "function",
    "name": "chooseBetween",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~chooseBetween",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{chooseBetween}",
    "description": "Chooses the 'best' course to take given an array of slugs, the student and the courses the student\nhas taken.",
    "lineNumber": 122,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "slugs",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesTakenSlugs",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 285,
    "kind": "function",
    "name": "validateCourseSlugFormat",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~validateCourseSlugFormat",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{validateCourseSlugFormat}",
    "description": "Checks the format of the getCourseSlug. Does not check to see if the slug is defined. Valid course\nslugs have the format <dept>_<number>.",
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "courseSlug",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 286,
    "kind": "function",
    "name": "getDepartment",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~getDepartment",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{getDepartment}",
    "description": "Returns the department from the given course slug.",
    "lineNumber": 162,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "courseSlug",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 287,
    "kind": "function",
    "name": "getCourseNumber",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~getCourseNumber",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{getCourseNumber}",
    "description": "Returns the number portion of the getCourseSlug.",
    "lineNumber": 171,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "courseSlug",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 288,
    "kind": "function",
    "name": "getRandomDepartment",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~getRandomDepartment",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{getRandomDepartment}",
    "description": "Returns a random department string.",
    "lineNumber": 180,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "length",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 289,
    "kind": "function",
    "name": "getRandomCourseSlugForDept",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~getRandomCourseSlugForDept",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{getRandomCourseSlugForDept}",
    "description": "Returns a random course slug for the given department.",
    "lineNumber": 195,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dept",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "min",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "max",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 290,
    "kind": "function",
    "name": "getRandomCourseSlug",
    "memberof": "api/course/CourseUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/CourseUtilities.ts~getRandomCourseSlug",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/CourseUtilities.ts",
    "importStyle": "{getRandomCourseSlug}",
    "description": "Returns a random course slug for a random department.",
    "lineNumber": 209,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "deptLength",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "min",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "max",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 291,
    "kind": "file",
    "name": "api/course/SampleCourses.ts",
    "content": "import faker from 'faker';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { Courses } from './CourseCollection';\nimport { CourseInstances } from './CourseInstanceCollection';\nimport { makeSampleInterestArray } from '../interest/SampleInterests';\nimport { getRandomCourseSlug } from './CourseUtilities';\nimport { Slugs } from '../slug/SlugCollection';\n\nconst makePrerequisiteArray = (numPrereqs: number = 0) => {\n  const retVal = [];\n  for (let i = 0; i < numPrereqs; i++) {\n    retVal.push(getRandomCourseSlug());\n  }\n  return retVal;\n};\n\n/**\n * Creates a Course with a unique slug and returns its docID.\n * @param args An optional object containing arguments to the courses.define function.\n * @returns { String } The docID of the newly generated Course.\n * @memberOf api/course\n */\nexport const makeSampleCourse = (args?: { num?: string; interestID?: string; }) => {\n  const name = faker.lorem.words();\n  const slug = getRandomCourseSlug();\n  const num = (args && args.num) ? args.num : faker.lorem.words();\n  const description = faker.lorem.paragraph();\n  const creditHrs = faker.random.number({\n    min: 1,\n    max: 15,\n  });\n  const interests = (args && args.interestID) ? [args.interestID] : makeSampleInterestArray(faker.random.number({\n    min: 1,\n    max: 6,\n  }));\n  const syllabus = faker.lorem.paragraph();\n  const prerequisites = makePrerequisiteArray(faker.random.number({ max: 4 }));\n  return Courses.define({ name, slug, num, description, creditHrs, syllabus, prerequisites, interests });\n};\n\n/**\n * Creates an array of defined course slugs.\n * @param num the number of slugs.\n * Returns an array of defined course slugs.\n */\nexport const makeSampleCourseSlugArray = (num = 1) => {\n  const retVal = [];\n  for (let i = 0; i < num; i++) {\n    retVal.push(Slugs.getNameFromID(Courses.findDoc(makeSampleCourse()).slugID));\n  }\n  return retVal;\n};\n\n/**\n * Creates a CourseInstance with a unique slug and returns its docID.\n * Also creates a new Course.\n * @param student The student slug associated with this course.\n * @param args Optional object providing arguments to the CourseInstance definition.\n * @returns { String } The docID for the newly generated Interest.\n * @memberOf api/course\n */\nexport function makeSampleCourseInstance(student, args) {\n  const academicTerm = AcademicTerms.define({ term: AcademicTerms.FALL, year: 2013 });\n  const course = (args && args.course) ? args.course : makeSampleCourse();\n  const verified = true;\n  const grade = 'A';\n  const note = `ABC ${course.num}`;\n  return CourseInstances.define({ academicTerm, course, verified, grade, student, note });\n}\n\nexport const getRandomGrade = (): string => {\n  const index = faker.random.number({ min: 1, max: CourseInstances.validGrades.length - 1 });\n  return CourseInstances.validGrades[index];\n};\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/course/SampleCourses.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 292,
    "kind": "function",
    "name": "makePrerequisiteArray",
    "memberof": "api/course/SampleCourses.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/SampleCourses.ts~makePrerequisiteArray",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/course/SampleCourses.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "params": [
      {
        "name": "numPrereqs",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 293,
    "kind": "function",
    "name": "makeSampleCourse",
    "memberof": "api/course/SampleCourses.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/SampleCourses.ts~makeSampleCourse",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/SampleCourses.ts",
    "importStyle": "{makeSampleCourse}",
    "description": "Creates a Course with a unique slug and returns its docID.",
    "lineNumber": 21,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ String } The docID of the newly generated Course."
      },
      {
        "tagName": "@memberOf",
        "tagValue": "api/course"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": "An optional object containing arguments to the courses.define function."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        " String "
      ],
      "spread": false,
      "description": "The docID of the newly generated Course."
    }
  },
  {
    "__docId__": 294,
    "kind": "function",
    "name": "makeSampleCourseSlugArray",
    "memberof": "api/course/SampleCourses.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/SampleCourses.ts~makeSampleCourseSlugArray",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/SampleCourses.ts",
    "importStyle": "{makeSampleCourseSlugArray}",
    "description": "Creates an array of defined course slugs.",
    "lineNumber": 43,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "num",
        "description": "the number of slugs.\nReturns an array of defined course slugs."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 295,
    "kind": "function",
    "name": "makeSampleCourseInstance",
    "memberof": "api/course/SampleCourses.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/SampleCourses.ts~makeSampleCourseInstance",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/SampleCourses.ts",
    "importStyle": "{makeSampleCourseInstance}",
    "description": "Creates a CourseInstance with a unique slug and returns its docID.\nAlso creates a new Course.",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "student",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 296,
    "kind": "function",
    "name": "getRandomGrade",
    "memberof": "api/course/SampleCourses.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/course/SampleCourses.ts~getRandomGrade",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/course/SampleCourses.ts",
    "importStyle": "{getRandomGrade}",
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 297,
    "kind": "file",
    "name": "api/course/index.ts",
    "content": "/** @namespace api/course */\n\nimport './CourseCollection';\nimport './CourseCollection.methods';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/course/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 298,
    "kind": "file",
    "name": "api/degree-plan/AcademicPlanCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { AcademicPlans } from './AcademicPlanCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('AcademicPlanCollection Meteor Methods ', function test() {\n    const collectionName = AcademicPlans.getCollectionName();\n    const definitionData = {\n      slug: 'bs-cs-2016-test',\n      degreeSlug: 'bs-cs',\n      name: 'B.S. in Computer Sciences',\n      description: 'The BS in CS degree offers a solid foundation in computer science.',\n      academicTerm: 'Fall-2016',\n      coursesPerAcademicTerm: [2, 2, 0, 2, 2, 0, 2, 2, 0, 2, 2, 0],\n      choiceList: ['ics_111-1', 'ics_141-1', 'ics_211-1', 'ics_241-1', 'ics_311-1', 'ics_314-1', 'ics_212-1',\n        'ics_321-1', 'ics_312,ics_331-1', 'ics_313,ics_361-1', 'ics_332-1', 'ics_400+-1', 'ics_400+-2', 'ics_400+-3',\n        'ics_400+-4', 'ics_400+-5'],\n      groups: {\n        ics_111: {\n          name: 'ICS 111',\n          courseSlugs: ['ics_111'],\n        },\n        ics_141: {\n          name: 'ICS 141',\n          courseSlugs: ['ics_141'],\n        },\n        ics_211: {\n          name: 'ICS 211',\n          courseSlugs: ['ics_211'],\n        },\n        ics_241: {\n          name: 'ICS 241',\n          courseSlugs: ['ics_241'],\n        },\n        ics_212: {\n          name: 'ICS 212',\n          courseSlugs: ['ics_212'],\n        },\n        ics_311: {\n          name: 'ICS 311',\n          courseSlugs: ['ics_311'],\n        },\n        'ics_312,ics_331': {\n          name: 'ICS 312 or ICS 331',\n          courseSlugs: ['ics_312', 'ics_331'],\n        },\n        ics_321: {\n          name: 'ICS 321',\n          courseSlugs: ['ics_321'],\n        },\n        'ics_313,ics_361': {\n          name: 'ICS 313 or ICS 361',\n          courseSlugs: ['ics_313', 'ics_361'],\n        },\n        ics_314: {\n          name: 'ICS 314',\n          courseSlugs: ['ics_314'],\n        },\n        ics_332: {\n          name: 'ICS 332',\n          courseSlugs: ['ics_332'],\n        },\n        'ics_400+': {\n          name: 'ICS 400+',\n          courseSlugs: ['ics_414', 'ics_415', 'ics_419', 'ics_421', 'ics_422', 'ics_423', 'ics_424', 'ics_425',\n            'ics_426', 'ics_431', 'ics_432', 'ics_434', 'ics_435', 'ics_441', 'ics_442', 'ics_443', 'ics_451',\n            'ics_452', 'ics_455', 'ics_461', 'ics_462', 'ics_464', 'ics_465', 'ics_466', 'ics_469', 'ics_471',\n            'ics_475', 'ics_476', 'ics_481', 'ics_483', 'ics_484', 'ics_485', 'ics_491', 'ics_495', 'ics_499',\n          ],\n        },\n\n      },\n    };\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      await defineMethod.callPromise({ collectionName, definitionData });\n    });\n\n    it('Update Method', async function () {\n      const id = AcademicPlans.findIdBySlug(definitionData.slug);\n      const degreeSlug = 'ba-ics';\n      const name = 'updated AcademicPlan name';\n      const academicTerm = 'Spring-2017';\n      const coursesPerAcademicTerm = [5, 5, 5, 5, 2, 0, 2, 2, 0, 2, 2, 0];\n      await updateMethod.callPromise({\n        collectionName,\n        updateData: { id, degreeSlug, name, academicTerm, coursesPerAcademicTerm },\n      });\n    });\n\n    it('Remove Method', async function () {\n      await removeItMethod.callPromise({ collectionName, instance: definitionData.slug });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/AcademicPlanCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 299,
    "kind": "file",
    "name": "api/degree-plan/AcademicPlanCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport moment from 'moment';\nimport fc from 'fast-check';\nimport 'mocha';\nimport { DesiredDegrees } from './DesiredDegreeCollection';\nimport { AcademicPlans } from './AcademicPlanCollection';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { makeSampleAcademicPlan, makeSampleChoiceList, makeSampleCoursesPerTerm } from './SampleAcademicPlans';\nimport { makeSampleAcademicTerm } from '../academic-term/SampleAcademicTerms';\nimport { IAcademicPlan } from '../../typings/radgrad';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('AcademicPlanCollection', function testSuite() {\n    const name = 'Bachelors in Computer Science';\n    const shortName = 'B.S. CS';\n    const degreeSlug = 'bs-cs';\n    const description = 'B.S. in CS.';\n    const academicTerm = 'Spring-2017';\n    const slug = 'bs-cs-2017';\n    const coursesPerAcademicTerm = [2, 2, 0, 2, 2, 0, 2, 2, 0, 2, 2, 0];\n    const choiceList = [\n      'ics_111-1',\n      'ics_141-1',\n      'ics_211-1',\n      'ics_241-1',\n      'ics_311-1',\n      'ics_314-1',\n      'ics_212-1',\n      'ics_321-1',\n      'ics_312,ics_331-1',\n      'ics_313,ics_361-1',\n      'ics_332-1',\n      'ics_400+-1',\n      'ics_400+-2',\n      'ics_400+-3',\n      'ics_400+-4',\n      'ics_400+-5',\n    ];\n    const badCourseList = [\n      'ics_111-1',\n      'ics_141-1',\n      'ics_211-1',\n      'ics_241-1',\n      'ics_311-1',\n      'ics_314-1',\n      'ics_212-1',\n      'ics_321-1',\n      'ics_312,ics_331-1',\n      'ics_313,ics_361-1',\n      'ics_332-1',\n      'ics_400+-1',\n      'ics_400+-2',\n      'ics_400+-3',\n      'ics_400+-4',\n    ];\n\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(15000);\n      fc.assert(\n        fc.property(fc.integer(1, 3), fc.integer(2018, 2025), fc.lorem(1), fc.lorem(5), fc.lorem(), fc.lorem(5), fc.lorem(12), (termNameInt, termYear, fcDegreeSlug, fcDegreeName, fcPlanSlug, fcName, fcDescription) => {\n          const dSlug = `degree-${moment().format('YYYY-MM-DD-HH-mm-ss-SSSSS')}`;\n          const pSlug = `plan-${moment().format('YYYY-MM-DD-HH-mm-ss-SSSSS')}`;\n          let term;\n          switch (termNameInt) {\n            case 1:\n              term = AcademicTerms.FALL;\n              break;\n            case 2:\n              term = AcademicTerms.SPRING;\n              break;\n            default:\n              term = AcademicTerms.SUMMER;\n          }\n          const academicTermSlug = `${term}-${termYear}`;\n          const termID = AcademicTerms.define({ term, year: termYear });\n          const degreeID = DesiredDegrees.define({\n            name: fcDegreeName,\n            shortName: fcName,\n            slug: dSlug,\n            description: fcDescription,\n          });\n          const docID = AcademicPlans.define({\n            slug: pSlug,\n            name: fcName,\n            description: fcDescription,\n            degreeSlug: dSlug,\n            academicTerm: academicTermSlug,\n            choiceList,\n            coursesPerAcademicTerm,\n          });\n          expect(AcademicPlans.isDefined(docID)).to.be.true;\n          AcademicPlans.removeIt(docID);\n          expect(AcademicPlans.isDefined(docID)).to.be.false;\n          AcademicTerms.removeIt(termID);\n          DesiredDegrees.removeIt(degreeID);\n        }),\n      );\n      done();\n    });\n\n    it('Can define duplicates', function test2() {\n      const termID = AcademicTerms.define({ term: 'Spring', year: 2017 });\n      const degreeID = DesiredDegrees.define({ name, shortName, slug: degreeSlug, description });\n      const docID1 = AcademicPlans.define({\n        slug,\n        degreeSlug,\n        name: description,\n        description,\n        academicTerm,\n        coursesPerAcademicTerm,\n        choiceList,\n      });\n      const docID2 = AcademicPlans.define({\n        slug,\n        degreeSlug,\n        name: description,\n        description,\n        academicTerm,\n        coursesPerAcademicTerm,\n        choiceList,\n      });\n      expect(docID1).to.equal(docID2);\n      expect(AcademicPlans.isDefined(docID1)).to.be.true;\n      // clean up\n      AcademicPlans.removeIt(docID2);\n      AcademicTerms.removeIt(termID);\n      DesiredDegrees.removeIt(degreeID);\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      const docID = makeSampleAcademicPlan();\n      // { degreeSlug, name, academicTerm, coursesPerAcademicTerm, choiceList, retired }\n      fc.assert(\n        fc.property(fc.lorem(), fc.boolean(), (fcName, fcRetired) => {\n          const coursesPerAcademicTerm2 = makeSampleCoursesPerTerm();\n          const choiceList2 = makeSampleChoiceList(coursesPerAcademicTerm);\n          const academicTerm2 = makeSampleAcademicTerm();\n          AcademicPlans.update(docID, {\n            name: fcName,\n            academicTerm: academicTerm2,\n            coursesPerAcademicTerm: coursesPerAcademicTerm2,\n            choiceList: choiceList2,\n            retired: fcRetired,\n          });\n          const doc = AcademicPlans.findDoc(docID);\n          // console.log(doc, coursePerAcademicTerm);\n          expect(doc.name).to.equal(fcName);\n          expect(doc.coursesPerAcademicTerm).to.have.ordered.members(coursesPerAcademicTerm2);\n        }),\n      );\n      AcademicPlans.removeIt(docID);\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      let docID = makeSampleAcademicPlan();\n      expect(AcademicPlans.isDefined(docID)).to.be.true;\n      const origPlan: IAcademicPlan = AcademicPlans.findDoc(docID);\n      const dumpObject = AcademicPlans.dumpOne(docID);\n      AcademicPlans.removeIt(docID);\n      expect(AcademicPlans.isDefined(docID)).to.be.false;\n      docID = AcademicPlans.restoreOne(dumpObject);\n      const doc: IAcademicPlan = AcademicPlans.findDoc(docID);\n      expect(origPlan.name).to.equal(doc.name);\n      expect(origPlan.degreeID).to.equal(doc.degreeID);\n      expect(origPlan.description).to.equal(doc.description);\n      expect(origPlan.academicTermNumber).to.equal(doc.academicTermNumber);\n      expect(origPlan.coursesPerAcademicTerm).to.have.ordered.members(doc.coursesPerAcademicTerm);\n      expect(origPlan.choiceList).to.have.ordered.members(doc.choiceList);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      // Act\n      const errors = AcademicPlans.checkIntegrity();\n      // console.log(errors);\n      // Assert\n      expect(errors.length).to.equal(0);\n    });\n\n    it('Can get latest plans', function test6() {\n      const plans = AcademicPlans.getLatestPlans();\n      expect(plans).to.have.lengthOf(1);\n    });\n\n    it('Can checkIntegrity errors', function test7() {\n      // Arrange\n      const doc = AcademicPlans.findOne({});\n      const docID = doc._id;\n      AcademicPlans.update(docID, { choiceList: badCourseList });\n      const errors = AcademicPlans.checkIntegrity();\n      // console.log(errors);\n      expect(errors).to.have.lengthOf(1);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/AcademicPlanCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 300,
    "kind": "file",
    "name": "api/degree-plan/AcademicPlanCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport SimpleSchema from 'simpl-schema';\nimport BaseSlugCollection from '../base/BaseSlugCollection';\nimport { DesiredDegrees } from './DesiredDegreeCollection';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { Slugs } from '../slug/SlugCollection';\nimport { IAcademicPlanDefine, IAcademicPlanUpdate } from '../../typings/radgrad';\nimport { FavoriteAcademicPlans } from '../favorite/FavoriteAcademicPlanCollection';\nimport { RadGradProperties } from '../radgrad/RadGradProperties';\nimport { stripCounter } from './PlanChoiceUtilities';\nimport { PlanChoices } from './PlanChoiceCollection';\n\n/**\n * AcademicPlans holds the different academic plans possible in this department.\n * @extends api/base.BaseSlugCollection\n * @memberOf api/degree-plan\n */\nclass AcademicPlanCollection extends BaseSlugCollection {\n\n  /**\n   * Creates the AcademicPlan collection.\n   */\n  constructor() {\n    super('AcademicPlan', new SimpleSchema({\n      name: { type: String },\n      description: String,\n      slugID: SimpleSchema.RegEx.Id,\n      degreeID: SimpleSchema.RegEx.Id,\n      effectiveAcademicTermID: SimpleSchema.RegEx.Id,\n      termNumber: Number,\n      year: Number,\n      // CAM: maxCount of 20 is for quarter system bachelors and masters.\n      //      minCount of 6 for 2 year plan\n      coursesPerAcademicTerm: { type: Array, minCount: 6, maxCount: 20 },\n      'coursesPerAcademicTerm.$': Number,\n      choiceList: { type: Array },\n      'choiceList.$': { type: String },\n      retired: { type: Boolean, optional: true },\n    }));\n    if (Meteor.isServer) {\n      this.collection._ensureIndex({ _id: 1, degreeID: 1, effectiveAcademicTermID: 1 });\n    }\n    this.defineSchema = new SimpleSchema({\n      slug: String,\n      degreeSlug: String,\n      name: String,\n      description: String,\n      academicTerm: String,\n      coursesPerAcademicTerm: [Number],\n      choiceList: { type: Array },\n      'choiceList.$': { type: String },\n    });\n    this.updateSchema = new SimpleSchema({\n      degreeSlug: { type: String, optional: true },\n      name: { type: String, optional: true },\n      academicTerm: { type: String, optional: true },\n      coursesPerAcademicTerm: { type: Array, optional: true },\n      'coursesPerAcademicTerm.$': { type: Number },\n      choiceList: { type: Array, optional: true },\n      'choiceList.$': { type: String },\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines an AcademicPlan.\n   * @example\n   *     AcademicPlans.define({\n   *                        slug: 'bs-cs-2016',\n   *                        degreeSlug: 'bs-cs',\n   *                        name: 'B.S. in Computer Science',\n   *                        description: 'The BS in CS degree offers a solid foundation in computer science.',\n   *                        academicTerm: 'Spring-2016',\n   *                        coursesPerAcademicTerm: [2, 2, 0, 2, 2, 0, 2, 2, 0, 2, 2, 0],\n   *                        choiceList: ['ics_111-1', 'ics_141-1, 'ics_211-1', 'ics_241-1', 'ics_311-1', 'ics_314-1',\n   *                                     'ics_212-1', 'ics_321-1', 'ics_313,ics_361-1', 'ics_312,ics_331-1', 'ics_332-1',\n   *                                     'ics_400+-1', 'ics_400+-2', 'ics_400+-3', 'ics_400+-4', 'ics_400+-5'] })\n   * @param slug The slug for the academic plan.\n   * @param degreeSlug The slug for the desired degree.\n   * @param name The name of the academic plan.\n   * @param description The description of the academic plan.\n   * @param academicTerm the slug for the academicTerm.\n   * @param coursesPerAcademicTerm an array of the number of courses to take in each academicTerm.\n   * @param choiceList an array of PlanChoices. The choices for each course.\n   * @param retired boolean optional defaults to false.\n   * @returns {*}\n   */\n  public define({ slug, degreeSlug, name, description, academicTerm, coursesPerAcademicTerm, choiceList, retired = false }: IAcademicPlanDefine) {\n    const degreeID = Slugs.getEntityID(degreeSlug, 'DesiredDegree');\n    const effectiveAcademicTermID = AcademicTerms.getID(academicTerm);\n    const doc = this.collection.findOne({ degreeID, name, effectiveAcademicTermID });\n    if (doc) {\n      return doc._id;\n    }\n    // Get SlugID, throw error if found.\n    const slugID = Slugs.define({ name: slug, entityName: this.getType() });\n    const academicTermDoc = AcademicTerms.findDoc(effectiveAcademicTermID);\n    const termNumber = academicTermDoc.termNumber;\n    const year = academicTermDoc.year;\n    // CAM should we ensure all the choices are defined?\n    _.forEach(choiceList, (choice) => {\n      const stripped = stripCounter(choice);\n      if (!PlanChoices.isDefined(stripped)) {\n        // console.log(`defining PlanChoice ${stripped}`);\n        PlanChoices.define({ choice: stripped });\n      }\n    });\n    const planID = this.collection.insert({\n      slugID,\n      degreeID,\n      name,\n      description,\n      effectiveAcademicTermID,\n      termNumber,\n      year,\n      coursesPerAcademicTerm,\n      choiceList,\n      retired,\n    });\n    // Connect the Slug to this AcademicPlan.\n    Slugs.updateEntityID(slugID, planID);\n    return planID;\n  }\n\n  /**\n   * Updates the AcademicPlan, instance.\n   * @param instance the docID or slug associated with this AcademicPlan.\n   * @param degreeSlug the slug for the DesiredDegree that this plan satisfies.\n   * @param name the name of this AcademicPlan.\n   * @param academicTerm the first academicTerm this plan is effective.\n   * @param coursesPerAcademicTerm an array of the number of courses per academicTerm.\n   * @param choiceList an array of PlanChoices, the choices for each course.\n   * @param retired boolean, optional.\n   */\n  public update(instance, { degreeSlug, name, academicTerm, coursesPerAcademicTerm, choiceList, retired }: IAcademicPlanUpdate) {\n    const docID = this.getID(instance);\n    const updateData: { degreeID?: string; name?: string; effectiveAcademicTermID?: string; coursesPerAcademicTerm?: number[]; choiceList?: string[]; retired?: boolean; } = {};\n    if (degreeSlug) {\n      updateData.degreeID = DesiredDegrees.getID(degreeSlug);\n    }\n    if (name) {\n      updateData.name = name;\n    }\n    if (academicTerm) {\n      updateData.effectiveAcademicTermID = AcademicTerms.getID(academicTerm);\n    }\n    if (coursesPerAcademicTerm) {\n      if (!Array.isArray(coursesPerAcademicTerm)) {\n        throw new Meteor.Error(`CoursesPerAcademicTerm ${coursesPerAcademicTerm} is not an Array.`);\n      }\n      _.forEach(coursesPerAcademicTerm, (cps) => {\n        if (!_.isNumber(cps)) {\n          throw new Meteor.Error(`CoursePerAcademicTerm ${cps} is not a Number.`);\n        }\n      });\n      updateData.coursesPerAcademicTerm = coursesPerAcademicTerm;\n    }\n    if (choiceList) {\n      if (!Array.isArray(choiceList)) {\n        throw new Meteor.Error(`CourseList ${choiceList} is not an Array.`);\n      }\n      _.forEach(choiceList, (pc) => {\n        if (!_.isString(pc)) {\n          throw new Meteor.Error(`CourseList ${pc} is not a PlanChoice.`);\n        }\n      });\n      updateData.choiceList = choiceList;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    // console.log('AcademicPlans.update', updateData);\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the AcademicPlan.\n   * @param instance The docID or slug of the entity to be removed.\n   * @throws { Meteor.Error } If docID is not an AcademicPlan, or if this plan is referenced by a User.\n   */\n  public removeIt(instance: string) {\n    const academicPlanID = this.getID(instance);\n    // Check that no student is using this AcademicPlan.\n    const favPlans = FavoriteAcademicPlans.find({ academicPlanID }).fetch();\n    const isReferenced = favPlans.length > 0;\n    if (isReferenced) {\n      throw new Meteor.Error(`AcademicPlan ${instance} is referenced.`);\n    }\n    return super.removeIt(academicPlanID);\n  }\n\n  /**\n   * Returns an array of problems. Checks the termID and DesiredDegree ID.\n   * @returns {Array} An array of problem messages.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (!Slugs.isDefined(doc.slugID)) {\n        problems.push(`Bad slugID: ${doc.slugID}.`);\n      }\n      if (!AcademicTerms.isDefined(doc.effectiveAcademicTermID)) {\n        problems.push(`Bad termID: ${doc.effectiveAcademicTermID}.`);\n      }\n      if (!DesiredDegrees.isDefined(doc.degreeID)) {\n        problems.push(`Bad desiredDegreeID: ${doc.degreeID}.`);\n      }\n      let numCourses = 0;\n      _.forEach(doc.coursesPerAcademicTerm, (n) => {\n        numCourses += n;\n      });\n      if (doc.choiceList.length !== numCourses) {\n        problems.push(`Mismatch between choiceList.length ${doc.choiceList.length} and sum of coursesPerAcademicTerm ${numCourses}.`);\n      }\n      _.forEach(doc.choiceList, (choice) => {\n        const stripped = stripCounter(choice);\n        if (!PlanChoices.findDoc({ choice: stripped })) {\n          problems.push(`${stripped} is not a defined PlanChoice.`);\n        }\n      });\n    });\n    return problems;\n  }\n\n  /**\n   * Returns the AcademicPlans that are effective on or after termNumber for the given DesiredDegree.\n   * @param degree the desired degree either a slug or id.\n   * @param academicTermNumber (optional) the academicTerm number. if undefined returns the latest AcademicPlans.\n   * @return {any}\n   */\n  public getPlansForDegree(degree: string, academicTermNumber?: number) {\n    const degreeID = DesiredDegrees.getID(degree);\n    if (!academicTermNumber) {\n      return this.collection.find({ degreeID, termNumber: this.getLatestAcademicTermNumber() }).fetch();\n    }\n    return this.collection.find({ degreeID, termNumber: { $gte: academicTermNumber } }).fetch();\n  }\n\n  /**\n   * Returns an array of the latest AcademicPlans.\n   * @return {array}\n   */\n  public getLatestPlans() {\n    const termNumber = this.getLatestAcademicTermNumber();\n    return this.collection.find({ termNumber }).fetch();\n  }\n\n  /**\n   * Returns the largest academicTerm number.\n   * @return {number}\n   */\n  public getLatestAcademicTermNumber() {\n    const plans = this.collection.find({}, { sort: { termNumber: 1 } }).fetch();\n    const currentTerm = AcademicTerms.getCurrentAcademicTermDoc();\n    let max = 0;\n    let latest = 0;\n    _.forEach(plans, (p) => {\n      if (max < p.termNumber) {\n        max = p.termNumber;\n      }\n      if (p.termNumber <= currentTerm.termNumber && latest < p.termNumber) {\n        latest = p.termNumber;\n      }\n    });\n    if (latest !== 0) {\n      return latest;\n    }\n    return max;\n  }\n\n  /**\n   * Returns an array of years that have AcademicPlans.\n   * @returns {number[]} an array of the years that have AcademicPlans.\n   */\n  public getPlanYears() {\n    const plans = this.collection.find({}).fetch();\n    return _.uniq(_.map(plans, (p) => p.year));\n  }\n\n  /**\n   * Returns the plan name and year for the given plan id.\n   * @param planID the id of the academic plan.\n   * @return {string}\n   */\n  public toFullString(planID: string) {\n    const plan = this.findDoc(planID);\n    const academicTerm = AcademicTerms.findDoc(plan.effectiveAcademicTermID);\n    return `${plan.name} (${academicTerm.year})`;\n  }\n\n  /**\n   * Returns true if the give academic plan includes graduate classes.\n   * @param {string} planID the id of the academic plan.\n   * @returns {boolean}\n   */\n  public isGraduatePlan(planID: string): boolean {\n    const plan = this.findDoc(planID);\n    // console.log('isGraduatePlan', planID, plan.coursesPerAcademicTerm, plan.coursesPerAcademicTerm.length >= 15);\n    return RadGradProperties.getQuarterSystem() ? plan.coursesPerAcademicTerm > 16 : plan.coursesPerAcademicTerm.length > 12;\n  }\n\n  /**\n   * Returns an object representing the AcademicPlan docID in a format acceptable to define().\n   * @param docID The docID of a HelpMessage.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IAcademicPlanDefine {\n    const doc = this.findDoc(docID);\n    const slug = Slugs.getNameFromID(doc.slugID);\n    const degree = DesiredDegrees.findDoc(doc.degreeID);\n    const degreeSlug = Slugs.findDoc(degree.slugID).name;\n    const name = doc.name;\n    const description = doc.description;\n    const academicTermDoc = AcademicTerms.findDoc(doc.effectiveAcademicTermID);\n    const academicTerm = Slugs.findDoc(academicTermDoc.slugID).name;\n    const coursesPerAcademicTerm = doc.coursesPerAcademicTerm;\n    const choiceList = doc.choiceList;\n    const retired = doc.retired;\n    return { slug, degreeSlug, name, description, academicTerm, coursesPerAcademicTerm, choiceList, retired };\n  }\n\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @memberOf api/degree-plan\n */\nexport const AcademicPlans = new AcademicPlanCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/AcademicPlanCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 301,
    "kind": "variable",
    "name": "AcademicPlans",
    "memberof": "api/degree-plan/AcademicPlanCollection.ts",
    "static": true,
    "longname": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlans",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanCollection.ts",
    "importStyle": "{AcademicPlans}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 327,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/degree-plan"
      }
    ],
    "type": {
      "types": [
        "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection"
      ]
    }
  },
  {
    "__docId__": 302,
    "kind": "class",
    "name": "AcademicPlanCollection",
    "memberof": "api/degree-plan/AcademicPlanCollection.ts",
    "static": true,
    "longname": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanCollection.ts",
    "importStyle": null,
    "description": "AcademicPlans holds the different academic plans possible in this department.",
    "lineNumber": 19,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseSlugCollection.js~BaseSlugCollection"
    ]
  },
  {
    "__docId__": 303,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection#constructor",
    "access": "public",
    "description": "Creates the AcademicPlan collection.",
    "lineNumber": 22
  },
  {
    "__docId__": 304,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection",
    "static": false,
    "longname": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 305,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection",
    "static": false,
    "longname": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 306,
    "kind": "method",
    "name": "define",
    "memberof": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection#define",
    "access": "public",
    "description": "Defines an AcademicPlan.",
    "lineNumber": 89,
    "params": [
      {
        "nullable": null,
        "types": [
          "IAcademicPlanDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 307,
    "kind": "method",
    "name": "update",
    "memberof": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection#update",
    "access": "public",
    "description": "Updates the AcademicPlan, instance.",
    "lineNumber": 136,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IAcademicPlanUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 308,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection#removeIt",
    "access": "public",
    "description": "Remove the AcademicPlan.",
    "lineNumber": 182,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 309,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of problems. Checks the termID and DesiredDegree ID.",
    "lineNumber": 197,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 310,
    "kind": "method",
    "name": "getPlansForDegree",
    "memberof": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection#getPlansForDegree",
    "access": "public",
    "description": "Returns the AcademicPlans that are effective on or after termNumber for the given DesiredDegree.",
    "lineNumber": 232,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "degree",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "academicTermNumber",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 311,
    "kind": "method",
    "name": "getLatestPlans",
    "memberof": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection#getLatestPlans",
    "access": "public",
    "description": "Returns an array of the latest AcademicPlans.",
    "lineNumber": 244,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 312,
    "kind": "method",
    "name": "getLatestAcademicTermNumber",
    "memberof": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection#getLatestAcademicTermNumber",
    "access": "public",
    "description": "Returns the largest academicTerm number.",
    "lineNumber": 253,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 313,
    "kind": "method",
    "name": "getPlanYears",
    "memberof": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection#getPlanYears",
    "access": "public",
    "description": "Returns an array of years that have AcademicPlans.",
    "lineNumber": 276,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 314,
    "kind": "method",
    "name": "toFullString",
    "memberof": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection#toFullString",
    "access": "public",
    "description": "Returns the plan name and year for the given plan id.",
    "lineNumber": 286,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "planID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "method",
    "name": "isGraduatePlan",
    "memberof": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection#isGraduatePlan",
    "access": "public",
    "description": "Returns true if the give academic plan includes graduate classes.",
    "lineNumber": 297,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "planID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 316,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicPlanCollection.ts~AcademicPlanCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the AcademicPlan docID in a format acceptable to define().",
    "lineNumber": 308,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IAcademicPlanDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 317,
    "kind": "file",
    "name": "api/degree-plan/AcademicPlanUtilities.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { Random } from 'meteor/random';\nimport { expect } from 'chai';\nimport * as AcademicPlanUtilities from './AcademicPlanUtilities';\nimport { RadGradProperties } from '../radgrad/RadGradProperties';\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('AcademicPlanUtilities', function testSuite() {\n    const _id = Random.id();\n    const name = 'good';\n    const description = 'description';\n    const choiceList = [];\n    const coursesPerAcademicTerm = [];\n    const shortList = [];\n    const shortCourses = [];\n    const year = 2019;\n    let goodPlan;\n    let badPlan;\n    before(function setup() {\n      const quarters = RadGradProperties.getQuarterSystem();\n      if (quarters) {\n        choiceList.push('ics_111-1');\n        choiceList.push('ics_141-1');\n        choiceList.push('ics_211-1');\n        choiceList.push('ics_241-1');\n        coursesPerAcademicTerm.push(1);\n        coursesPerAcademicTerm.push(1);\n        coursesPerAcademicTerm.push(1);\n        coursesPerAcademicTerm.push(1);\n        shortList.push('ics_111-1');\n        shortList.push('ics_211-1');\n        shortList.push('ics_311-1');\n        shortCourses.push(2);\n        shortCourses.push(2);\n        shortCourses.push(0);\n      } else {\n        choiceList.push('ics_111-1');\n        choiceList.push('ics_141-1');\n        choiceList.push('ics_211-1');\n        choiceList.push('ics_241-1');\n        coursesPerAcademicTerm.push(2);\n        coursesPerAcademicTerm.push(2);\n        coursesPerAcademicTerm.push(0);\n        shortList.push('ics_111-1');\n        shortList.push('ics_211-1');\n        shortList.push('ics_311-1');\n        shortCourses.push(1);\n        shortCourses.push(2);\n      }\n      goodPlan = {\n        _id,\n        name,\n        description,\n        degreeID: Random.id(),\n        slugID: Random.id(),\n        choiceList,\n        coursesPerAcademicTerm,\n        effectiveAcademicTermID: Random.id(),\n        year,\n        academicTermNumber: 3,\n      };\n      badPlan = {\n        _id,\n        name,\n        description,\n        degreeID: Random.id(),\n        slugID: Random.id(),\n        choiceList: shortList,\n        coursesPerAcademicTerm: shortCourses,\n        effectiveAcademicTermID: Random.id(),\n        year,\n        academicTermNumber: 3,\n      };\n    });\n\n    it('getPlanChoices', function () {\n      const quarters = RadGradProperties.getQuarterSystem();\n      const courses = AcademicPlanUtilities.getPlanChoices(goodPlan, 1);\n      if (quarters) {\n        expect(courses.length).to.equal(1);\n        expect(courses[0]).to.equal('ics_141-1');\n      } else {\n        expect(courses.length).to.equal(2);\n        expect(courses[0]).to.equal('ics_211-1');\n      }\n    });\n\n    it('isAcademicPlanValid', function () {\n      expect(AcademicPlanUtilities.isAcademicPlanValid(goodPlan)).to.be.true;\n      expect(AcademicPlanUtilities.isAcademicPlanValid(badPlan)).to.be.false;\n    });\n\n    it('addChoiceToPlan', function () {\n      // console.log('before %o', badPlan);\n      AcademicPlanUtilities.addChoiceToPlan(badPlan, 2, 'ics_314');\n      // console.log('after %o', badPlan);\n      expect(AcademicPlanUtilities.isAcademicPlanValid(badPlan)).to.be.true;\n      AcademicPlanUtilities.addChoiceToPlan(goodPlan, 1, 'ics_314');\n      expect(AcademicPlanUtilities.isAcademicPlanValid(goodPlan)).to.be.true;\n      // console.log('updated good %o', goodPlan);\n    });\n\n    it('addDuplicateChoice', function () {\n      AcademicPlanUtilities.addChoiceToPlan(badPlan, 0, 'ics_314');\n      // console.log('after duplicate %o', badPlan);\n      expect(AcademicPlanUtilities.isAcademicPlanValid(badPlan)).to.be.true;\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/AcademicPlanUtilities.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 318,
    "kind": "file",
    "name": "api/degree-plan/AcademicPlanUtilities.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport { IAcademicPlan, ICourseInstance } from '../../typings/radgrad';\nimport { CourseInstances } from '../course/CourseInstanceCollection';\nimport { Slugs } from '../slug/SlugCollection';\nimport { complexChoiceToArray } from './PlanChoiceUtilities';\nimport * as PlanChoiceUtils from './PlanChoiceUtilities';\nimport { RadGradProperties } from '../radgrad/RadGradProperties';\n\nexport function getPlanChoicesRaw(coursesPerTerm: number[], choiceList: string[], termNum: number) {\n  if (termNum < 0 || termNum > coursesPerTerm.length - 1) {\n    throw new Meteor.Error(`Bad termNum ${termNum}`);\n  }\n  let numChoices = 0;\n  for (let i = 0; i < termNum; i++) {\n    numChoices += coursesPerTerm[i];\n  }\n  const numTermChoices = coursesPerTerm[termNum];\n  // console.log(academicPlan.coursesPerAcademicTerm, termNum, numTermChoices, academicPlan.choiceList.slice(numChoices, numChoices + numTermChoices));\n  return choiceList.slice(numChoices, numChoices + numTermChoices);\n}\n\nexport function getPlanChoices(academicPlan: IAcademicPlan, termNum: number): string[] {\n  return getPlanChoicesRaw(academicPlan.coursesPerAcademicTerm, academicPlan.choiceList, termNum);\n}\n\nexport function passedCourse(ci: ICourseInstance): boolean {\n  const courseDoc = CourseInstances.getCourseDoc(ci._id);\n  const courseSlug = Slugs.getNameFromID(courseDoc.slugID);\n  // TODO: We need another way of representing 'passing'\n  if (courseSlug.includes('111') || courseSlug.includes('141') || courseSlug.includes('211') || courseSlug.includes('241')) {\n    return _.includes(['B', 'B+', 'A-', 'A', 'A+'], ci.grade);\n  }\n  return _.includes(['C', 'C+', 'B-', 'B', 'B+', 'A-', 'A', 'A+'], ci.grade);\n}\n\nexport function isPlanChoiceSatisfied(planChoice: string, takenSlugs: string[]): boolean {\n  const planCount = PlanChoiceUtils.getPlanCount(planChoice);\n  const planSlug = PlanChoiceUtils.stripCounter(planChoice);\n  const courseSlugs = complexChoiceToArray(planSlug);\n  let count = 0;\n  _.forEach(takenSlugs, (slug) => {\n    _.forEach(courseSlugs, (cSlug) => {\n     if (PlanChoiceUtils.satisfiesPlanChoice(cSlug, slug)) {\n        count++;\n      }\n    });\n  });\n  const ret = count >= planCount;\n  // console.log('isPlanChoiceSatisfied(%s, %o) returns %o', planChoice, takenSlugs, ret);\n  return ret;\n}\n\nexport function isAcademicPlanValid(academicPlan: IAcademicPlan): boolean {\n  const quarters = RadGradProperties.getQuarterSystem();\n  // check the coursesPerAcademicTerm length\n  if (quarters) {\n    if (academicPlan.coursesPerAcademicTerm.length % 4 !== 0) {\n      return false;\n    }\n  } else if (academicPlan.coursesPerAcademicTerm.length % 3 !== 0) {\n    return false;\n  }\n  // check the choiceList length to the sum of the coursesPerTerm\n  const numCourses = _.reduce(academicPlan.coursesPerAcademicTerm, (sum, n) => sum + n, 0);\n  if (numCourses !== academicPlan.choiceList.length) {\n    return false;\n  }\n  // check the choiceList to see if has numbers.\n  if (!_.each(academicPlan.choiceList, (choice) => PlanChoiceUtils.getPlanCount(choice) !== 0)) {\n    return false;\n  }\n  // check to see if choiceList numbers are correct.\n  return true;\n}\n\nexport function getCourseListIndex(coursesPerAcademicTerm: number[], termNum: number, termIndex?: number) {\n  // console.log(coursesPerAcademicTerm, termNum, termIndex);\n  let index = 0;\n  let i = 0;\n  for (i = 0; i < termNum; i++) {\n    index += coursesPerAcademicTerm[i];\n  }\n  if (termIndex) {\n    index += termIndex;\n  }\n  // if (coursesPerAcademicTerm[i]) {\n  //   index += coursesPerAcademicTerm[i];\n  // }\n  return index;\n}\n\nexport function updateChoiceCounts(choiceList: string[]) {\n  // create a map to count the choices\n  const choiceCounts = {};\n  // loop over each of the items in choiceList\n  let i = 0;\n  for (i = 0; i < choiceList.length; i++) {\n    const choice = choiceList[i];\n    // strip off the counter and check the choice in the map\n    const noCount = PlanChoiceUtils.stripCounter(choice);\n    if (choiceCounts[noCount]) {\n      // update the choiceList[i]\n      const seen = choiceCounts[noCount] + 1;\n      choiceList[i] = `${noCount}-${seen}`; // eslint-disable-line no-param-reassign\n      choiceCounts[noCount] = seen;\n    } else {\n      choiceList[i] = `${noCount}-1`; // eslint-disable-line no-param-reassign\n      choiceCounts[noCount] = 1;\n    }\n  }\n}\n\nexport function addChoiceToRaw(choice: string, termNum: number, choiceList: string[], coursesPerAcademicTerm: number[], termIndex?: number) {\n  const listIndex = getCourseListIndex(coursesPerAcademicTerm, termNum, termIndex);\n  const choiceWithNum = `${choice}-1`;\n  if (listIndex === 0) {\n    choiceList.unshift(choiceWithNum);\n  } else if (listIndex === choiceList.length) {\n    choiceList.push(choiceWithNum);\n  } else {\n    choiceList.splice(listIndex, 0, choiceWithNum);\n  }\n  if (coursesPerAcademicTerm[termNum]) {\n    coursesPerAcademicTerm[termNum] += 1; // eslint-disable-line no-param-reassign\n  } else {\n    coursesPerAcademicTerm[termNum] = 1; // eslint-disable-line no-param-reassign\n  }\n  updateChoiceCounts(choiceList);\n}\n\nexport function addChoiceToPlan(academicPlan: IAcademicPlan, termNum: number, choice: string) {\n  addChoiceToRaw(choice, termNum, academicPlan.choiceList, academicPlan.coursesPerAcademicTerm);\n}\n\nfunction getListIndex(choice: string, choiceList: string[]) {\n  const stripped = _.map(choiceList, (c) => PlanChoiceUtils.stripCounter(c));\n  return stripped.indexOf(choice);\n}\n\nexport function reorderChoicesInTermRaw(choice: string, termNumber: number, newIndex: number, choiceList: string[], coursesPerAcademicTerm: number[]) {\n  // console.log('reorder', choice, termNumber, newIndex);\n  const termChoices = getPlanChoicesRaw(coursesPerAcademicTerm, choiceList, termNumber);\n  const oldTermIndex = getListIndex(choice, termChoices);\n  const diff = newIndex - oldTermIndex;\n  if (newIndex !== oldTermIndex) {\n    const oldPosition = getListIndex(choice, choiceList);\n    const newPosition = oldPosition + diff;\n    const temp = choiceList[oldPosition];\n    choiceList[oldPosition] = choiceList[newPosition]; // eslint-disable-line no-param-reassign\n    choiceList[newPosition] = temp; // eslint-disable-line no-param-reassign\n  }\n}\n\nexport function removeChoiceFromPlanRaw(choice: string, termNumber: number, choiceList: string[], coursesPerAcademicTerm: number[]) {\n  const clIndex = getCourseListIndex(coursesPerAcademicTerm, termNumber);\n  for (let i = clIndex; i < choiceList.length; i++) {\n    if (PlanChoiceUtils.stripCounter(choiceList[i]) === choice) {\n      choiceList.splice(i, 1);\n      break;\n    }\n  }\n  coursesPerAcademicTerm[termNumber]--; // eslint-disable-line no-param-reassign\n}\n\nexport function planHasCoursesRaw(coursesPerAcademicTerm: number[], yearNum: number): boolean {\n  const quarterSystem = RadGradProperties.getQuarterSystem();\n  let start;\n  let end;\n  let courses;\n  if (quarterSystem) {\n    start = yearNum * 4;\n    end = start + 4;\n    courses = coursesPerAcademicTerm.slice(start, end);\n  } else {\n    start = yearNum * 3;\n    end = start + 3;\n    courses = coursesPerAcademicTerm.slice(start, end);\n  }\n  // console.log('planHasCoursesRaw', start, end, courses, _.some(courses));\n  return _.some(courses);\n}\n\n/**\n * Removes the year from coursesPerAcademicTerm if the coursesPerAcademicTerm are all 0.\n * @param {number[]} coursesPerAcademicTerm\n * @param {number} yearNum\n * @returns {number[]}\n */\nexport function removeYearFromPlanRaw(coursesPerAcademicTerm: number[], yearNum: number): number[] {\n  const quarterSystem = RadGradProperties.getQuarterSystem();\n  const start = quarterSystem ? yearNum * 4 : yearNum * 3;\n  const numTerms = quarterSystem ? 4 : 3;\n  if (!planHasCoursesRaw(coursesPerAcademicTerm, yearNum)) {\n    return coursesPerAcademicTerm.splice(start, numTerms);\n  }\n  return coursesPerAcademicTerm;\n}\n\n/**\n * Removes the empty years from coursesPerAcademicTerm.\n * @param {number[]} coursesPerAcademicTerm\n * @returns {number[]}\n */\nexport function removeEmptyYearsRaw(coursesPerAcademicTerm: number[]): number[] {\n  for (let i = 4; i >= 0; i--) {\n    removeYearFromPlanRaw(coursesPerAcademicTerm, i);\n  }\n  return coursesPerAcademicTerm;\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/AcademicPlanUtilities.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 319,
    "kind": "function",
    "name": "getPlanChoicesRaw",
    "memberof": "api/degree-plan/AcademicPlanUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicPlanUtilities.ts~getPlanChoicesRaw",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanUtilities.ts",
    "importStyle": "{getPlanChoicesRaw}",
    "description": "",
    "lineNumber": 10,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesPerTerm",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "choiceList",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "termNum",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 320,
    "kind": "function",
    "name": "getPlanChoices",
    "memberof": "api/degree-plan/AcademicPlanUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicPlanUtilities.ts~getPlanChoices",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanUtilities.ts",
    "importStyle": "{getPlanChoices}",
    "description": "",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "IAcademicPlan"
        ],
        "spread": false,
        "optional": false,
        "name": "academicPlan",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "termNum",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 321,
    "kind": "function",
    "name": "passedCourse",
    "memberof": "api/degree-plan/AcademicPlanUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicPlanUtilities.ts~passedCourse",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanUtilities.ts",
    "importStyle": "{passedCourse}",
    "description": "",
    "lineNumber": 27,
    "params": [
      {
        "nullable": null,
        "types": [
          "ICourseInstance"
        ],
        "spread": false,
        "optional": false,
        "name": "ci",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 322,
    "kind": "function",
    "name": "isPlanChoiceSatisfied",
    "memberof": "api/degree-plan/AcademicPlanUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicPlanUtilities.ts~isPlanChoiceSatisfied",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanUtilities.ts",
    "importStyle": "{isPlanChoiceSatisfied}",
    "description": "",
    "lineNumber": 37,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "planChoice",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "takenSlugs",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 323,
    "kind": "function",
    "name": "isAcademicPlanValid",
    "memberof": "api/degree-plan/AcademicPlanUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicPlanUtilities.ts~isAcademicPlanValid",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanUtilities.ts",
    "importStyle": "{isAcademicPlanValid}",
    "description": "",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "IAcademicPlan"
        ],
        "spread": false,
        "optional": false,
        "name": "academicPlan",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 324,
    "kind": "function",
    "name": "getCourseListIndex",
    "memberof": "api/degree-plan/AcademicPlanUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicPlanUtilities.ts~getCourseListIndex",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanUtilities.ts",
    "importStyle": "{getCourseListIndex}",
    "description": "",
    "lineNumber": 77,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesPerAcademicTerm",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "termNum",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "termIndex",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 325,
    "kind": "function",
    "name": "updateChoiceCounts",
    "memberof": "api/degree-plan/AcademicPlanUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicPlanUtilities.ts~updateChoiceCounts",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanUtilities.ts",
    "importStyle": "{updateChoiceCounts}",
    "description": "",
    "lineNumber": 93,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "choiceList",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 326,
    "kind": "function",
    "name": "addChoiceToRaw",
    "memberof": "api/degree-plan/AcademicPlanUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicPlanUtilities.ts~addChoiceToRaw",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanUtilities.ts",
    "importStyle": "{addChoiceToRaw}",
    "description": "",
    "lineNumber": 114,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "choice",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "termNum",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "choiceList",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesPerAcademicTerm",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "termIndex",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 327,
    "kind": "function",
    "name": "addChoiceToPlan",
    "memberof": "api/degree-plan/AcademicPlanUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicPlanUtilities.ts~addChoiceToPlan",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanUtilities.ts",
    "importStyle": "{addChoiceToPlan}",
    "description": "",
    "lineNumber": 132,
    "params": [
      {
        "nullable": null,
        "types": [
          "IAcademicPlan"
        ],
        "spread": false,
        "optional": false,
        "name": "academicPlan",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "termNum",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "choice",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 328,
    "kind": "function",
    "name": "getListIndex",
    "memberof": "api/degree-plan/AcademicPlanUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicPlanUtilities.ts~getListIndex",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanUtilities.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 136,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "choice",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "choiceList",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 329,
    "kind": "function",
    "name": "reorderChoicesInTermRaw",
    "memberof": "api/degree-plan/AcademicPlanUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicPlanUtilities.ts~reorderChoicesInTermRaw",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanUtilities.ts",
    "importStyle": "{reorderChoicesInTermRaw}",
    "description": "",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "choice",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "termNumber",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "newIndex",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "choiceList",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesPerAcademicTerm",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 330,
    "kind": "function",
    "name": "removeChoiceFromPlanRaw",
    "memberof": "api/degree-plan/AcademicPlanUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicPlanUtilities.ts~removeChoiceFromPlanRaw",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanUtilities.ts",
    "importStyle": "{removeChoiceFromPlanRaw}",
    "description": "",
    "lineNumber": 155,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "choice",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "termNumber",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "choiceList",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesPerAcademicTerm",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 331,
    "kind": "function",
    "name": "planHasCoursesRaw",
    "memberof": "api/degree-plan/AcademicPlanUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicPlanUtilities.ts~planHasCoursesRaw",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanUtilities.ts",
    "importStyle": "{planHasCoursesRaw}",
    "description": "",
    "lineNumber": 166,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesPerAcademicTerm",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "yearNum",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 332,
    "kind": "function",
    "name": "removeYearFromPlanRaw",
    "memberof": "api/degree-plan/AcademicPlanUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicPlanUtilities.ts~removeYearFromPlanRaw",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanUtilities.ts",
    "importStyle": "{removeYearFromPlanRaw}",
    "description": "Removes the year from coursesPerAcademicTerm if the coursesPerAcademicTerm are all 0.",
    "lineNumber": 190,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesPerAcademicTerm",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "yearNum",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 333,
    "kind": "function",
    "name": "removeEmptyYearsRaw",
    "memberof": "api/degree-plan/AcademicPlanUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicPlanUtilities.ts~removeEmptyYearsRaw",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicPlanUtilities.ts",
    "importStyle": "{removeEmptyYearsRaw}",
    "description": "Removes the empty years from coursesPerAcademicTerm.",
    "lineNumber": 205,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesPerAcademicTerm",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 334,
    "kind": "file",
    "name": "api/degree-plan/AcademicYearInstanceCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { AcademicYearInstances } from './AcademicYearInstanceCollection';\nimport { Users } from '../user/UserCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('AcademicYearInstances Meteor Methods ', function test() {\n    const collectionName = AcademicYearInstances.getCollectionName();\n    const year = 2017;\n    const student = 'abi@hawaii.edu';\n    const definitionData = { student, year };\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal', 'abi.student'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions(student);\n      await defineMethod.callPromise({ collectionName, definitionData });\n    });\n\n    it('Update Method', async function () {\n      const studentID = Users.getID(student);\n      const id = AcademicYearInstances.findDoc({ year, studentID })._id;\n      const springYear = 2018;\n      await updateMethod.callPromise({ collectionName, updateData: { id, year: springYear, retired: true } });\n    });\n\n    it('Remove Method', async function () {\n      const studentID = Users.getID(student);\n      const springYear = 2018;\n      const instance = AcademicYearInstances.findDoc({ year: springYear, studentID })._id;\n      await removeItMethod.callPromise({ collectionName, instance });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/AcademicYearInstanceCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 335,
    "kind": "file",
    "name": "api/degree-plan/AcademicYearInstanceCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport 'mocha';\nimport { AcademicYearInstances } from './AcademicYearInstanceCollection';\nimport { Users } from '../user/UserCollection';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { makeSampleAcademicTerm } from '../academic-term/SampleAcademicTerms';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { IAcademicYearInstance } from '../../typings/radgrad';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('AcademicYearInstanceCollection', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(5000);\n      const studentID = makeSampleUser();\n      const student = Users.getProfile(studentID).username;\n      fc.assert(\n        fc.property(fc.integer(2017, 2027), (fcYear) => {\n          const docID = AcademicYearInstances.define({ student, year: fcYear });\n          expect(AcademicYearInstances.isDefined(docID)).to.be.true;\n          AcademicYearInstances.removeIt(docID);\n          expect(AcademicYearInstances.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicates', function test2() {\n      const academicTerm = makeSampleAcademicTerm();\n      const year = AcademicTerms.findDoc(academicTerm).year;\n      const studentID = makeSampleUser();\n      const student = Users.getProfile(studentID).username;\n      const docID1 = AcademicYearInstances.define({ year, student });\n      const docID2 = AcademicYearInstances.define({ year, student });\n      expect(docID1).to.equal(docID2);\n      expect(AcademicYearInstances.isDefined(docID1)).to.be.true;\n      AcademicYearInstances.removeIt(docID2);\n      expect(AcademicYearInstances.isDefined(docID1)).to.be.false;\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      const academicTerm = makeSampleAcademicTerm();\n      const year = AcademicTerms.findDoc(academicTerm).year;\n      const studentID = makeSampleUser();\n      const student = Users.getProfile(studentID).username;\n      const docID = AcademicYearInstances.define({ year, student });\n      fc.assert(\n        fc.property(fc.integer(2017, 2027), fc.boolean(), (fcYear, fcRetired) => {\n          AcademicYearInstances.update(docID, { year: fcYear, retired: fcRetired });\n          const ay = AcademicYearInstances.findDoc(docID);\n          expect(ay.year).to.equal(fcYear);\n          expect(ay.springYear).to.equal(fcYear + 1);\n          expect(ay.retired).to.equal(fcRetired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      let ay = AcademicYearInstances.findOne({});\n      let docID = ay._id;\n      const dumpObject = AcademicYearInstances.dumpOne(docID);\n      AcademicYearInstances.removeIt(docID);\n      expect(AcademicYearInstances.isDefined(docID)).to.be.false;\n      docID = AcademicYearInstances.restoreOne(dumpObject);\n      ay = AcademicYearInstances.findDoc(docID);\n      expect(dumpObject.year).to.equal(ay.year);\n      const student = Users.getProfile(ay.studentID).username;\n      expect(dumpObject.student).to.equal(student);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const errors = AcademicYearInstances.checkIntegrity();\n      expect(errors).to.have.lengthOf(0);\n    });\n\n    it('Can remove user', function test6() {\n      const ay: IAcademicYearInstance = AcademicYearInstances.findOne({});\n      AcademicYearInstances.removeUser(ay.studentID);\n      expect(AcademicYearInstances.find({ studentID: ay.studentID }).count()).to.equal(0);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/AcademicYearInstanceCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 336,
    "kind": "file",
    "name": "api/degree-plan/AcademicYearInstanceCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport _ from 'lodash';\nimport moment from 'moment';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { ROLE } from '../role/Role';\nimport { Users } from '../user/UserCollection';\nimport BaseCollection from '../base/BaseCollection';\nimport { IAcademicYearInstanceDefine } from '../../typings/radgrad';\nimport { RadGradProperties } from '../radgrad/RadGradProperties';\n\n/**\n * Each AcademicYearInstance represents a sequence of three or four academic terms for a given student.\n * It is used to control the display of academic terms for a given student in the Degree Planner.\n * @extends api/base.BaseCollection\n * @memberOf api/degree-plan\n */\nclass AcademicYearInstanceCollection extends BaseCollection {\n  /**\n   * Creates the AcademicYearInstance collection.\n   */\n  constructor() {\n    super('AcademicYearInstance', new SimpleSchema({\n      year: { type: Number },\n      springYear: { type: Number },\n      studentID: { type: SimpleSchema.RegEx.Id },\n      termIDs: [SimpleSchema.RegEx.Id],\n      retired: { type: Boolean, optional: true },\n    }));\n    if (Meteor.isServer) {\n      this.collection.rawCollection().createIndex({ studentID: 1, year: 1 });\n    }\n    this.defineSchema = new SimpleSchema({\n      year: {\n        type: SimpleSchema.Integer,\n        min: moment().year() - 5,\n        max: moment().year() + 10,\n        defaultValue: moment().year(),\n      },\n      student: String,\n    });\n    // year?: number; springYear?: number; studentID?: string; termIDs?: string[];\n    this.updateSchema = new SimpleSchema({\n      year: { type: SimpleSchema.Integer, min: moment().year() - 10, max: moment().year() + 10, optional: true },\n      springYear: {\n        type: SimpleSchema.Integer,\n        min: moment().year() - 10,\n        max: moment().year() + 10,\n        optional: true,\n      },\n      studentID: { type: String, optional: true },\n      termIDs: { type: Array, optional: true },\n      'termIDs.$': String,\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines a new AcademicYearInstance.\n   * @example\n   * To define the 2016 - 2017 academic year for Joe Smith.\n   *     AcademicYearInstances.define({ year: 2016,\n   *                                    student: 'joesmith' });\n   * @param { Object } Object with keys year and student.\n   * @throws {Meteor.Error} If the definition includes an undefined student or a year that is out of bounds.\n   * @returns The newly created docID.\n   */\n  public define({ year, student }: IAcademicYearInstanceDefine) {\n    const studentID = Users.getID(student);\n    const quarterSystem = RadGradProperties.getQuarterSystem();\n    let termIDs = [];\n    // check for gaps\n    const prevYears = this.collection.find({ year: { $lt: year }, studentID }, { sort: { year: 1 } }).fetch();\n    if (prevYears.length > 0) {\n      const lastYear = prevYears[prevYears.length - 1].year;\n      for (let y = lastYear + 1; y < year; y++) {\n        if (this.collection.find({ year: y, studentID }).fetch().length === 0) {\n          termIDs = [];\n          termIDs.push(AcademicTerms.getID(`${AcademicTerms.FALL}-${y}`));\n          if (quarterSystem) {\n            termIDs.push(AcademicTerms.getID(`${AcademicTerms.WINTER}-${y + 1}`));\n          }\n          termIDs.push(AcademicTerms.getID(`${AcademicTerms.SPRING}-${y + 1}`));\n          termIDs.push(AcademicTerms.getID(`${AcademicTerms.SUMMER}-${y + 1}`));\n          this.collection.insert({ year: y, springYear: y + 1, studentID, termIDs });\n        }\n      }\n    }\n    const nextYears = this.collection.find({ year: { $gt: year }, studentID }, { sort: { year: 1 } }).fetch();\n    if (nextYears.length > 0) {\n      const nextYear = nextYears[0].year;\n      for (let y = year + 1; y < nextYear; y++) {\n        if (this.collection.find({ year: y, studentID }).fetch().length === 0) {\n          termIDs = [];\n          termIDs.push(AcademicTerms.getID(`${AcademicTerms.FALL}-${y}`));\n          if (quarterSystem) {\n            termIDs.push(AcademicTerms.getID(`${AcademicTerms.WINTER}-${y + 1}`));\n          }\n          termIDs.push(AcademicTerms.getID(`${AcademicTerms.SPRING}-${y + 1}`));\n          termIDs.push(AcademicTerms.getID(`${AcademicTerms.SUMMER}-${y + 1}`));\n          this.collection.insert({ year: y, springYear: y + 1, studentID, termIDs });\n        }\n      }\n    }\n    const doc = this.collection.find({ year, studentID }).fetch();\n    if (doc.length > 0) {\n      return doc[0]._id;\n    }\n    termIDs = [];\n    termIDs.push(AcademicTerms.getID(`${AcademicTerms.FALL}-${year}`));\n    if (quarterSystem) {\n      termIDs.push(AcademicTerms.getID(`${AcademicTerms.WINTER}-${year + 1}`));\n    }\n    termIDs.push(AcademicTerms.getID(`${AcademicTerms.SPRING}-${year + 1}`));\n    termIDs.push(AcademicTerms.getID(`${AcademicTerms.SUMMER}-${year + 1}`));\n\n    // Define and return the docID\n    return this.collection.insert({ year, springYear: year + 1, studentID, termIDs });\n  }\n\n  /**\n   * Update an AcademicYear.\n   * @param docID The docID associated with this academic year.\n   * @param year the fall year.\n   * @param springYear the spring year\n   * @param studentID the student's ID.\n   * @param termIDs the 3 or 4 academic terms in the year.\n   */\n  public update(docID: string, { year, retired }:\n    { year?: number; springYear?: number; studentID?: string; termIDs?: string[]; retired?: boolean }) {\n    this.assertDefined(docID);\n    const termIDs = [];\n    const updateData: { year?: number; springYear?: number; termIDs?: string[]; retired?: boolean } = {};\n    if (_.isNumber(year)) {\n      updateData.year = year;\n      updateData.springYear = year + 1;\n      termIDs.push(AcademicTerms.getID(`${AcademicTerms.FALL}-${year}`));\n      if (RadGradProperties.getQuarterSystem()) {\n        termIDs.push(AcademicTerms.getID(`${AcademicTerms.WINTER}-${year + 1}`));\n      }\n      termIDs.push(AcademicTerms.getID(`${AcademicTerms.SPRING}-${year + 1}`));\n      termIDs.push(AcademicTerms.getID(`${AcademicTerms.SUMMER}-${year + 1}`));\n      updateData.termIDs = termIDs;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the academic year.\n   * @param docID The docID of the academic year.\n   */\n  public removeIt(docID: string) {\n    this.assertDefined(docID);\n    // OK, clear to delete.\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Removes all AcademicYearInstance documents referring to user.\n   * @param user The student, either the ID or the username.\n   * @throws { Meteor.Error } If user is not an ID or username.\n   */\n  public removeUser(user: string): void {\n    const studentID = Users.getID(user);\n    this.collection.remove({ studentID });\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\n   * Student.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  public assertValidRoleForMethod(userId: string): void {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.STUDENT]);\n  }\n\n  /**\n   * Depending on the logged in user publish only their AcademicYears. If\n   * the user is an Admin or Advisor then publish all AcademicYears.\n   */\n  public publish(): void {\n    if (Meteor.isServer) {\n      const instance = this;\n      Meteor.publish(this.collectionName, function filterStudentID(studentID) { // eslint-disable-line meteor/audit-argument-checks\n        if (_.isNil(studentID)) {\n          return this.ready();\n        }\n        const profile = Users.getProfile(studentID);\n        if (profile.role === ROLE.ADMIN || Meteor.isAppTest) {\n          return instance.collection.find();\n        }\n        return instance.collection.find({ studentID, retired: { $not: { $eq: true } } });\n      });\n    }\n  }\n\n  /**\n   * @returns {String} A formatted string representing the academic year instance.\n   * @param academicYearInstanceID The academic year instance ID.\n   * @throws {Meteor.Error} If not a valid ID.\n   */\n  public toString(academicYearInstanceID: string): string {\n    this.assertDefined(academicYearInstanceID);\n    const doc = this.findDoc(academicYearInstanceID);\n    const username = Users.getProfile(doc.studentID).username;\n    return `[AY ${doc.year}-${doc.year + 1} ${username}]`;\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks studentID, termIDs\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity(): string[] {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (!Users.isDefined(doc.studentID)) {\n        problems.push(`Bad studentID: ${doc.studentID}`);\n      }\n      _.forEach(doc.termIDs, (termID) => {\n        if (!AcademicTerms.isDefined(termID)) {\n          problems.push(`Bad termID: ${termID}`);\n        }\n      });\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the AcademicYearInstance docID in a format acceptable to define().\n   * @param docID The docID of an AcademicYearInstance.\n   * @returns { object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IAcademicYearInstanceDefine {\n    const doc = this.findDoc(docID);\n    const student = Users.getProfile(doc.studentID).username;\n    const year = doc.year;\n    return { student, year };\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @memberOf api/degree-plan\n */\nexport const AcademicYearInstances = new AcademicYearInstanceCollection();\n// We are not going to persist AcademicYearInstances\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/AcademicYearInstanceCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 337,
    "kind": "variable",
    "name": "AcademicYearInstances",
    "memberof": "api/degree-plan/AcademicYearInstanceCollection.ts",
    "static": true,
    "longname": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstances",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicYearInstanceCollection.ts",
    "importStyle": "{AcademicYearInstances}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 269,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/degree-plan"
      }
    ],
    "type": {
      "types": [
        "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection"
      ]
    }
  },
  {
    "__docId__": 338,
    "kind": "class",
    "name": "AcademicYearInstanceCollection",
    "memberof": "api/degree-plan/AcademicYearInstanceCollection.ts",
    "static": true,
    "longname": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicYearInstanceCollection.ts",
    "importStyle": null,
    "description": "Each AcademicYearInstance represents a sequence of three or four academic terms for a given student.\nIt is used to control the display of academic terms for a given student in the Degree Planner.",
    "lineNumber": 18,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 339,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection#constructor",
    "access": "public",
    "description": "Creates the AcademicYearInstance collection.",
    "lineNumber": 21
  },
  {
    "__docId__": 340,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection",
    "static": false,
    "longname": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 341,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection",
    "static": false,
    "longname": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 342,
    "kind": "method",
    "name": "define",
    "memberof": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection#define",
    "access": "public",
    "description": "Defines a new AcademicYearInstance.",
    "lineNumber": 68,
    "params": [
      {
        "nullable": null,
        "types": [
          "IAcademicYearInstanceDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 343,
    "kind": "method",
    "name": "update",
    "memberof": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection#update",
    "access": "public",
    "description": "Update an AcademicYear.",
    "lineNumber": 129,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 344,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection#removeIt",
    "access": "public",
    "description": "Remove the academic year.",
    "lineNumber": 155,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 345,
    "kind": "method",
    "name": "removeUser",
    "memberof": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection#removeUser",
    "access": "public",
    "description": "Removes all AcademicYearInstance documents referring to user.",
    "lineNumber": 166,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 346,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\nStudent.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 178,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 347,
    "kind": "method",
    "name": "publish",
    "memberof": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection#publish",
    "access": "public",
    "description": "Depending on the logged in user publish only their AcademicYears. If\nthe user is an Admin or Advisor then publish all AcademicYears.",
    "lineNumber": 186,
    "params": [],
    "return": null
  },
  {
    "__docId__": 348,
    "kind": "method",
    "name": "toString",
    "memberof": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection#toString",
    "access": "public",
    "description": "",
    "lineNumber": 220,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{String} A formatted string representing the academic year instance."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "academicYearInstanceID",
        "description": "The academic year instance ID."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "A formatted string representing the academic year instance."
    },
    "throws": [
      {
        "types": [
          "Meteor.Error"
        ],
        "description": "If not a valid ID."
      }
    ]
  },
  {
    "__docId__": 349,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks studentID, termIDs",
    "lineNumber": 220,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 350,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/AcademicYearInstanceCollection.ts~AcademicYearInstanceCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the AcademicYearInstance docID in a format acceptable to define().",
    "lineNumber": 240,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IAcademicYearInstanceDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 351,
    "kind": "file",
    "name": "api/degree-plan/AcademicYearUtilities.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport {} from 'mocha';\nimport { Users } from '../user/UserCollection';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { defineTestFixtures } from '../test/test-utilities';\nimport * as utilities from './AcademicYearUtilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('AcademicYearUtilities', function testSuite() {\n    before(function setup() {\n      this.timeout(15000);\n      defineTestFixtures(['minimal', 'abi.student', 'extended.courses.interests', 'abi.courseinstances']);\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('#getStudentsCurrentAcademicTermNumber.', function test() {\n      const profile = Users.getProfile('abi@hawaii.edu');\n\n      // 1/11/18: Test failed: expected 11 to equal 10. I've changed to 11 so test passes. Has curr academicTerm changed?\n      // TODO: Yes the current academicTerm has rolled and we will have to update this 3 times a year or update abi.student\n      expect(utilities.getStudentsCurrentAcademicTermNumber(profile.userID)).to.equal(18);\n    });\n    it('#getStudentTerms.', function test() {\n      const profile = Users.getProfile('abi@hawaii.edu');\n      const academicTerms = utilities.getStudentTerms(profile.userID);\n      expect(academicTerms.length).to.equal(12);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/AcademicYearUtilities.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 352,
    "kind": "file",
    "name": "api/degree-plan/AcademicYearUtilities.ts",
    "content": "import _ from 'lodash';\nimport { AcademicYearInstances } from './AcademicYearInstanceCollection';\nimport { CourseInstances } from '../course/CourseInstanceCollection';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\n\n/**\n * Returns the student's current academicTerm number (i.e. which academicTerm are they currently in.)\n * @param studentID the studentID.\n * @returns {number}\n * @memberOf api/degree-plan\n */\nexport function getStudentsCurrentAcademicTermNumber(studentID: string) {\n  const cis = CourseInstances.find({ studentID }).fetch();\n  let firstAcademicTerm;\n  _.forEach(cis, (ci) => {\n    const academicTerm = AcademicTerms.findDoc(ci.termID);\n    if (!firstAcademicTerm) {\n      firstAcademicTerm = academicTerm;\n    } else if (academicTerm.termNumber < firstAcademicTerm.termNumber) {\n      firstAcademicTerm = academicTerm;\n    }\n  });\n  const currentAcademicTerm = AcademicTerms.getCurrentAcademicTermDoc();\n  return (currentAcademicTerm.termNumber - firstAcademicTerm.termNumber) + 1;\n}\n\n/**\n * Returns an array of the academicTermIDs that the student has taken or is planning to take courses or opportunities\n * in.\n * @param studentID the studentID.\n * @memberOf api/degree-plan\n */\nexport function getStudentTerms(studentID: string) {\n  const years = AcademicYearInstances.find({ studentID }, { $sort: { year: 1 } }).fetch();\n  let academicTerms = [];\n  _.forEach(years, (ay) => {\n    academicTerms = _.concat(academicTerms, ay.termIDs);\n  });\n  const cis = CourseInstances.find({ studentID }).fetch();\n  let courseAcademicTerms = [];\n  _.forEach(cis, (ci) => {\n    courseAcademicTerms.push(ci.termID);\n  });\n  courseAcademicTerms = _.uniq(courseAcademicTerms);\n  return academicTerms;\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/AcademicYearUtilities.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 353,
    "kind": "function",
    "name": "getStudentsCurrentAcademicTermNumber",
    "memberof": "api/degree-plan/AcademicYearUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicYearUtilities.ts~getStudentsCurrentAcademicTermNumber",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicYearUtilities.ts",
    "importStyle": "{getStudentsCurrentAcademicTermNumber}",
    "description": "Returns the student's current academicTerm number (i.e. which academicTerm are they currently in.)",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 354,
    "kind": "function",
    "name": "getStudentTerms",
    "memberof": "api/degree-plan/AcademicYearUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/AcademicYearUtilities.ts~getStudentTerms",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/AcademicYearUtilities.ts",
    "importStyle": "{getStudentTerms}",
    "description": "Returns an array of the academicTermIDs that the student has taken or is planning to take courses or opportunities\nin.",
    "lineNumber": 33,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 355,
    "kind": "file",
    "name": "api/degree-plan/DesiredDegreeCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { DesiredDegrees } from './DesiredDegreeCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('DesiredDegreeCollection Meteor Methods ', function test() {\n    const collectionName = DesiredDegrees.getCollectionName();\n    const definitionData = {\n      name: 'B.A. in Information and Computer Sciences Test',\n      shortName: 'B.A. ICS Test',\n      slug: 'ba-ics-test',\n      description: 'The Bachelor of Arts (BA) degree allows you to combine computer science with another discipline.',\n    };\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      await defineMethod.callPromise({ collectionName, definitionData });\n    });\n\n    it('Update Method', async function () {\n      const id = DesiredDegrees.findIdBySlug(definitionData.slug);\n      const name = 'updated DesiredDegree name';\n      const shortName = 'updated short name';\n      const description = 'updated description';\n      await updateMethod.callPromise({ collectionName, updateData: { id, name, shortName, description } });\n    });\n\n    it('Remove Method', async function () {\n      await removeItMethod.callPromise({ collectionName, instance: definitionData.slug });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/DesiredDegreeCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 356,
    "kind": "file",
    "name": "api/degree-plan/DesiredDegreeCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport 'mocha';\nimport { DesiredDegrees } from './DesiredDegreeCollection';\nimport { removeAllEntities } from '../base/BaseUtilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('DesiredDegreeCollection', function testSuite() {\n\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(5000);\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(1), fc.lorem(1), fc.lorem(6), fc.boolean(), (fcName, fcShortName, fcSlug, fcDescription, fcRetired) => {\n          const docID = DesiredDegrees.define({\n            name: fcName,\n            shortName: fcShortName,\n            description: fcDescription,\n            slug: fcSlug,\n            retired: fcRetired,\n          });\n          expect(DesiredDegrees.isDefined(docID)).to.be.true;\n          const dd = DesiredDegrees.findDoc(docID);\n          expect(dd.name).to.equal(fcName);\n          expect(dd.shortName).to.equal(fcShortName);\n          expect(dd.description).to.equal(fcDescription);\n          expect(dd.retired).to.equal(fcRetired);\n          DesiredDegrees.removeIt(docID);\n          expect(DesiredDegrees.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicates', function test2() {\n      const name = faker.lorem.word();\n      const shortName = faker.lorem.word();\n      const description = faker.lorem.paragraph();\n      const slug = faker.lorem.word();\n      const retired = faker.random.boolean();\n      const docID = DesiredDegrees.define({ name, shortName, description, slug, retired });\n      expect(DesiredDegrees.isDefined(docID)).to.be.true;\n      expect(() => DesiredDegrees.define({ name, shortName, description, slug, retired })).to.throw();\n      DesiredDegrees.removeIt(docID);\n      expect(DesiredDegrees.isDefined(docID)).to.be.false;\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      const name = faker.lorem.word();\n      const shortName = faker.lorem.word();\n      const description = faker.lorem.paragraph();\n      const slug = faker.lorem.word();\n      const retired = faker.random.boolean();\n      const docID = DesiredDegrees.define({ name, shortName, description, slug, retired });\n      fc.assert(\n        fc.property(fc.lorem(3), fc.lorem(1), fc.lorem(20, true), fc.boolean(), (fcName, fcShortName, fcDescription, fcRetired) => {\n          DesiredDegrees.update(docID, { name: fcName, shortName: fcShortName, description: fcDescription, retired: fcRetired });\n          const dd = DesiredDegrees.findDoc(docID);\n          expect(dd.name).to.equal(fcName);\n          expect(dd.shortName).to.equal(fcShortName);\n          expect(dd.description).to.equal(fcDescription);\n          expect(dd.retired).to.equal(fcRetired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      let dd = DesiredDegrees.findOne({});\n      let docID = dd._id;\n      expect(DesiredDegrees.isDefined(docID)).to.be.true;\n      const dumpObject = DesiredDegrees.dumpOne(docID);\n      DesiredDegrees.removeIt(docID);\n      expect(DesiredDegrees.isDefined(docID)).to.be.false;\n      docID = DesiredDegrees.restoreOne(dumpObject);\n      expect(DesiredDegrees.isDefined(docID)).to.be.true;\n      dd = DesiredDegrees.findDoc(docID);\n      expect(dd.name).to.equal(dumpObject.name);\n      expect(dd.shortName).to.equal(dumpObject.shortName);\n      expect(dd.description).to.equal(dumpObject.description);\n      expect(dd.retired).to.equal(dumpObject.retired);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const errors = DesiredDegrees.checkIntegrity();\n      expect(errors.length).to.equal(0);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/DesiredDegreeCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 357,
    "kind": "file",
    "name": "api/degree-plan/DesiredDegreeCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport SimpleSchema from 'simpl-schema';\nimport BaseSlugCollection from '../base/BaseSlugCollection';\nimport { AcademicPlans } from './AcademicPlanCollection';\nimport { Slugs } from '../slug/SlugCollection';\nimport { IDesiredDegreeDefine, IDesiredDegreeUpdate } from '../../typings/radgrad';\n\n/**\n * DesiredDegrees specifies the set of degrees possible in this department.\n * @extends api/base.BaseSlugCollection\n * @memberOf api/degree-plan\n */\nclass DesiredDegreeCollection extends BaseSlugCollection {\n\n  /**\n   * Creates the DesiredDegree collection.\n   */\n  constructor() {\n    super('DesiredDegree', new SimpleSchema({\n      name: { type: String },\n      shortName: { type: String },\n      slugID: { type: SimpleSchema.RegEx.Id },\n      description: { type: String },\n      retired: { type: Boolean, optional: true },\n    }));\n    this.defineSchema = new SimpleSchema({\n      name: String,\n      shortName: String,\n      slug: String,\n      description: String,\n    });\n    this.updateSchema = new SimpleSchema({\n      name: { type: String, optional: true },\n      shortName: { type: String, optional: true },\n      description: { type: String, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines a new DesiredDegree with its name, slug, and description.\n   * @example\n   * DesiredDegrees.define({ name: 'B.S. in Computer Science',\n   *                         shortName: 'B.S. CS',\n   *                         slug: 'bs-cs',\n   *                         description: 'Focuses on software technology and provides a foundation in math.' });\n   * @param { Object } description Object with keys name, slug, description and optional retired flag.\n   * Slug must be globally unique and previously undefined.\n   * ShortName defaults to name if not supplied.\n   * @throws { Meteor.Error } If the slug already exists.\n   * @returns The newly created docID.\n   */\n  public define({ name, shortName = name, slug, description, retired = false }: IDesiredDegreeDefine) {\n    // Get SlugID, throw error if found.\n    const slugID = Slugs.define({ name: slug, entityName: this.getType() });\n    const desiredDegreeID = this.collection.insert({ name, shortName, slugID, description, retired });\n    // Connect the Slug to this Interest\n    Slugs.updateEntityID(slugID, desiredDegreeID);\n    return desiredDegreeID;\n  }\n\n  /**\n   * Update a DesiredDegree.\n   * @param instance The docID (or slug) associated with this degree.\n   * @param name the name of this degree.\n   * @param shortName the short name of this degree.\n   * @param description the description of this degree.\n   * @param retired boolean, optional.\n   */\n  public update(instance, { name, shortName, description, retired }: IDesiredDegreeUpdate) {\n    const docID = this.getID(instance);\n    const updateData: IDesiredDegreeUpdate = {};\n    if (name) {\n      updateData.name = name;\n    }\n    if (shortName) {\n      updateData.shortName = shortName;\n    }\n    if (description) {\n      updateData.description = description;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the DesiredDegree.\n   * @param instance The docID or slug of the entity to be removed.\n   * @throws { Meteor.Error } If docID is not a DesiredDegree, or if this degree has any associated academic plans or\n   * is referenced by any user.\n   */\n  public removeIt(instance: string) {\n    const desiredDegreeID = this.getID(instance);\n    // Check that this is not referenced by any AcademicPlans.\n    AcademicPlans.find().map((plan) => {\n      if (plan.degreeID === desiredDegreeID) {\n        throw new Meteor.Error(`DesiredDegree ${instance} is referenced by a academic plan ${plan}.`);\n      }\n      return true;\n    });\n    return super.removeIt(desiredDegreeID);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks slugID.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity(): string[] {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (!Slugs.isDefined(doc.slugID)) {\n        problems.push(`Bad slugID: ${doc.slugID}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the DesiredDegree docID in a format acceptable to define().\n   * @param docID The docID of a DesiredDegree.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IDesiredDegreeDefine {\n    const doc = this.findDoc(docID);\n    const name = doc.name;\n    const shortName = doc.shortName;\n    const slug = Slugs.getNameFromID(doc.slugID);\n    const description = doc.description;\n    const retired = doc.retired;\n    return { name, shortName, slug, description, retired };\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @memberOf api/degree-plan\n */\nexport const DesiredDegrees = new DesiredDegreeCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/DesiredDegreeCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 358,
    "kind": "variable",
    "name": "DesiredDegrees",
    "memberof": "api/degree-plan/DesiredDegreeCollection.ts",
    "static": true,
    "longname": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegrees",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/DesiredDegreeCollection.ts",
    "importStyle": "{DesiredDegrees}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 141,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/degree-plan"
      }
    ],
    "type": {
      "types": [
        "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection"
      ]
    }
  },
  {
    "__docId__": 359,
    "kind": "class",
    "name": "DesiredDegreeCollection",
    "memberof": "api/degree-plan/DesiredDegreeCollection.ts",
    "static": true,
    "longname": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/DesiredDegreeCollection.ts",
    "importStyle": null,
    "description": "DesiredDegrees specifies the set of degrees possible in this department.",
    "lineNumber": 14,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseSlugCollection.js~BaseSlugCollection"
    ]
  },
  {
    "__docId__": 360,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection#constructor",
    "access": "public",
    "description": "Creates the DesiredDegree collection.",
    "lineNumber": 17
  },
  {
    "__docId__": 361,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection",
    "static": false,
    "longname": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 362,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection",
    "static": false,
    "longname": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 363,
    "kind": "method",
    "name": "define",
    "memberof": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection#define",
    "access": "public",
    "description": "Defines a new DesiredDegree with its name, slug, and description.",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "IDesiredDegreeDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 364,
    "kind": "method",
    "name": "update",
    "memberof": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection#update",
    "access": "public",
    "description": "Update a DesiredDegree.",
    "lineNumber": 71,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IDesiredDegreeUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 365,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection#removeIt",
    "access": "public",
    "description": "Remove the DesiredDegree.",
    "lineNumber": 95,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 366,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks slugID.",
    "lineNumber": 113,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 367,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/DesiredDegreeCollection.ts~DesiredDegreeCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the DesiredDegree docID in a format acceptable to define().",
    "lineNumber": 128,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IDesiredDegreeDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 368,
    "kind": "file",
    "name": "api/degree-plan/PlanChoiceCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { PlanChoices } from './PlanChoiceCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('PlanChoiceCollection Meteor Methods ', function test() {\n    const collectionName = PlanChoices.getCollectionName();\n    const choice = 'ics211,ics215-1';\n    const definitionData = { choice };\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      await defineMethod.callPromise({ collectionName, definitionData });\n    });\n\n    it('Update Method', async function () {\n      const id = PlanChoices.findOne({}, {})._id;\n      const newChoice = 'ics314-1';\n      await updateMethod.callPromise({ collectionName, updateData: { id, choice: newChoice } });\n    });\n\n    it('Remove Method', async function () {\n      const instance = PlanChoices.findOne({}, {})._id;\n      await removeItMethod.callPromise({ collectionName, instance });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/PlanChoiceCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 369,
    "kind": "file",
    "name": "api/degree-plan/PlanChoiceCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport { PlanChoices } from './PlanChoiceCollection';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { makeComplexPlanChoice, makeSimplePlanChoice, makeSinglePlanChoice } from './SamplePlanChoices';\nimport { getDepartment } from './PlanChoiceUtilities';\nimport { PlanChoiceType } from './PlanChoiceType';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('PlanChoiceCollection', function testSuite() {\n    const single = 'ics_111';\n    const simple = 'ics_313,ics_361';\n    const complex = 'ics_321,ics_332,(ics_415,ics_351)';\n    const complex2 = '(ics_312,ics_331),(ics_313,ics_361),ics_355';\n    const xPlus = 'ics_257+';\n\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(5000);\n      fc.assert(\n        fc.property(fc.lorem(2), fc.boolean(), (fake, retired) => {\n          let choice = makeSinglePlanChoice({});\n          let docID = PlanChoices.define({ choice, retired });\n          expect(PlanChoices.isDefined(docID)).to.be.true;\n          PlanChoices.removeIt(docID);\n          expect(PlanChoices.isDefined(docID)).to.be.false;\n          choice = makeSimplePlanChoice({});\n          docID = PlanChoices.define({ choice, retired });\n          expect(PlanChoices.isDefined(docID)).to.be.true;\n          PlanChoices.removeIt(docID);\n          expect(PlanChoices.isDefined(docID)).to.be.false;\n          choice = makeComplexPlanChoice({});\n          // console.log(PlanChoices.toString(choice));\n          docID = PlanChoices.define({ choice, retired });\n          expect(PlanChoices.isDefined(docID)).to.be.true;\n          PlanChoices.removeIt(docID);\n          expect(PlanChoices.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Can define duplicates', function test2(done) {\n      const choice = makeComplexPlanChoice({});\n      const docID1 = PlanChoices.define({ choice });\n      const docID2 = PlanChoices.define({ choice });\n      expect(docID1).to.equal(docID2);\n      expect(PlanChoices.isDefined(docID2)).to.be.true;\n      PlanChoices.removeIt(docID1);\n      expect(PlanChoices.isDefined(docID2)).to.be.false;\n      done();\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      let choice = makeSinglePlanChoice({});\n      const dept = getDepartment(choice);\n      const docID = PlanChoices.define({ choice });\n      fc.assert(\n        fc.property(fc.lorem(2), fc.boolean(), (fake, retired) => {\n          choice = makeSimplePlanChoice({ dept });\n          PlanChoices.update(docID, { choice, retired });\n          const doc = PlanChoices.findDoc(docID);\n          expect(doc.choice).to.equal(choice);\n          expect(doc.retired).to.equal(retired);\n        }),\n      );\n      PlanChoices.removeIt(docID);\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test5() {\n      const choice = makeComplexPlanChoice({});\n      let docID = PlanChoices.define({ choice });\n      const origDoc = PlanChoices.findDoc(docID);\n      expect(PlanChoices.isDefined(docID)).to.be.true;\n      const dumpObject = PlanChoices.dumpOne(docID);\n      expect(dumpObject.choice).to.equal(choice);\n      expect(dumpObject.retired).to.be.false;\n      PlanChoices.removeIt(docID);\n      expect(PlanChoices.isDefined(docID)).to.be.false;\n      docID = PlanChoices.restoreOne(dumpObject);\n      const restored = PlanChoices.findDoc(docID);\n      expect(origDoc.choice).to.equal(restored.choice);\n      expect(origDoc.retired).to.equal(restored.retired);\n    });\n\n    it('Can checkIntegrity with errors', function test6() {\n      const errors = PlanChoices.checkIntegrity();\n      expect(errors.length).to.equal(4); // there are 4 choices defined in the complex choice w/o Courses.\n    });\n\n    it('Can get toString', function test7() {\n      expect(PlanChoices.toString(single)).to.equal('ICS 111');\n      expect(PlanChoices.toString(simple)).to.equal('ICS 313 or ICS 361');\n      expect(PlanChoices.toString(complex)).to.equal('ICS 321 or ICS 332 or (ICS 415 or ICS 351)');\n      expect(PlanChoices.toString(complex2)).to.equal('(ICS 312 or ICS 331) or (ICS 313 or ICS 361) or ICS 355');\n    });\n\n    it('Can get choice type', function test8() {\n      expect(PlanChoices.getPlanChoiceType(single)).to.equal(PlanChoiceType.SINGLE);\n      expect(PlanChoices.getPlanChoiceType(simple)).to.equal(PlanChoiceType.SIMPLE);\n      expect(PlanChoices.getPlanChoiceType(complex)).to.equal(PlanChoiceType.COMPLEX);\n      expect(PlanChoices.getPlanChoiceType(complex2)).to.equal(PlanChoiceType.COMPLEX);\n      expect(PlanChoices.getPlanChoiceType(xPlus)).to.equal(PlanChoiceType.XPLUS);\n    });\n\n    it('Can check if course slug satisfies choice', function test9() {\n      expect(PlanChoices.satisfiesPlanChoice(single, 'ics_111')).to.be.true;\n      expect(PlanChoices.satisfiesPlanChoice(single, 'ics_211')).to.be.false;\n      expect(PlanChoices.satisfiesPlanChoice(simple, 'ics_313')).to.be.true;\n      expect(PlanChoices.satisfiesPlanChoice(simple, 'ics_361')).to.be.true;\n      expect(PlanChoices.satisfiesPlanChoice(simple, 'ics_314')).to.be.false;\n      expect(PlanChoices.satisfiesPlanChoice(complex, 'ics_321')).to.be.true;\n      expect(PlanChoices.satisfiesPlanChoice(complex, 'ics_332')).to.be.true;\n      expect(PlanChoices.satisfiesPlanChoice(complex, 'ics_415')).to.be.true;\n      expect(PlanChoices.satisfiesPlanChoice(complex, 'ics_351')).to.be.true;\n      expect(PlanChoices.satisfiesPlanChoice(complex, 'ics_355')).to.be.false;\n      expect(PlanChoices.satisfiesPlanChoice(complex2, 'ics_312')).to.be.true;\n      expect(PlanChoices.satisfiesPlanChoice(complex2, 'ics_331')).to.be.true;\n      expect(PlanChoices.satisfiesPlanChoice(complex2, 'ics_313')).to.be.true;\n      expect(PlanChoices.satisfiesPlanChoice(complex2, 'ics_361')).to.be.true;\n      expect(PlanChoices.satisfiesPlanChoice(complex2, 'ics_355')).to.be.true;\n      expect(PlanChoices.satisfiesPlanChoice(complex2, 'ics_455')).to.be.false;\n      expect(PlanChoices.satisfiesPlanChoice(xPlus, 'ics_455')).to.be.true;\n      expect(PlanChoices.satisfiesPlanChoice(xPlus, 'ics_255')).to.be.false;\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/PlanChoiceCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 370,
    "kind": "file",
    "name": "api/degree-plan/PlanChoiceCollection.ts",
    "content": "import SimpleSchema from 'simpl-schema';\nimport _ from 'lodash';\nimport BaseCollection from '../base/BaseCollection';\nimport {\n  buildSimpleName,\n  complexChoiceToArray,\n  isSimpleChoice,\n  isSingleChoice,\n  isXXChoice,\n  getSimpleChoiceNumber,\n} from './PlanChoiceUtilities';\nimport { IPlanChoiceDefine, IPlanChoiceUpdate } from '../../typings/radgrad';\nimport { IPlanChoiceType, PlanChoiceType } from './PlanChoiceType';\nimport { Courses } from '../course/CourseCollection';\n\n/**\n * Represents a choice in an academic plan.\n * @extends api/base.BaseCollection\n * @memberOf api/degree-plan\n */\nexport class PlanChoiceCollection extends BaseCollection {\n\n  /**\n   * Creates a plan choice.\n   */\n  constructor() {\n    super('PlanChoice', new SimpleSchema({\n      choice: String, // this is the choice such as ics111 or ics_313,ics_361\n      retired: { type: Boolean, optional: true },\n    }));\n    this.defineSchema = new SimpleSchema({\n      choice: String, // this is the choice such as ics111 or ics_313,ics_361\n      retired: { type: Boolean, optional: true },\n    });\n    this.updateSchema = new SimpleSchema({\n      choice: { type: String, optional: true }, // this is the choice such as ics111 or ics_313,ics_361\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines a PlanChoice.\n   * @example\n   * PlanChoices.define({ 'ics_312,ics_331-1' });\n   * Defines the choice of ICS 312 or ICS 331.\n   * @param choice\n   * @param {boolean} retired, (optional) defaults to false.\n   * @returns {*}\n   */\n  public define({ choice, retired = false }: IPlanChoiceDefine) {\n    const doc = this.collection.findOne({ choice });\n    if (doc) {\n      return doc._id;\n    }\n    return this.collection.insert({ choice, retired });\n  }\n\n  /**\n   * Updates this PlanChoice.\n   * @param docID The docID associated with this plan choice.\n   * @param choice the updated choice.\n   */\n  public update(docID: string, { choice, retired }: IPlanChoiceUpdate) {\n    this.assertDefined(docID);\n    const updateData: IPlanChoiceUpdate = {};\n    if (choice) {\n      updateData.choice = choice;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Creates a human readable string representation of the choice.\n   * @param planChoice\n   * @returns {string}\n   */\n  public toString(planChoice: string) {\n    let ret = '';\n    let slug;\n    const countIndex = planChoice.indexOf('-');\n    if (countIndex === -1) {\n      slug = planChoice;\n    } else {\n      slug = planChoice.substring(0, countIndex);\n    }\n    while (slug.length > 0) {\n      let temp;\n      let index;\n      if (slug.startsWith('(')) {\n        index = slug.indexOf(')');\n        temp = slug.substring(1, index);\n        ret = `${ret}(${buildSimpleName(temp)}) or `;\n        if (index < slug.length - 2) {\n          slug = slug.substring(index + 2); // skip over the ,\n        } else {\n          slug = '';\n        }\n      } else\n        if (slug.indexOf(',') !== -1) {\n          index = slug.indexOf(',');\n          temp = slug.substring(0, index);\n          slug = slug.substring(index + 1);\n          ret = `${ret}${buildSimpleName(temp)} or `;\n        } else {\n          temp = slug;\n          slug = '';\n          ret = `${ret}${buildSimpleName(temp)} or `;\n        }\n    }\n    return ret.substring(0, ret.length - 4);\n  }\n\n  public getPlanChoiceType(choice: string): IPlanChoiceType {\n    if (isXXChoice(choice)) {\n      return PlanChoiceType.XPLUS;\n    }\n    if (isSingleChoice(choice)) {\n      return PlanChoiceType.SINGLE;\n    }\n    if (isSimpleChoice(choice)) {\n      return PlanChoiceType.SIMPLE;\n    }\n    return PlanChoiceType.COMPLEX;\n  }\n\n  public isGraduateChoice(planChoice: string): boolean {\n    const simpleChoices = complexChoiceToArray(planChoice);\n    let retVal = false;\n    _.forEach(simpleChoices, (choice) => {\n      const planNumberStr = getSimpleChoiceNumber(choice);\n      const planNumber = parseInt(planNumberStr, 10);\n      if (planNumber > 500) {\n        retVal = true;\n      }\n    });\n    return retVal;\n  }\n\n  public satisfiesPlanChoice(planChoice: string, courseSlug: string): boolean {\n    if (this.getPlanChoiceType(planChoice) === PlanChoiceType.XPLUS) {\n      const planNumberStr = getSimpleChoiceNumber(planChoice);\n      const planNumber = parseInt(planNumberStr.substring(0, planNumberStr.length - 1), 10);\n      const courseNumber = parseInt(getSimpleChoiceNumber(courseSlug), 10);\n      return courseNumber >= planNumber;\n    }\n    const simpleChoices = complexChoiceToArray(planChoice);\n    let returnVal = false;\n    _.forEach(simpleChoices, (choice) => {\n      if (this.getPlanChoiceType(choice) === PlanChoiceType.XPLUS) {\n        const planNumberStr = getSimpleChoiceNumber(choice);\n        const planNumber = parseInt(planNumberStr.substring(0, planNumberStr.length - 1), 10);\n        const courseNumber = parseInt(getSimpleChoiceNumber(courseSlug), 10);\n        if (courseNumber >= planNumber) {\n          returnVal = true;\n        }\n      } else if (choice.includes(courseSlug)) {\n        returnVal = true;\n      }\n    });\n    return returnVal;\n  }\n\n  /**\n   * Returns an empty array (no integrity checking done on this collection).\n   * This method will ensure that there is a single choice for each of the non retired courses.\n   * @returns {Array} An empty array.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (this.getPlanChoiceType(doc.choice) !== PlanChoiceType.XPLUS) {\n        const courseSlugs = complexChoiceToArray(doc.choice);\n        _.forEach(courseSlugs, (slug) => {\n          if (!Courses.isDefined(slug)) {\n            problems.push(`Plan choice ${doc.choice} has undefined course slug ${slug}.`);\n          }\n        });\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the PlanChoice docID in a format acceptable to define().\n   * @param docID The docID of a PlanChoice.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IPlanChoiceDefine {\n    const doc = this.findDoc(docID);\n    const choice = doc.choice;\n    const retired = doc.retired;\n    return { choice, retired };\n  }\n\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @memberOf api/degree-plan\n */\nexport const PlanChoices = new PlanChoiceCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/PlanChoiceCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 371,
    "kind": "class",
    "name": "PlanChoiceCollection",
    "memberof": "api/degree-plan/PlanChoiceCollection.ts",
    "static": true,
    "longname": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceCollection.ts",
    "importStyle": "{PlanChoiceCollection}",
    "description": "Represents a choice in an academic plan.",
    "lineNumber": 21,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 372,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection#constructor",
    "access": "public",
    "description": "Creates a plan choice.",
    "lineNumber": 17
  },
  {
    "__docId__": 373,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection",
    "static": false,
    "longname": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 374,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection",
    "static": false,
    "longname": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 375,
    "kind": "method",
    "name": "define",
    "memberof": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection#define",
    "access": "public",
    "description": "Defines a PlanChoice.",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "IPlanChoiceDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 376,
    "kind": "method",
    "name": "update",
    "memberof": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection#update",
    "access": "public",
    "description": "Updates this PlanChoice.",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IPlanChoiceUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 377,
    "kind": "method",
    "name": "toString",
    "memberof": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection#toString",
    "access": "public",
    "description": "Creates a human readable string representation of the choice.",
    "lineNumber": 80,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "planChoice",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 378,
    "kind": "method",
    "name": "getPlanChoiceType",
    "memberof": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection#getPlanChoiceType",
    "access": "public",
    "description": "",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "choice",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IPlanChoiceType"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 379,
    "kind": "method",
    "name": "isGraduateChoice",
    "memberof": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection#isGraduateChoice",
    "access": "public",
    "description": "",
    "lineNumber": 129,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "planChoice",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 380,
    "kind": "method",
    "name": "satisfiesPlanChoice",
    "memberof": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection#satisfiesPlanChoice",
    "access": "public",
    "description": "",
    "lineNumber": 142,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "planChoice",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "courseSlug",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 381,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an empty array (no integrity checking done on this collection).\nThis method will ensure that there is a single choice for each of the non retired courses.",
    "lineNumber": 171,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 382,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the PlanChoice docID in a format acceptable to define().",
    "lineNumber": 191,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IPlanChoiceDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 383,
    "kind": "variable",
    "name": "PlanChoices",
    "memberof": "api/degree-plan/PlanChoiceCollection.ts",
    "static": true,
    "longname": "api/degree-plan/PlanChoiceCollection.ts~PlanChoices",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceCollection.ts",
    "importStyle": "{PlanChoices}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 235,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/degree-plan"
      }
    ],
    "type": {
      "types": [
        "api/degree-plan/PlanChoiceCollection.ts~PlanChoiceCollection"
      ]
    }
  },
  {
    "__docId__": 384,
    "kind": "file",
    "name": "api/degree-plan/PlanChoiceType.ts",
    "content": "export enum PlanChoiceType {\n  SINGLE = 'single',\n  SIMPLE = 'simple',\n  COMPLEX = 'complex',\n  XPLUS = 'xPlus',\n}\n\nexport type IPlanChoiceType = PlanChoiceType.SINGLE | PlanChoiceType.SIMPLE | PlanChoiceType.COMPLEX | PlanChoiceType.XPLUS;\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/PlanChoiceType.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 385,
    "kind": "file",
    "name": "api/degree-plan/PlanChoiceUtilities.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport * as planChoiceUtilities from './PlanChoiceUtilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('PlanChoiceUtilities', function testSuite() {\n    it('#stripCounter', function test() {\n      let slug = 'ics_111';\n      expect(planChoiceUtilities.stripCounter(slug)).to.equal('ics_111');\n      slug = 'ics_400+-5';\n      expect(planChoiceUtilities.stripCounter(slug)).to.equal('ics_400+');\n    });\n    it('#is*Choice', function test() {\n      let slug = 'ics_111';\n      expect(planChoiceUtilities.isSingleChoice(slug)).to.be.true;\n      expect(planChoiceUtilities.isSimpleChoice(slug)).to.be.false;\n      expect(planChoiceUtilities.isComplexChoice(slug)).to.be.false;\n      slug = 'ics_111,ics_211';\n      expect(planChoiceUtilities.isSingleChoice(slug)).to.be.false;\n      expect(planChoiceUtilities.isSimpleChoice(slug)).to.be.true;\n      expect(planChoiceUtilities.isComplexChoice(slug)).to.be.false;\n      slug = 'ics_111,(ics_211,ics_355)';\n      expect(planChoiceUtilities.isSingleChoice(slug)).to.be.false;\n      expect(planChoiceUtilities.isSimpleChoice(slug)).to.be.false;\n      expect(planChoiceUtilities.isComplexChoice(slug)).to.be.true;\n    });\n    it('#complexChoiceToArray', function test() {\n      let slug = 'ics_111,(ics_211,ics_355)';\n      let ans = planChoiceUtilities.complexChoiceToArray(slug);\n      expect(ans.length).to.equal(3);\n      expect(ans[1]).to.equal('ics_211');\n      slug = 'ics_111';\n      ans = planChoiceUtilities.complexChoiceToArray(slug);\n      expect(ans.length).to.equal(1);\n      expect(ans[0]).to.equal('ics_111');\n    });\n    it('#buildCourseSlugName', function test() {\n      let slug = 'ics_111';\n      expect(planChoiceUtilities.buildCourseSlugName(slug)).to.equal('ICS 111');\n      slug = 'ee_111';\n      expect(planChoiceUtilities.buildCourseSlugName(slug)).to.equal('EE 111');\n    });\n    it('#satisfiesPlanChoice', function test() {\n      let planChoice = 'ics_111';\n      let slug = 'ics_111';\n      expect(planChoiceUtilities.satisfiesPlanChoice(planChoice, slug)).to.be.true;\n      slug = 'ee_111';\n      expect(planChoiceUtilities.satisfiesPlanChoice(planChoice, slug)).to.be.false;\n      slug = 'ics_141';\n      expect(planChoiceUtilities.satisfiesPlanChoice(planChoice, slug)).to.be.false;\n      planChoice = 'ics_313,ics_331';\n      slug = 'ics_313';\n      expect(planChoiceUtilities.satisfiesPlanChoice(planChoice, slug)).to.be.true;\n      slug = 'ics_331';\n      expect(planChoiceUtilities.satisfiesPlanChoice(planChoice, slug)).to.be.true;\n      slug = 'ics_355';\n      expect(planChoiceUtilities.satisfiesPlanChoice(planChoice, slug)).to.be.false;\n      slug = 'ee_331';\n      expect(planChoiceUtilities.satisfiesPlanChoice(planChoice, slug)).to.be.false;\n      planChoice = 'ics_311,ee_331';\n      expect(planChoiceUtilities.satisfiesPlanChoice(planChoice, slug)).to.be.true;\n      slug = 'ics_311';\n      expect(planChoiceUtilities.satisfiesPlanChoice(planChoice, slug)).to.be.true;\n      slug = 'ics_331';\n      expect(planChoiceUtilities.satisfiesPlanChoice(planChoice, slug)).to.be.false;\n      planChoice = '(ics_313,ics_331),ics_355';\n      slug = 'ics_313';\n      expect(planChoiceUtilities.satisfiesPlanChoice(planChoice, slug)).to.be.true;\n      slug = 'ics_331';\n      expect(planChoiceUtilities.satisfiesPlanChoice(planChoice, slug)).to.be.true;\n      slug = 'ics_355';\n      expect(planChoiceUtilities.satisfiesPlanChoice(planChoice, slug)).to.be.true;\n      planChoice = '(ics_313,ics_331),(ics_312,ics_332)';\n      slug = 'ics_355';\n      expect(planChoiceUtilities.satisfiesPlanChoice(planChoice, slug)).to.be.false;\n    });\n    it('#getDepartment, #getDepartments', function test() {\n      let slug = 'ics_111';\n      expect(planChoiceUtilities.getDepartment(slug)).to.equal('ics');\n      slug = 'ee_111';\n      expect(planChoiceUtilities.getDepartment(slug)).to.equal('ee');\n      slug = '(ics_111,ics_141),ee_160';\n      const departments = planChoiceUtilities.getDepartments(slug);\n      expect(departments.length).to.equal(2);\n      expect(departments.indexOf('ics')).to.equal(0);\n      expect(departments.indexOf('ee')).to.equal(1);\n    });\n    it('#compoundCombineChoices', function () {\n      const choice1 = 'ics_111';\n      const choice2 = 'ics_211';\n      const choice3 = 'ics_141';\n      const choice4 = 'ics_241';\n      const result1 = planChoiceUtilities.compoundCombineChoices(choice1, choice2);\n      expect(result1).to.equal(`${choice1},${choice2}`);\n      const result2 = planChoiceUtilities.compoundCombineChoices(result1, choice3);\n      expect(result2).to.equal(`(${result1}),${choice3}`);\n      const result3 = planChoiceUtilities.compoundCombineChoices(choice4, result2);\n      expect(result3).to.equal(`${choice4},(${result2})`);\n      // console.log(result1, result2, result3);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/PlanChoiceUtilities.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 386,
    "kind": "file",
    "name": "api/degree-plan/PlanChoiceUtilities.ts",
    "content": "import _ from 'lodash';\n\n/**\n * Strips of the counter for the plan choice. The counter is used in academic plans to keep track of how many\n * choices there are (e.g. five ics_400+ in the B.S. degree).\n * @param planChoice the plan choice.\n * @returns {*}\n * @memberOf api/degree-plan\n */\nexport function stripCounter(planChoice: string) {\n  const index = planChoice.indexOf('-');\n  if (index !== -1) {\n    return planChoice.substring(0, index);\n  }\n  return planChoice;\n}\n\n/**\n * Returns the count of the given planChoice.\n * @param {string} planChoice the planChoice\n * @returns {number} the count value of the planChoice, or 0 if none.\n */\nexport function getPlanCount(planChoice: string): number {\n  const index = planChoice.indexOf('-');\n  if (index !== -1) {\n    return parseInt(planChoice.substring(index + 1), 10);\n  }\n  return 0;\n}\n\n/**\n * Returns true if the planChoice is a single choice.\n * @param planChoice the plan choice.\n * @returns {boolean}\n * @memberOf api/degree-plan\n */\nexport function isSingleChoice(planChoice: string) {\n  const cleaned = stripCounter(planChoice);\n  return cleaned.indexOf(',') === -1;\n}\n\n/**\n * Returns true if the plan choice is a simple choice, just individual slugs separated by commas.\n * @param planChoice the plan choice.\n * @returns {boolean}\n * @memberOf api/degree-plan\n */\nexport function isSimpleChoice(planChoice: string) {\n  const cleaned = stripCounter(planChoice);\n  const parenp = cleaned.indexOf('(') !== -1;\n  const orp = cleaned.indexOf(',') !== -1;\n  return !parenp && orp;\n}\n\n/**\n * Returns true if the plan choice includes a sub-choice (e.g. '(ics_313,ics_331),ics_355-1' )\n * @param planChoice the plan choice.\n * @returns {boolean}\n * @memberOf api/degree-plan\n */\nexport function isComplexChoice(planChoice: string) {\n  const cleaned = stripCounter(planChoice);\n  const parenp = cleaned.indexOf('(') !== -1;\n  const orp = cleaned.indexOf(',') !== -1;\n  return parenp && orp;\n}\n\n/**\n * Returns true if the planChoice is a 300+ or 400+.\n * @param planChoice the plan choice.\n * @return {boolean}\n * @memberOf api/degree-plan\n */\nexport function isXXChoice(planChoice: string) {\n  const cleaned = stripCounter(planChoice);\n  return cleaned.indexOf('+') !== -1;\n}\n\n/**\n * Converts a complex choice into an array of the slugs that make up the choice.\n * Note: This may not be enough to solve the generate plan problem.\n * @param planChoice a plan choice.\n * @memberOf api/degree-plan\n */\nexport function complexChoiceToArray(planChoice: string) {\n  const cleaned = stripCounter(planChoice);\n  const split = cleaned.split(',');\n  return _.map(split, (slug) => {\n    if (slug.startsWith('(')) {\n      return slug.substring(1);\n    }\n    if (slug.endsWith(')')) {\n      return slug.substring(0, slug.length - 1);\n    }\n    return slug;\n  });\n}\n\n/**\n * Creates the course name from the slug. Course names have department in all caps.\n * @param slug the course slug.\n * @returns {string}\n * @memberOf api/degree-plan\n */\nexport function buildCourseSlugName(slug: string) {\n  const splits = slug.split('_');\n  return `${splits[0].toUpperCase()} ${splits[1]}`;\n}\n\n/**\n * Builds the Name for a simple planChoice. Will have commas replaced by ' or '.\n * @param slug the simple plan choice.\n * @returns {string}\n * @memberOf api/degree-plan\n */\nexport function buildSimpleName(slug: string) {\n  const splits = stripCounter(slug).split(',');\n  let ret = '';\n  _.forEach(splits, (s) => {\n    ret = `${ret}${buildCourseSlugName(s)} or `;\n  });\n  return ret.substring(0, ret.length - 4);\n}\n\n/**\n * Returns the department from a course slug.\n * @param courseSlug\n * @returns {*}\n * @memberOf api/degree-plan\n */\nexport function getDepartment(courseSlug: string) {\n  let slug = courseSlug;\n  if (courseSlug.startsWith('(')) {\n    slug = courseSlug.substring(1);\n  }\n  const result = slug.split('_');\n  return result[0];\n}\n\n/**\n * Returns an array of the departments in the plan choice.\n * @param planChoice The plan choice.\n * @returns {Array}\n * @memberOf api/degree-plan\n */\nexport function getDepartments(planChoice: string) {\n  const choices = complexChoiceToArray(planChoice);\n  const ret = [];\n  _.forEach(choices, (c) => {\n    const dept = getDepartment(c);\n    if (_.indexOf(ret, dept) === -1) {\n      ret.push(dept);\n    }\n  });\n  return ret;\n}\n\n/**\n * Returns true if the getCourseSlug satisfies the planChoice.\n * @param planChoice a plan choice.\n * @param courseSlug a course's slug.\n * @returns {*}\n * @memberOf api/degree-plan\n */\nfunction satisfiesSinglePlanChoice(planChoice: string, courseSlug: string) {\n  const dept = getDepartment(planChoice);\n  const stripped = stripCounter(planChoice);\n  if (planChoice.includes('300+')) {\n    return courseSlug.startsWith(`${dept}_3`) || courseSlug.startsWith(`${dept}_4`);\n  }\n  if (planChoice.includes('400+')) {\n    return courseSlug.startsWith(`${dept}_4`);\n  }\n  return planChoice.indexOf(courseSlug) !== -1 && stripped.length === courseSlug.length;\n}\n\n/**\n * Returns the number portion of the getCourseSlug.\n * @param courseSlug the course slug.\n * @returns {string}\n */\nexport function getSimpleChoiceNumber(simpleChoice): string {\n  return simpleChoice.split('_')[1];\n}\n\n/**\n * Returns true if the courseSlug satisfies the plan choice.\n * @param planChoice The plan choice.\n * @param courseSlug The course slug.\n * @return {Boolean}\n * @memberOf api/degree-plan\n */\nexport function satisfiesPlanChoice(planChoice: string, courseSlug: string) {\n  const singleChoices = complexChoiceToArray(planChoice);\n  let ret = false;\n  _.forEach(singleChoices, (choice) => {\n    if (satisfiesSinglePlanChoice(choice, courseSlug)) {\n      ret = true;\n    }\n  });\n  // console.log('satisfiesPlanChoice %s, %s returns %o', planChoice, getCourseSlug, ret);\n  return ret;\n}\n\n/**\n * Returns the index of the getCourseSlug in the array of plan choices.\n * @param planChoices an array of plan choices.\n * @param courseSlug the course slug.\n * @return {Number} the index of getCourseSlug in the array.\n * @memberOf api/degree-plan\n */\nexport function planIndexOf(planChoices: string[], courseSlug: string) {\n  for (let i = 0; i < planChoices.length; i += 1) {\n    if (satisfiesPlanChoice(planChoices[i], courseSlug)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nexport function simpleCombineChoices(choice1: string, choice2: string): string {\n  return `${choice1},${choice2}`;\n}\n\nexport function compoundCombineChoices(choice1: string, choice2: string): string {\n  let left = choice1;\n  let right = choice2;\n  if (!isSingleChoice(left)) {\n    left = `(${left})`;\n  }\n  if (!isSingleChoice(right)) {\n    right = `(${right})`;\n  }\n  return `${left},${right}`;\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/PlanChoiceUtilities.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 387,
    "kind": "function",
    "name": "stripCounter",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~stripCounter",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": "{stripCounter}",
    "description": "Strips of the counter for the plan choice. The counter is used in academic plans to keep track of how many\nchoices there are (e.g. five ics_400+ in the B.S. degree).",
    "lineNumber": 10,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "planChoice",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 388,
    "kind": "function",
    "name": "getPlanCount",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~getPlanCount",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": "{getPlanCount}",
    "description": "Returns the count of the given planChoice.",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "planChoice",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 389,
    "kind": "function",
    "name": "isSingleChoice",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~isSingleChoice",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": "{isSingleChoice}",
    "description": "Returns true if the planChoice is a single choice.",
    "lineNumber": 37,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "planChoice",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 390,
    "kind": "function",
    "name": "isSimpleChoice",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~isSimpleChoice",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": "{isSimpleChoice}",
    "description": "Returns true if the plan choice is a simple choice, just individual slugs separated by commas.",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "planChoice",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 391,
    "kind": "function",
    "name": "isComplexChoice",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~isComplexChoice",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": "{isComplexChoice}",
    "description": "Returns true if the plan choice includes a sub-choice (e.g. '(ics_313,ics_331),ics_355-1' )",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "planChoice",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 392,
    "kind": "function",
    "name": "isXXChoice",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~isXXChoice",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": "{isXXChoice}",
    "description": "Returns true if the planChoice is a 300+ or 400+.",
    "lineNumber": 74,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "planChoice",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 393,
    "kind": "function",
    "name": "complexChoiceToArray",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~complexChoiceToArray",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": "{complexChoiceToArray}",
    "description": "Converts a complex choice into an array of the slugs that make up the choice.\nNote: This may not be enough to solve the generate plan problem.",
    "lineNumber": 85,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "planChoice",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 394,
    "kind": "function",
    "name": "buildCourseSlugName",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~buildCourseSlugName",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": "{buildCourseSlugName}",
    "description": "Creates the course name from the slug. Course names have department in all caps.",
    "lineNumber": 105,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "slug",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 395,
    "kind": "function",
    "name": "buildSimpleName",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~buildSimpleName",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": "{buildSimpleName}",
    "description": "Builds the Name for a simple planChoice. Will have commas replaced by ' or '.",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "slug",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 396,
    "kind": "function",
    "name": "getDepartment",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~getDepartment",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": "{getDepartment}",
    "description": "Returns the department from a course slug.",
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "courseSlug",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 397,
    "kind": "function",
    "name": "getDepartments",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~getDepartments",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": "{getDepartments}",
    "description": "Returns an array of the departments in the plan choice.",
    "lineNumber": 146,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "planChoice",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 398,
    "kind": "function",
    "name": "satisfiesSinglePlanChoice",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~satisfiesSinglePlanChoice",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": null,
    "description": "Returns true if the getCourseSlug satisfies the planChoice.",
    "lineNumber": 165,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "planChoice",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "courseSlug",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 399,
    "kind": "function",
    "name": "getSimpleChoiceNumber",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~getSimpleChoiceNumber",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": "{getSimpleChoiceNumber}",
    "description": "Returns the number portion of the getCourseSlug.",
    "lineNumber": 182,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "simpleChoice",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 400,
    "kind": "function",
    "name": "satisfiesPlanChoice",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~satisfiesPlanChoice",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": "{satisfiesPlanChoice}",
    "description": "Returns true if the courseSlug satisfies the plan choice.",
    "lineNumber": 193,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "planChoice",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "courseSlug",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 401,
    "kind": "function",
    "name": "planIndexOf",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~planIndexOf",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": "{planIndexOf}",
    "description": "Returns the index of the getCourseSlug in the array of plan choices.",
    "lineNumber": 212,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "planChoices",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "courseSlug",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 402,
    "kind": "function",
    "name": "simpleCombineChoices",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~simpleCombineChoices",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": "{simpleCombineChoices}",
    "description": "",
    "lineNumber": 221,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "choice1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "choice2",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 403,
    "kind": "function",
    "name": "compoundCombineChoices",
    "memberof": "api/degree-plan/PlanChoiceUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/PlanChoiceUtilities.ts~compoundCombineChoices",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/PlanChoiceUtilities.ts",
    "importStyle": "{compoundCombineChoices}",
    "description": "",
    "lineNumber": 225,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "choice1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "choice2",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 404,
    "kind": "file",
    "name": "api/degree-plan/PreferredChoice.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport {} from 'mocha';\nimport { Courses } from '../course/CourseCollection';\nimport { Interests } from '../interest/InterestCollection';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { defineTestFixtures } from '../test/test-utilities';\nimport PreferredChoice from './PreferredChoice';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('PreferredChoice', function testSuite() {\n    before(function setup() {\n      this.timeout(5000);\n      defineTestFixtures(['minimal', 'extended.courses.interests']);\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('#hasPreferences, #getBestChoices, #getOrderedChoices', function test() {\n      const courses = [];\n      courses.push(Courses.findDocBySlug('ics_111'));\n      courses.push(Courses.findDocBySlug('ics_141'));\n      courses.push(Courses.findDocBySlug('ics_211'));\n      const interestIDs = [];\n      interestIDs.push(Interests.findIdBySlug('ruby'));\n      let preferred = new PreferredChoice(courses, interestIDs);\n      expect(preferred.hasPreferences()).to.be.false;\n      expect(preferred.getBestChoices().length).to.equal(3);\n      let ordered = preferred.getOrderedChoices();\n      expect(ordered[0].num).to.equal('ICS 111');\n      expect(ordered[1].num).to.equal('ICS 141');\n      expect(ordered[2].num).to.equal('ICS 211');\n      interestIDs.push(Interests.findIdBySlug('java'));\n      preferred = new PreferredChoice(courses, interestIDs);\n      expect(preferred.hasPreferences()).to.be.true;\n      expect(preferred.getBestChoices().length).to.equal(2);\n      ordered = preferred.getOrderedChoices();\n      expect(ordered[0].num).to.equal('ICS 111');\n      expect(ordered[2].num).to.equal('ICS 141');\n      expect(ordered[1].num).to.equal('ICS 211');\n      interestIDs.push(Interests.findIdBySlug('algorithms'));\n      preferred = new PreferredChoice(courses, interestIDs);\n      expect(preferred.hasPreferences()).to.be.true;\n      expect(preferred.getBestChoices().length).to.equal(1);\n      interestIDs.push(Interests.findIdBySlug('software-engineering'));\n      preferred = new PreferredChoice(courses, interestIDs);\n      expect(preferred.hasPreferences()).to.be.true;\n      expect(preferred.getBestChoices().length).to.equal(1);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/PreferredChoice.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 405,
    "kind": "file",
    "name": "api/degree-plan/PreferredChoice.ts",
    "content": "import _ from 'lodash';\n\n/**\n * Class that can calculate the preferred choice given an array of interests.\n * @memberOf api/degree-plan\n */\nclass PreferredChoice {\n  private readonly rankedChoices: any;\n  private readonly max: number;\n\n  /**\n   * Creates a new PreferredChoice instance given the array of choices and array of interestIDs.\n   * @param choices\n   * @param interestIDs\n   */\n  constructor(choices, interestIDs) {\n    this.rankedChoices = {};\n    let max = 0;\n    _.forEach(choices, (choice) => {\n      const score = _.intersection(choice.interestIDs, interestIDs).length;\n      if (score > max) {\n        max = score;\n      }\n      if (!this.rankedChoices[score]) {\n        this.rankedChoices[score] = [];\n      }\n      this.rankedChoices[score].push(choice);\n    });\n    this.max = max;\n  }\n\n  /**\n   * Returns an array of the choices that best match the interestIDs.\n   * @returns {*} an array of the choices that best match the interests.\n   */\n  public getBestChoices() {\n    return this.rankedChoices[this.max];\n  }\n\n  /**\n   * Returns an array with the best matches first.\n   * @returns {Array}\n   */\n  public getOrderedChoices() {\n    let choices = [];\n    for (let i = this.max; i >= 0; i--) {\n      if (this.rankedChoices[i]) {\n        choices = choices.concat(this.rankedChoices[i]);\n      }\n    }\n    // console.log(choices);\n    return choices;\n  }\n\n  /**\n   * Returns true if there are any preferences.\n   * @return {boolean} true if max !== 0.\n   */\n  public hasPreferences() {\n    return this.max !== 0;\n  }\n}\n\nexport { PreferredChoice as default };\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/PreferredChoice.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 406,
    "kind": "class",
    "name": "PreferredChoice",
    "memberof": "api/degree-plan/PreferredChoice.ts",
    "static": true,
    "longname": "api/degree-plan/PreferredChoice.ts~PreferredChoice",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/degree-plan/PreferredChoice.ts",
    "importStyle": null,
    "description": "Class that can calculate the preferred choice given an array of interests.",
    "lineNumber": 7,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 407,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/degree-plan/PreferredChoice.ts~PreferredChoice",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/PreferredChoice.ts~PreferredChoice#constructor",
    "access": "public",
    "description": "Creates a new PreferredChoice instance given the array of choices and array of interestIDs.",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "choices",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "interestIDs",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 408,
    "kind": "member",
    "name": "rankedChoices",
    "memberof": "api/degree-plan/PreferredChoice.ts~PreferredChoice",
    "static": false,
    "longname": "api/degree-plan/PreferredChoice.ts~PreferredChoice#rankedChoices",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 409,
    "kind": "member",
    "name": "max",
    "memberof": "api/degree-plan/PreferredChoice.ts~PreferredChoice",
    "static": false,
    "longname": "api/degree-plan/PreferredChoice.ts~PreferredChoice#max",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 410,
    "kind": "method",
    "name": "getBestChoices",
    "memberof": "api/degree-plan/PreferredChoice.ts~PreferredChoice",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/PreferredChoice.ts~PreferredChoice#getBestChoices",
    "access": "public",
    "description": "Returns an array of the choices that best match the interestIDs.",
    "lineNumber": 36,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 411,
    "kind": "method",
    "name": "getOrderedChoices",
    "memberof": "api/degree-plan/PreferredChoice.ts~PreferredChoice",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/PreferredChoice.ts~PreferredChoice#getOrderedChoices",
    "access": "public",
    "description": "Returns an array with the best matches first.",
    "lineNumber": 44,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 412,
    "kind": "method",
    "name": "hasPreferences",
    "memberof": "api/degree-plan/PreferredChoice.ts~PreferredChoice",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/degree-plan/PreferredChoice.ts~PreferredChoice#hasPreferences",
    "access": "public",
    "description": "Returns true if there are any preferences.",
    "lineNumber": 59,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 413,
    "kind": "file",
    "name": "api/degree-plan/SampleAcademicPlans.ts",
    "content": "import faker from 'faker';\nimport _ from 'lodash';\nimport { makeSampleDesiredDegree } from './SampleDesiredDegrees';\nimport slugify, { Slugs } from '../slug/SlugCollection';\nimport { DesiredDegrees } from './DesiredDegreeCollection';\nimport { AcademicPlans } from './AcademicPlanCollection';\nimport { makeSampleAcademicTerm } from '../academic-term/SampleAcademicTerms';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { getRandomCourseSlugForDept, getRandomDepartment } from '../course/CourseUtilities';\n\nconst buildRandomCoursesPerTerm = () => {\n  const coursesPerAcademicTerm = [];\n  for (let i = 0; i < 12; i++) {\n    coursesPerAcademicTerm.push(faker.random.number({\n      min: 0,\n      max: 4,\n    }));\n  }\n  return coursesPerAcademicTerm;\n};\n\nexport const makeSampleCoursesPerTerm = () => buildRandomCoursesPerTerm();\n\nconst buildCourseList = (coursesPerAcademicTerm: number[]) => {\n  const numChoices = _.sum(coursesPerAcademicTerm);\n  const dept = getRandomDepartment();\n  const choiceList = [];\n  for (let i = 0; i < numChoices; i++) {\n    const slug = getRandomCourseSlugForDept(dept);\n    choiceList.push(`${slug}-1`);\n  }\n  return choiceList;\n};\n\nexport const makeSampleChoiceList = (coursesPerAcademicTerm: number[]) => buildCourseList(coursesPerAcademicTerm);\n\nexport const makeSampleAcademicPlan = () => {\n  const desiredDegreeID = makeSampleDesiredDegree({});\n  const degreeDoc = DesiredDegrees.findDoc(desiredDegreeID);\n  const name = faker.lorem.words();\n  const slug = slugify(`academic-plan-${name}`);\n  const degreeSlug = Slugs.getNameFromID(degreeDoc.slugID);\n  const description = faker.lorem.paragraph();\n  const academicTermID = makeSampleAcademicTerm();\n  const academicTerm = AcademicTerms.findSlugByID(academicTermID);\n  const coursesPerAcademicTerm = buildRandomCoursesPerTerm();\n  const choiceList = buildCourseList(coursesPerAcademicTerm);\n  return AcademicPlans.define({\n    name,\n    slug,\n    degreeSlug,\n    description,\n    academicTerm,\n    coursesPerAcademicTerm,\n    choiceList,\n  });\n};\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/SampleAcademicPlans.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 414,
    "kind": "function",
    "name": "buildRandomCoursesPerTerm",
    "memberof": "api/degree-plan/SampleAcademicPlans.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/SampleAcademicPlans.ts~buildRandomCoursesPerTerm",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/degree-plan/SampleAcademicPlans.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 415,
    "kind": "function",
    "name": "makeSampleCoursesPerTerm",
    "memberof": "api/degree-plan/SampleAcademicPlans.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/SampleAcademicPlans.ts~makeSampleCoursesPerTerm",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/SampleAcademicPlans.ts",
    "importStyle": "{makeSampleCoursesPerTerm}",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 416,
    "kind": "function",
    "name": "buildCourseList",
    "memberof": "api/degree-plan/SampleAcademicPlans.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/SampleAcademicPlans.ts~buildCourseList",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/degree-plan/SampleAcademicPlans.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "params": [
      {
        "name": "coursesPerAcademicTerm",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 417,
    "kind": "function",
    "name": "makeSampleChoiceList",
    "memberof": "api/degree-plan/SampleAcademicPlans.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/SampleAcademicPlans.ts~makeSampleChoiceList",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/SampleAcademicPlans.ts",
    "importStyle": "{makeSampleChoiceList}",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "params": [
      {
        "name": "coursesPerAcademicTerm",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 418,
    "kind": "function",
    "name": "makeSampleAcademicPlan",
    "memberof": "api/degree-plan/SampleAcademicPlans.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/SampleAcademicPlans.ts~makeSampleAcademicPlan",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/SampleAcademicPlans.ts",
    "importStyle": "{makeSampleAcademicPlan}",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 419,
    "kind": "file",
    "name": "api/degree-plan/SampleDesiredDegrees.ts",
    "content": "import faker from 'faker';\nimport moment from 'moment';\nimport { DesiredDegrees } from './DesiredDegreeCollection';\nimport slugify from '../slug/SlugCollection';\n\nexport function makeSampleDesiredDegree(args) {\n  const name = faker.lorem.words();\n  const shortName = faker.lorem.word();\n  const slug = slugify(`degree-${shortName}-${moment().format('YYYY-MM-DD-HH-mm-ss-SSSSS')}`);\n  const description = args && args.description ? args.description : faker.lorem.paragraph();\n  return DesiredDegrees.define({ name, shortName, slug, description });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/SampleDesiredDegrees.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 420,
    "kind": "function",
    "name": "makeSampleDesiredDegree",
    "memberof": "api/degree-plan/SampleDesiredDegrees.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/SampleDesiredDegrees.ts~makeSampleDesiredDegree",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/SampleDesiredDegrees.ts",
    "importStyle": "{makeSampleDesiredDegree}",
    "description": "",
    "lineNumber": 6,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "args",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 421,
    "kind": "file",
    "name": "api/degree-plan/SamplePlanChoices.ts",
    "content": "import faker from 'faker';\nimport { getRandomCourseSlugForDept, getRandomDepartment } from '../course/CourseUtilities';\n\nexport interface ImakeSinglePlanChoiceArgs {\n  dept?: string;\n  courseNum?: number;\n  choiceNum?: number;\n}\n\nexport const makeSinglePlanChoice = (args: ImakeSinglePlanChoiceArgs): string => {\n  const dept = args.dept ? args.dept : getRandomDepartment(faker.random.number({\n    min: 2,\n    max: 4,\n  }));\n  const courseNum = args.courseNum ? args.courseNum : faker.random.number({\n    min: 100,\n    max: 800,\n  });\n  const choiceNum = args.choiceNum ? args.choiceNum : faker.random.number({\n    min: 1,\n    max: 6,\n  });\n  return `${dept}_${courseNum}-${choiceNum}`;\n};\n\nexport interface ImakeSimplePlanChoice {\n  dept?: string;\n  choice1?: string;\n  choice2?: string;\n  choiceNum?: number;\n}\n\nexport const makeSimplePlanChoice = (args: ImakeSimplePlanChoice) => {\n  const dept = args.dept ? args.dept : getRandomDepartment(faker.random.number({\n    min: 2,\n    max: 4,\n  }));\n  const choice1 = args.choice1 ? args.choice1 : getRandomCourseSlugForDept(dept);\n  const choice2 = args.choice2 ? args.choice2 : getRandomCourseSlugForDept(dept);\n  const choiceNum = args.choiceNum ? args.choiceNum : faker.random.number({ min: 1, max: 6 });\n  return `${choice1},${choice2}-${choiceNum}`;\n};\n\nexport interface ImakeComplexPlanChoice {\n  dept?: string;\n  choice1?: string;\n  choice2?: string;\n  choice3?: string;\n  choice4?: string;\n  choiceNum?: number;\n}\n\nexport const makeComplexPlanChoice = (args: ImakeComplexPlanChoice) => {\n  const dept = args.dept ? args.dept : getRandomDepartment(faker.random.number({\n    min: 2,\n    max: 4,\n  }));\n  const choice1 = args.choice1 ? args.choice1 : getRandomCourseSlugForDept(dept);\n  const choice2 = args.choice2 ? args.choice2 : getRandomCourseSlugForDept(dept);\n  const choice3 = args.choice3 ? args.choice3 : getRandomCourseSlugForDept(dept);\n  const choice4 = args.choice4 ? args.choice4 : getRandomCourseSlugForDept(dept);\n  const choiceNum = args.choiceNum ? args.choiceNum : faker.random.number({ min: 1, max: 6 });\n  return `(${choice1},${choice2}),(${choice3},${choice4})-${choiceNum}`;\n};\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/SamplePlanChoices.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 422,
    "kind": "function",
    "name": "makeSinglePlanChoice",
    "memberof": "api/degree-plan/SamplePlanChoices.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/SamplePlanChoices.ts~makeSinglePlanChoice",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/SamplePlanChoices.ts",
    "importStyle": "{makeSinglePlanChoice}",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 423,
    "kind": "function",
    "name": "makeSimplePlanChoice",
    "memberof": "api/degree-plan/SamplePlanChoices.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/SamplePlanChoices.ts~makeSimplePlanChoice",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/SamplePlanChoices.ts",
    "importStyle": "{makeSimplePlanChoice}",
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 424,
    "kind": "function",
    "name": "makeComplexPlanChoice",
    "memberof": "api/degree-plan/SamplePlanChoices.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/degree-plan/SamplePlanChoices.ts~makeComplexPlanChoice",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/degree-plan/SamplePlanChoices.ts",
    "importStyle": "{makeComplexPlanChoice}",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "params": [
      {
        "name": "args",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 425,
    "kind": "file",
    "name": "api/degree-plan/index.ts",
    "content": "/** @namespace api/degree-plan */\nimport './AcademicPlanCollection';\nimport './AcademicYearInstanceCollection';\nimport './AcademicYearUtilities';\nimport './DesiredDegreeCollection';\nimport './PlanChoiceCollection';\nimport './PreferredChoice';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/degree-plan/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 426,
    "kind": "file",
    "name": "api/favorite/FavoriteAcademicPlanCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\nimport { FavoriteAcademicPlans } from './FavoriteAcademicPlanCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('FavoriteAcademicPlanCollection', function testSuite() {\n    const collectionName = FavoriteAcademicPlans.getCollectionName();\n    const student = 'abi@hawaii.edu';\n    const definitionData = {\n      academicPlan: 'bs-cs-2016',\n      student,\n    };\n    const updateData: any = { retired: true };\n\n    before(function (done) {\n      this.timeout(5000);\n      defineTestFixturesMethod.call(['minimal', 'abi.student'], done);\n    });\n\n    it('#define, #update, #removeIt Methods', async function test() {\n      await withLoggedInUser();\n      await withRadGradSubscriptions(Meteor.userId());\n      const docID = await defineMethod.callPromise({ collectionName, definitionData });\n      expect(FavoriteAcademicPlans.isDefined(docID), `define: ${docID} isDefined`).to.be.true;\n      expect(FavoriteAcademicPlans.countNonRetired()).to.equal(1);\n      updateData.id = docID;\n      await updateMethod.callPromise({ collectionName, updateData });\n      expect(FavoriteAcademicPlans.countNonRetired()).to.equal(0);\n      expect(FavoriteAcademicPlans.isDefined(docID), 'retired: isDefined').to.be.true; // still in client collection\n      await removeItMethod.callPromise({ collectionName, instance: docID });\n      expect(FavoriteAcademicPlans.countNonRetired()).to.equal(0);\n      expect(FavoriteAcademicPlans.isDefined(docID), 'removeIt: isDefined').to.be.false;\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteAcademicPlanCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 427,
    "kind": "file",
    "name": "api/favorite/FavoriteAcademicPlanCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport fc from 'fast-check';\nimport { expect } from 'chai';\nimport { FavoriteAcademicPlans } from './FavoriteAcademicPlanCollection';\nimport { makeSampleAcademicPlan } from '../degree-plan/SampleAcademicPlans';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { Slugs } from '../slug/SlugCollection';\nimport { AcademicPlans } from '../degree-plan/AcademicPlanCollection';\nimport { Users } from '../user/UserCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('FavoriteAcademicPlanCollection', function testSuite() {\n    let academicPlan;\n    let plan;\n    let student;\n    let studentFirstName;\n    let username;\n\n    before(function setup() {\n      this.timeout(5000);\n      removeAllEntities();\n      academicPlan = makeSampleAcademicPlan();\n      plan = AcademicPlans.findDoc(academicPlan);\n      student = makeSampleUser();\n      const profile = Users.getProfile(student);\n      studentFirstName = profile.firstName;\n      username = profile.username;\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1() {\n      const docID = FavoriteAcademicPlans.define({ academicPlan, student });\n      expect(FavoriteAcademicPlans.isDefined(docID)).to.be.true;\n      FavoriteAcademicPlans.removeIt(docID);\n      expect(FavoriteAcademicPlans.isDefined(docID)).to.be.false;\n    });\n\n    it('Cannot define duplicates', function test2() {\n      const docID1 = FavoriteAcademicPlans.define({ academicPlan, student });\n      const docID2 = FavoriteAcademicPlans.define({ academicPlan, student });\n      expect(docID1).to.equal(docID2);\n      expect(FavoriteAcademicPlans.isDefined(docID2)).to.be.true;\n      FavoriteAcademicPlans.removeIt(docID2);\n      expect(FavoriteAcademicPlans.isDefined(docID1)).to.be.false;\n    });\n\n    it('Can update', function test3(done) {\n      const docID = FavoriteAcademicPlans.define({ academicPlan, student });\n      expect(FavoriteAcademicPlans.isDefined(docID)).to.be.true;\n      fc.assert(\n        fc.property(fc.boolean(), (retired) => {\n          FavoriteAcademicPlans.update(docID, { retired });\n          const doc = FavoriteAcademicPlans.findDoc(docID);\n          expect(doc.retired).to.equal(retired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      let fav = FavoriteAcademicPlans.findOne({});\n      let docID = fav._id;\n      const dumpObject = FavoriteAcademicPlans.dumpOne(docID);\n      FavoriteAcademicPlans.removeIt(docID);\n      expect(FavoriteAcademicPlans.isDefined(docID)).to.be.false;\n      docID = FavoriteAcademicPlans.restoreOne(dumpObject);\n      expect(FavoriteAcademicPlans.isDefined(docID)).to.be.true;\n      fav = FavoriteAcademicPlans.findDoc(docID);\n      expect(fav.studentID).to.equal(student);\n      expect(fav.academicPlanID).to.equal(academicPlan);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const errors = FavoriteAcademicPlans.checkIntegrity();\n      expect(errors).to.have.lengthOf(0);\n    });\n\n    it('Can get docs and slug', function test6() {\n      const docID = FavoriteAcademicPlans.define({ academicPlan, student });\n      const academicPlanDoc = FavoriteAcademicPlans.getAcademicPlanDoc(docID);\n      expect(academicPlanDoc).to.exist;\n      expect(academicPlanDoc.name).to.equal(plan.name);\n      const academicPlanSlug = Slugs.getNameFromID(academicPlanDoc.slugID);\n      expect(FavoriteAcademicPlans.getAcademicPlanSlug(docID)).to.equal(academicPlanSlug);\n      const studentDoc = FavoriteAcademicPlans.getStudentDoc(docID);\n      expect(studentDoc).to.exist;\n      expect(studentDoc.firstName).to.equal(studentFirstName);\n      const studentUsername = FavoriteAcademicPlans.getStudentUsername(docID);\n      expect(studentUsername.startsWith('student')).to.be.true;\n      expect(studentUsername).to.equal(username);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteAcademicPlanCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 428,
    "kind": "file",
    "name": "api/favorite/FavoriteAcademicPlanCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport _ from 'lodash';\nimport { ReactiveAggregate } from 'meteor/jcbernack:reactive-aggregate';\nimport BaseCollection from '../base/BaseCollection';\nimport { AcademicPlans } from '../degree-plan/AcademicPlanCollection';\nimport { Users } from '../user/UserCollection';\nimport { ROLE } from '../role/Role';\nimport { IFavoriteAcademicPlanDefine, IFavoriteUpdate } from '../../typings/radgrad';\n\nclass FavoriteAcademicPlanCollection extends BaseCollection {\n  public readonly publicationNames: {\n    scoreboard: string;\n  }\n\n  /** Creates the FavoriteAcademicPlan collection */\n  constructor() {\n    super('FavoriteAcademicPlan', new SimpleSchema({\n      academicPlanID: SimpleSchema.RegEx.Id,\n      studentID: SimpleSchema.RegEx.Id,\n      retired: { type: Boolean, optional: true },\n    }));\n    this.publicationNames = {\n      scoreboard: `${this.collectionName}.scoreboard`,\n    };\n  }\n\n  /**\n   * Defines a new FavoriteAcademicPlan.\n   * @param academicPlan the academicPlan slug.\n   * @param student the student's username.\n   * @param retired the retired status.\n   * @returns {void|*|boolean|{}}\n   */\n  define({ academicPlan, student, retired = false }: IFavoriteAcademicPlanDefine): string {\n    const academicPlanID = AcademicPlans.getID(academicPlan);\n    const studentID = Users.getID(student);\n    const doc = this.collection.findOne({ studentID, academicPlanID });\n    if (doc) {\n      return doc._id;\n    }\n    return this.collection.insert({ academicPlanID, studentID, retired });\n  }\n\n  /**\n   * Updates the retired status.\n   * @param docID the ID of the FavoriteAcademicPlan.\n   * @param retired the new retired value.\n   */\n  update(docID, { retired }) {\n    this.assertDefined(docID);\n    const updateData: IFavoriteUpdate = {};\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the FavoriteAcademicPlan.\n   * @param docID The docID of the FavoriteAcademicPlan.\n   */\n  removeIt(docID: string) {\n    this.assertDefined(docID);\n    // OK, clear to delete.\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Removes all the FavoriteAcademicPlans for the user.\n   * @param user the username.\n   */\n  removeUser(user: string) {\n    const studentID = Users.getID(user);\n    this.collection.remove({ studentID });\n  }\n\n  /**\n   * Publish AcademicPlanFavorites. If logged in as ADMIN get all, otherwise only get the AcademicPlanFavorites for the\n   * studentID.\n   * Also publishes the AcademicPlanFavorites scoreboard.\n   */\n  publish() {\n    if (Meteor.isServer) {\n      const instance = this;\n      Meteor.publish(this.collectionName, function filterStudentID(studentID) { // eslint-disable-line meteor/audit-argument-checks\n        if (_.isNil(studentID)) {\n          return this.ready();\n        }\n        const profile = Users.getProfile(studentID);\n        if (_.includes([ROLE.ADMIN, ROLE.ADVISOR], profile.role)) {\n          return instance.collection.find();\n        }\n        return instance.collection.find({ studentID });\n      });\n      Meteor.publish(this.publicationNames.scoreboard, function publishAcademicPlanScoreboard() {\n        ReactiveAggregate(this, instance.collection, [\n          {\n            $group: {\n              _id: '$academicPlanID',\n              count: { $sum: 1 },\n            },\n          },\n          { $project: { count: 1, academicPlanID: 1 } },\n        ], { clientCollection: 'AcademicPlanFavoritesScoreboard' });\n      });\n    }\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\n   * Student.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  assertValidRoleForMethod(userId) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.STUDENT]);\n  }\n\n  /**\n   * Returns the AcademicPlan associated with the FavoriteAcademicPlan with the given instanceID.\n   * @param instanceID The id of the AcademicPlanInstance.\n   * @returns {Object} The associated AcademicPlan.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  getAcademicPlanDoc(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return AcademicPlans.findDoc(instance.academicPlanID);\n  }\n\n  /**\n   * Returns the AcademicPlan slug for the favorite's corresponding AcademicPlan.\n   * @param instanceID The FavoriteAcademicPlan ID.\n   * @return {string} The academicPlan slug.\n   */\n  getAcademicPlanSlug(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return AcademicPlans.findSlugByID(instance.academicPlanID);\n  }\n\n  /**\n   * Returns the Student profile associated with the FavoriteAcademicPlan with the given instanceID.\n   * @param instanceID The ID of the FavoriteAcademicPlan.\n   * @returns {Object} The associated Student profile.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  getStudentDoc(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Users.getProfile(instance.studentID);\n  }\n\n  /**\n   * Returns the username associated with the studentID.\n   * @param instanceID the FavoriteAcademicPlan id.\n   * @returns {*}\n   */\n  getStudentUsername(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Users.getProfile(instance.studentID).username;\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks semesterID, academicPlanID, and studentID.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  checkIntegrity() {\n    const problems = [];\n    this.find()\n      .forEach(doc => {\n        if (!AcademicPlans.isDefined(doc.academicPlanID)) {\n          problems.push(`Bad academicPlanID: ${doc.academicPlanID}`);\n        }\n        if (!Users.isDefined(doc.studentID)) {\n          problems.push(`Bad studentID: ${doc.studentID}`);\n        }\n      });\n     return problems;\n  }\n\n  /**\n   * Returns an object representing the FavoriteAcademicPlan docID in a format acceptable to define().\n   * @param docID The docID of a FavoriteAcademicPlan.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  dumpOne(docID): IFavoriteAcademicPlanDefine {\n    const doc = this.findDoc(docID);\n    const academicPlan = AcademicPlans.findSlugByID(doc.academicPlanID);\n    const student = Users.getProfile(doc.studentID).username;\n    const retired = doc.retired;\n    return { academicPlan, student, retired };\n  }\n\n}\n\nexport const FavoriteAcademicPlans = new FavoriteAcademicPlanCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteAcademicPlanCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 429,
    "kind": "variable",
    "name": "FavoriteAcademicPlans",
    "memberof": "api/favorite/FavoriteAcademicPlanCollection.ts",
    "static": true,
    "longname": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlans",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/favorite/FavoriteAcademicPlanCollection.ts",
    "importStyle": "{FavoriteAcademicPlans}",
    "description": null,
    "lineNumber": 227,
    "undocument": true,
    "type": {
      "types": [
        "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection"
      ]
    }
  },
  {
    "__docId__": 430,
    "kind": "class",
    "name": "FavoriteAcademicPlanCollection",
    "memberof": "api/favorite/FavoriteAcademicPlanCollection.ts",
    "static": true,
    "longname": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/favorite/FavoriteAcademicPlanCollection.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 11,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 431,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection#constructor",
    "access": "public",
    "description": "Creates the FavoriteAcademicPlan collection",
    "lineNumber": 17
  },
  {
    "__docId__": 432,
    "kind": "member",
    "name": "publicationNames",
    "memberof": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection",
    "static": false,
    "longname": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection#publicationNames",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "{\"scoreboard\": *}"
      ]
    }
  },
  {
    "__docId__": 433,
    "kind": "method",
    "name": "define",
    "memberof": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection#define",
    "access": "public",
    "description": "Defines a new FavoriteAcademicPlan.",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "IFavoriteAcademicPlanDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 434,
    "kind": "method",
    "name": "update",
    "memberof": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection#update",
    "access": "public",
    "description": "Updates the retired status.",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 435,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection#removeIt",
    "access": "public",
    "description": "Remove the FavoriteAcademicPlan.",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 436,
    "kind": "method",
    "name": "removeUser",
    "memberof": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection#removeUser",
    "access": "public",
    "description": "Removes all the FavoriteAcademicPlans for the user.",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 437,
    "kind": "method",
    "name": "publish",
    "memberof": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection#publish",
    "access": "public",
    "description": "Publish AcademicPlanFavorites. If logged in as ADMIN get all, otherwise only get the AcademicPlanFavorites for the\nstudentID.\nAlso publishes the AcademicPlanFavorites scoreboard.",
    "lineNumber": 83,
    "params": [],
    "return": null
  },
  {
    "__docId__": 438,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\nStudent.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 117,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 439,
    "kind": "method",
    "name": "getAcademicPlanDoc",
    "memberof": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection#getAcademicPlanDoc",
    "access": "public",
    "description": "Returns the AcademicPlan associated with the FavoriteAcademicPlan with the given instanceID.",
    "lineNumber": 127,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 440,
    "kind": "method",
    "name": "getAcademicPlanSlug",
    "memberof": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection#getAcademicPlanSlug",
    "access": "public",
    "description": "Returns the AcademicPlan slug for the favorite's corresponding AcademicPlan.",
    "lineNumber": 138,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 441,
    "kind": "method",
    "name": "getStudentDoc",
    "memberof": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection#getStudentDoc",
    "access": "public",
    "description": "Returns the Student profile associated with the FavoriteAcademicPlan with the given instanceID.",
    "lineNumber": 150,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 442,
    "kind": "method",
    "name": "getStudentUsername",
    "memberof": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection#getStudentUsername",
    "access": "public",
    "description": "Returns the username associated with the studentID.",
    "lineNumber": 161,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 443,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks semesterID, academicPlanID, and studentID.",
    "lineNumber": 173,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 444,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteAcademicPlanCollection.ts~FavoriteAcademicPlanCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the FavoriteAcademicPlan docID in a format acceptable to define().",
    "lineNumber": 192,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IFavoriteAcademicPlanDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 445,
    "kind": "file",
    "name": "api/favorite/FavoriteCareerGoalCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\nimport { FavoriteCareerGoals } from './FavoriteCareerGoalCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('FavoriteCareerGoalCollection', function testSuite() {\n    const collectionName = FavoriteCareerGoals.getCollectionName();\n    const definitionData = {\n      careerGoal: 'data-scientist',\n      username: 'abi@hawaii.edu',\n    };\n    const updateData: any = { retired: true };\n\n    before(function (done) {\n      this.timeout(5000);\n      defineTestFixturesMethod.call(['minimal', 'abi.student'], done);\n    });\n\n    it('#define, #update, #removeIt Methods', async function test() {\n      await withLoggedInUser();\n      await withRadGradSubscriptions(Meteor.userId());\n      const docID = await defineMethod.callPromise({ collectionName, definitionData });\n      expect(FavoriteCareerGoals.isDefined(docID), 'define: isDefined').to.be.true;\n      expect(FavoriteCareerGoals.countNonRetired()).to.equal(1);\n      updateData.id = docID;\n      await updateMethod.callPromise({ collectionName, updateData });\n      expect(FavoriteCareerGoals.countNonRetired()).to.equal(0);\n      expect(FavoriteCareerGoals.isDefined(docID), 'retired: isDefined').to.be.true; // still in client collection\n      await removeItMethod.callPromise({ collectionName, instance: docID });\n      expect(FavoriteCareerGoals.countNonRetired()).to.equal(0);\n      expect(FavoriteCareerGoals.isDefined(docID), 'removeIt: isDefined').to.be.false;\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteCareerGoalCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 446,
    "kind": "file",
    "name": "api/favorite/FavoriteCareerGoalCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport { FavoriteCareerGoals } from './FavoriteCareerGoalCollection';\nimport { makeSampleCareerGoal } from '../career/SampleCareerGoals';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { Slugs } from '../slug/SlugCollection';\nimport { Users } from '../user/UserCollection';\nimport { CareerGoals } from '../career/CareerGoalCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('FavoriteCareerGoalCollection', function testSuite() {\n    let careerGoal;\n    let userID;\n    let username;\n    let firstName;\n    let careerGoalName;\n\n    before(function setup() {\n      this.timeout(5000);\n      removeAllEntities();\n      careerGoal = makeSampleCareerGoal();\n      careerGoalName = CareerGoals.findDoc(careerGoal).name;\n      userID = makeSampleUser();\n      const profile = Users.getProfile(userID);\n      username = profile.username;\n      firstName = profile.firstName;\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1() {\n      const docID = FavoriteCareerGoals.define({ careerGoal, username });\n      expect(FavoriteCareerGoals.isDefined(docID)).to.be.true;\n      FavoriteCareerGoals.removeIt(docID);\n      expect(FavoriteCareerGoals.isDefined(docID)).to.be.false;\n    });\n\n    it('Cannot define duplicates', function test2() {\n      const docID1 = FavoriteCareerGoals.define({ careerGoal, username });\n      const docID2 = FavoriteCareerGoals.define({ careerGoal, username });\n      expect(docID1).to.equal(docID2);\n      expect(FavoriteCareerGoals.isDefined(docID2)).to.be.true;\n      FavoriteCareerGoals.removeIt(docID1);\n      expect(FavoriteCareerGoals.isDefined(docID2)).to.be.false;\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      const docID = FavoriteCareerGoals.define({ careerGoal, username });\n      fc.assert(\n        fc.property(fc.boolean(), (retired) => {\n          FavoriteCareerGoals.update(docID, { retired });\n          const fav = FavoriteCareerGoals.findDoc(docID);\n          expect(fav.retired).to.equal(retired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      let fav = FavoriteCareerGoals.findOne({});\n      let docID = fav._id;\n      const dumpObject = FavoriteCareerGoals.dumpOne(docID);\n      FavoriteCareerGoals.removeIt(docID);\n      expect(FavoriteCareerGoals.isDefined(docID)).to.be.false;\n      docID = FavoriteCareerGoals.restoreOne(dumpObject);\n      fav = FavoriteCareerGoals.findDoc(docID);\n      expect(fav.userID).to.equal(userID);\n      expect(fav.careerGoalID).to.equal(careerGoal);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const errors = FavoriteCareerGoals.checkIntegrity();\n      expect(errors).to.have.lengthOf(0);\n    });\n\n    it('Can get docs and slug', function test6() {\n      const docID = FavoriteCareerGoals.define({ careerGoal, username });\n      const careerGoalDoc = FavoriteCareerGoals.getCareerGoalDoc(docID);\n      expect(careerGoalDoc).to.exist;\n      expect(careerGoalDoc.name).to.equal(careerGoalName);\n      const careerGoalSlug = Slugs.getNameFromID(careerGoalDoc.slugID);\n      expect(FavoriteCareerGoals.getCareerGoalSlug(docID)).to.equal(careerGoalSlug);\n      const studentDoc = FavoriteCareerGoals.getStudentDoc(docID);\n      expect(studentDoc).to.exist;\n      expect(studentDoc.firstName).to.equal(firstName);\n      const studentUsername = FavoriteCareerGoals.getStudentUsername(docID);\n      expect(studentUsername.startsWith('student')).to.be.true;\n      expect(studentUsername).to.equal(username);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteCareerGoalCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 447,
    "kind": "file",
    "name": "api/favorite/FavoriteCareerGoalCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport _ from 'lodash';\nimport { ReactiveAggregate } from 'meteor/jcbernack:reactive-aggregate';\nimport BaseCollection from '../base/BaseCollection';\nimport { CareerGoals } from '../career/CareerGoalCollection';\nimport { Users } from '../user/UserCollection';\nimport { IFavoriteCareerGoalDefine, IFavoriteUpdate } from '../../typings/radgrad';\nimport { ROLE } from '../role/Role';\n\nclass FavoriteCareerGoalCollection extends BaseCollection {\n  public readonly publicationNames: {\n    scoreboard: string;\n  };\n\n  /** Creates the FavoriteCareerGoal collection */\n  constructor() {\n    super('FavoriteCareerGoal', new SimpleSchema({\n      careerGoalID: SimpleSchema.RegEx.Id,\n      userID: SimpleSchema.RegEx.Id,\n      retired: { type: Boolean, optional: true },\n    }));\n    this.publicationNames = {\n      scoreboard: `${this.collectionName}.scoreboard`,\n    };\n  }\n\n  /**\n   * Defines a new FavoriteCareerGoal.\n   * @param careerGoal the careerGoal slug.\n   * @param username the user's username.\n   * @param retired the retired status.\n   * @returns {void|*|boolean|{}}\n   */\n  define({ careerGoal, username, retired = false }: IFavoriteCareerGoalDefine) {\n    const careerGoalID = CareerGoals.getID(careerGoal);\n    const userID = Users.getID(username);\n    const doc = this.collection.findOne({ userID, careerGoalID });\n    if (doc) {\n      return doc._id;\n    }\n    return this.collection.insert({ careerGoalID, userID, retired });\n  }\n\n  /**\n   * Updates the retired status.\n   * @param docID the ID of the FavoriteCareerGoal.\n   * @param retired the new retired value.\n   */\n  update(docID, { retired }) {\n    this.assertDefined(docID);\n    const updateData: IFavoriteUpdate = {};\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the FavoriteCareerGoal.\n   * @param docID The docID of the FavoriteCareerGoal.\n   */\n  removeIt(docID) {\n    this.assertDefined(docID);\n    // OK, clear to delete.\n   return super.removeIt(docID);\n  }\n\n  /**\n   * Removes all the FavoriteCareerGoals for the user.\n   * @param user the username.\n   */\n  removeUser(user) {\n    const userID = Users.getID(user);\n    this.collection.remove({ userID });\n  }\n\n  /**\n   * Publish CareerGoalFavorites. If logged in as ADMIN get all, otherwise only get the CareerGoalFavorites for the\n   * userID.\n   * Also publishes the CareerGoalFavorites scoreboard.\n   */\n  publish() {\n    if (Meteor.isServer) {\n      const instance = this;\n      Meteor.publish(this.collectionName, function filterStudentID(userID) { // eslint-disable-line meteor/audit-argument-checks\n        if (_.isNil(userID)) {\n          return this.ready();\n        }\n        const profile = Users.getProfile(userID);\n        if (_.includes([ROLE.ADMIN, ROLE.ADVISOR], profile.role)) {\n          return instance.collection.find();\n        }\n        return instance.collection.find({ userID });\n      });\n      Meteor.publish(this.publicationNames.scoreboard, function publishCareerGoalScoreboard() {\n        ReactiveAggregate(this, instance.collection, [\n          {\n            $group: {\n              _id: '$careerGoalID',\n              count: { $sum: 1 },\n            },\n          },\n          { $project: { count: 1, careerGoalID: 1 } },\n        ], { clientCollection: 'CareerGoalFavoritesScoreboard' });\n      });\n    }\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\n   * Student.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  assertValidRoleForMethod(userId) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.FACULTY, ROLE.MENTOR, ROLE.STUDENT]);\n  }\n\n  /**\n   * Returns the CareerGoal associated with the FavoriteCareerGoal with the given instanceID.\n   * @param instanceID The id of the CareerGoalInstance.\n   * @returns {Object} The associated CareerGoal.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  getCareerGoalDoc(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return CareerGoals.findDoc(instance.careerGoalID);\n  }\n\n  /**\n   * Returns the CareerGoal slug for the favorite's corresponding CareerGoal.\n   * @param instanceID The FavoriteCareerGoal ID.\n   * @return {string} The careerGoal slug.\n   */\n  getCareerGoalSlug(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return CareerGoals.findSlugByID(instance.careerGoalID);\n  }\n\n  /**\n   * Returns the Student profile associated with the FavoriteCareerGoal with the given instanceID.\n   * @param instanceID The ID of the FavoriteCareerGoal.\n   * @returns {Object} The associated Student profile.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  getStudentDoc(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Users.getProfile(instance.userID);\n  }\n\n  /**\n   * Returns the username associated with the userID.\n   * @param instanceID the FavoriteCareerGoal id.\n   * @returns {*}\n   */\n  getStudentUsername(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Users.getProfile(instance.userID).username;\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks semesterID, careerGoalID, and userID.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  checkIntegrity() {\n    const problems = [];\n    this.find()\n      .forEach(doc => {\n        if (!CareerGoals.isDefined(doc.careerGoalID)) {\n          problems.push(`Bad careerGoalID: ${doc.careerGoalID}`);\n        }\n        if (!Users.isDefined(doc.userID)) {\n          problems.push(`Bad userID: ${doc.userID}`);\n        }\n      });\n     return problems;\n  }\n\n  /**\n   * Returns an object representing the FavoriteAcademicPlan docID in a format acceptable to define().\n   * @param docID The docID of a FavoriteAcademicPlan.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  dumpOne(docID): IFavoriteCareerGoalDefine {\n    const doc = this.findDoc(docID);\n    const careerGoal = CareerGoals.findSlugByID(doc.careerGoalID);\n    const username = Users.getProfile(doc.userID).username;\n    const retired = doc.retired;\n    return { careerGoal, username, retired };\n  }\n\n}\n\nexport const FavoriteCareerGoals = new FavoriteCareerGoalCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteCareerGoalCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 448,
    "kind": "variable",
    "name": "FavoriteCareerGoals",
    "memberof": "api/favorite/FavoriteCareerGoalCollection.ts",
    "static": true,
    "longname": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoals",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/favorite/FavoriteCareerGoalCollection.ts",
    "importStyle": "{FavoriteCareerGoals}",
    "description": null,
    "lineNumber": 225,
    "undocument": true,
    "type": {
      "types": [
        "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection"
      ]
    }
  },
  {
    "__docId__": 449,
    "kind": "class",
    "name": "FavoriteCareerGoalCollection",
    "memberof": "api/favorite/FavoriteCareerGoalCollection.ts",
    "static": true,
    "longname": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/favorite/FavoriteCareerGoalCollection.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 11,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 450,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection#constructor",
    "access": "public",
    "description": "Creates the FavoriteCareerGoal collection",
    "lineNumber": 17
  },
  {
    "__docId__": 451,
    "kind": "member",
    "name": "publicationNames",
    "memberof": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection",
    "static": false,
    "longname": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection#publicationNames",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "{\"scoreboard\": *}"
      ]
    }
  },
  {
    "__docId__": 452,
    "kind": "method",
    "name": "define",
    "memberof": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection#define",
    "access": "public",
    "description": "Defines a new FavoriteCareerGoal.",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "IFavoriteCareerGoalDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 453,
    "kind": "method",
    "name": "update",
    "memberof": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection#update",
    "access": "public",
    "description": "Updates the retired status.",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 454,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection#removeIt",
    "access": "public",
    "description": "Remove the FavoriteCareerGoal.",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 455,
    "kind": "method",
    "name": "removeUser",
    "memberof": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection#removeUser",
    "access": "public",
    "description": "Removes all the FavoriteCareerGoals for the user.",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 456,
    "kind": "method",
    "name": "publish",
    "memberof": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection#publish",
    "access": "public",
    "description": "Publish CareerGoalFavorites. If logged in as ADMIN get all, otherwise only get the CareerGoalFavorites for the\nuserID.\nAlso publishes the CareerGoalFavorites scoreboard.",
    "lineNumber": 83,
    "params": [],
    "return": null
  },
  {
    "__docId__": 457,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\nStudent.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 117,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 458,
    "kind": "method",
    "name": "getCareerGoalDoc",
    "memberof": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection#getCareerGoalDoc",
    "access": "public",
    "description": "Returns the CareerGoal associated with the FavoriteCareerGoal with the given instanceID.",
    "lineNumber": 127,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 459,
    "kind": "method",
    "name": "getCareerGoalSlug",
    "memberof": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection#getCareerGoalSlug",
    "access": "public",
    "description": "Returns the CareerGoal slug for the favorite's corresponding CareerGoal.",
    "lineNumber": 138,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 460,
    "kind": "method",
    "name": "getStudentDoc",
    "memberof": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection#getStudentDoc",
    "access": "public",
    "description": "Returns the Student profile associated with the FavoriteCareerGoal with the given instanceID.",
    "lineNumber": 150,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 461,
    "kind": "method",
    "name": "getStudentUsername",
    "memberof": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection#getStudentUsername",
    "access": "public",
    "description": "Returns the username associated with the userID.",
    "lineNumber": 161,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 462,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks semesterID, careerGoalID, and userID.",
    "lineNumber": 173,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 463,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCareerGoalCollection.ts~FavoriteCareerGoalCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the FavoriteAcademicPlan docID in a format acceptable to define().",
    "lineNumber": 192,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IFavoriteCareerGoalDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 464,
    "kind": "file",
    "name": "api/favorite/FavoriteCourseCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\nimport { FavoriteCourses } from './FavoriteCourseCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('FavoriteCourseCollection', function testSuite() {\n    const collectionName = FavoriteCourses.getCollectionName();\n    const definitionData = {\n      course: 'ics_141',\n      student: 'abi@hawaii.edu',\n    };\n    const updateData: any = { retired: true };\n\n    before(function (done) {\n      this.timeout(5000);\n      defineTestFixturesMethod.call(['minimal', 'abi.student'], done);\n    });\n\n    it('#define, #update, #removeIt Methods', async function test() {\n      await withLoggedInUser();\n      await withRadGradSubscriptions(Meteor.userId());\n      const docID = await defineMethod.callPromise({ collectionName, definitionData });\n      expect(FavoriteCourses.isDefined(docID), 'define: isDefined').to.be.true;\n      expect(FavoriteCourses.countNonRetired()).to.equal(1);\n      updateData.id = docID;\n      await updateMethod.callPromise({ collectionName, updateData });\n      expect(FavoriteCourses.countNonRetired()).to.equal(0);\n      expect(FavoriteCourses.isDefined(docID), 'retired: isDefined').to.be.true; // still in client collection\n      await removeItMethod.callPromise({ collectionName, instance: docID });\n      expect(FavoriteCourses.countNonRetired()).to.equal(0);\n      expect(FavoriteCourses.isDefined(docID), 'removeIt: isDefined').to.be.false;\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteCourseCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 465,
    "kind": "file",
    "name": "api/favorite/FavoriteCourseCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport { FavoriteCourses } from './FavoriteCourseCollection';\nimport { makeSampleCourse } from '../course/SampleCourses';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { Slugs } from '../slug/SlugCollection';\nimport { Users } from '../user/UserCollection';\nimport { Courses } from '../course/CourseCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('FavoriteCourseCollection', function testSuite() {\n    let course;\n    let courseName;\n    let student;\n    let firstName;\n\n    before(function setup() {\n      this.timeout(5000);\n      removeAllEntities();\n      course = makeSampleCourse();\n      courseName = Courses.findDoc(course).name;\n      student = makeSampleUser();\n      firstName = Users.getProfile(student).firstName;\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1() {\n      const docID = FavoriteCourses.define({ course, student });\n      expect(FavoriteCourses.isDefined(docID)).to.be.true;\n      FavoriteCourses.removeIt(docID);\n      expect(FavoriteCourses.isDefined(docID)).to.be.false;\n    });\n\n    it('Cannot define duplicates', function test2() {\n      const docID1 = FavoriteCourses.define({ course, student });\n      const docID2 = FavoriteCourses.define({ course, student });\n      expect(docID1).to.equal(docID2);\n      expect(FavoriteCourses.isDefined(docID1)).to.be.true;\n      FavoriteCourses.removeIt(docID2);\n      expect(FavoriteCourses.isDefined(docID1)).to.be.false;\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      const docID = FavoriteCourses.define({ course, student });\n      fc.assert(\n        fc.property(fc.boolean(), (retired) => {\n          FavoriteCourses.update(docID, { retired });\n          const fav = FavoriteCourses.findDoc(docID);\n          expect(fav.retired).to.equal(retired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      let fav = FavoriteCourses.findOne({});\n      let docID = fav._id;\n      const dumbObject = FavoriteCourses.dumpOne(docID);\n      FavoriteCourses.removeIt(docID);\n      expect(FavoriteCourses.isDefined(docID)).to.be.false;\n      docID = FavoriteCourses.restoreOne(dumbObject);\n      fav = FavoriteCourses.findDoc(docID);\n      expect(fav.studentID).to.equal(student);\n      expect(fav.courseID).to.equal(course);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const errors = FavoriteCourses.checkIntegrity();\n      expect(errors).to.have.lengthOf(0);\n    });\n\n    it('Can get docs and slug', function test6() {\n      const docID = FavoriteCourses.define({ course, student });\n      const courseDoc = FavoriteCourses.getCourseDoc(docID);\n      expect(courseDoc).to.exist;\n      expect(courseDoc.name).to.equal(courseName);\n      const courseSlug = Slugs.getNameFromID(courseDoc.slugID);\n      expect(FavoriteCourses.getCourseSlug(docID)).to.equal(courseSlug);\n      const studentDoc = FavoriteCourses.getStudentDoc(docID);\n      expect(studentDoc).to.exist;\n      expect(studentDoc.firstName).to.equal(firstName);\n      const studentUsername = FavoriteCourses.getStudentUsername(docID);\n      expect(studentUsername.startsWith('student')).to.be.true;\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteCourseCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 466,
    "kind": "file",
    "name": "api/favorite/FavoriteCourseCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport _ from 'lodash';\nimport { ReactiveAggregate } from 'meteor/jcbernack:reactive-aggregate';\nimport BaseCollection from '../base/BaseCollection';\nimport { Courses } from '../course/CourseCollection';\nimport { Users } from '../user/UserCollection';\nimport { ROLE } from '../role/Role';\nimport { IFavoriteCourseDefine, IFavoriteUpdate } from '../../typings/radgrad';\n\nclass FavoriteCourseCollection extends BaseCollection {\n  public readonly publicationNames: {\n    scoreboard: string;\n  }\n\n  /** Creates the FavoriteCourse collection */\n  constructor() {\n    super('FavoriteCourse', new SimpleSchema({\n      courseID: SimpleSchema.RegEx.Id,\n      studentID: SimpleSchema.RegEx.Id,\n      retired: { type: Boolean, optional: true },\n    }));\n    this.publicationNames = {\n      scoreboard: `${this.collectionName}.scoreboard`,\n    };\n  }\n\n  /**\n   * Defines a new FavoriteCourse.\n   * @param course the course slug.\n   * @param student the student's username.\n   * @param retired the retired status.\n   * @returns {void|*|boolean|{}}\n   */\n  define({ course, student, retired = false }) {\n    const courseID = Courses.getID(course);\n    const studentID = Users.getID(student);\n    const doc = this.collection.findOne({ studentID, courseID });\n    if (doc) {\n      return doc._id;\n    }\n    return this.collection.insert({ courseID, studentID, retired });\n  }\n\n  /**\n   * Updates the retired status.\n   * @param docID the ID of the FavoriteCourse.\n   * @param retired the new retired value.\n   */\n  update(docID, { retired }) {\n    this.assertDefined(docID);\n    const updateData: IFavoriteUpdate = {};\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the FavoriteCourse.\n   * @param docID The docID of the FavoriteCourse.\n   */\n  removeIt(docID) {\n    this.assertDefined(docID);\n    // OK, clear to delete.\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Removes all the FavoriteCourses for the user.\n   * @param user the username.\n   */\n  removeUser(user) {\n    const studentID = Users.getID(user);\n    this.collection.remove({ studentID });\n  }\n\n  /**\n   * Publish CourseFavorites. If logged in as ADMIN get all, otherwise only get the CourseFavorites for the studentID.\n   * Also publishes the CourseFavorites scoreboard.\n   */\n  publish() {\n    if (Meteor.isServer) {\n      const instance = this;\n      Meteor.publish(this.collectionName, function filterStudentID(studentID) { // eslint-disable-line meteor/audit-argument-checks\n        if (_.isNil(studentID)) {\n          return this.ready();\n        }\n        const profile = Users.getProfile(studentID);\n        if (_.includes([ROLE.ADMIN, ROLE.ADVISOR], profile.role)) {\n          return instance.collection.find();\n        }\n        return instance.collection.find({ studentID });\n      });\n      Meteor.publish(this.publicationNames.scoreboard, function publishCourseScoreboard() {\n        ReactiveAggregate(this, instance.collection, [\n          {\n            $group: {\n              _id: '$courseID',\n              count: { $sum: 1 },\n            },\n          },\n          { $project: { count: 1, courseID: 1 } },\n        ], { clientCollection: 'CourseFavoritesScoreboard' });\n      });\n    }\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\n   * Student.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  assertValidRoleForMethod(userId) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.STUDENT]);\n  }\n\n  /**\n   * Returns the Course associated with the FavoriteCourse with the given instanceID.\n   * @param instanceID The id of the CourseInstance.\n   * @returns {Object} The associated Course.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  getCourseDoc(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Courses.findDoc(instance.courseID);\n  }\n\n  /**\n   * Returns the Course slug for the favorite's corresponding Course.\n   * @param instanceID The FavoriteCourse ID.\n   * @return {string} The course slug.\n   */\n  getCourseSlug(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Courses.findSlugByID(instance.courseID);\n  }\n\n  /**\n   * Returns the Student profile associated with the FavoriteCourse with the given instanceID.\n   * @param instanceID The ID of the FavoriteCourse.\n   * @returns {Object} The associated Student profile.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  getStudentDoc(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Users.getProfile(instance.studentID);\n  }\n\n  /**\n   * Returns the username associated with the studentID.\n   * @param instanceID the FavoriteCourse id.\n   * @returns {*}\n   */\n  getStudentUsername(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Users.getProfile(instance.studentID).username;\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks semesterID, courseID, and studentID.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  checkIntegrity() {\n    const problems = [];\n    this.find()\n      .forEach(doc => {\n        if (!Courses.isDefined(doc.courseID)) {\n          problems.push(`Bad courseID: ${doc.courseID}`);\n        }\n        if (!Users.isDefined(doc.studentID)) {\n          problems.push(`Bad studentID: ${doc.studentID}`);\n        }\n      });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the FavoriteCourse docID in a format acceptable to define().\n   * @param docID The docID of a FavoriteCourse.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  dumpOne(docID): IFavoriteCourseDefine {\n    const doc = this.findDoc(docID);\n    const course = Courses.findSlugByID(doc.courseID);\n    const student = Users.getProfile(doc.studentID).username;\n    const retired = doc.retired;\n    return { course, student, retired };\n  }\n\n}\n\nexport const FavoriteCourses = new FavoriteCourseCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteCourseCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 467,
    "kind": "variable",
    "name": "FavoriteCourses",
    "memberof": "api/favorite/FavoriteCourseCollection.ts",
    "static": true,
    "longname": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourses",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/favorite/FavoriteCourseCollection.ts",
    "importStyle": "{FavoriteCourses}",
    "description": null,
    "lineNumber": 224,
    "undocument": true,
    "type": {
      "types": [
        "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection"
      ]
    }
  },
  {
    "__docId__": 468,
    "kind": "class",
    "name": "FavoriteCourseCollection",
    "memberof": "api/favorite/FavoriteCourseCollection.ts",
    "static": true,
    "longname": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/favorite/FavoriteCourseCollection.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 11,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 469,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection#constructor",
    "access": "public",
    "description": "Creates the FavoriteCourse collection",
    "lineNumber": 17
  },
  {
    "__docId__": 470,
    "kind": "member",
    "name": "publicationNames",
    "memberof": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection",
    "static": false,
    "longname": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection#publicationNames",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "{\"scoreboard\": *}"
      ]
    }
  },
  {
    "__docId__": 471,
    "kind": "method",
    "name": "define",
    "memberof": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection#define",
    "access": "public",
    "description": "Defines a new FavoriteCourse.",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 472,
    "kind": "method",
    "name": "update",
    "memberof": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection#update",
    "access": "public",
    "description": "Updates the retired status.",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 473,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection#removeIt",
    "access": "public",
    "description": "Remove the FavoriteCourse.",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 474,
    "kind": "method",
    "name": "removeUser",
    "memberof": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection#removeUser",
    "access": "public",
    "description": "Removes all the FavoriteCourses for the user.",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 475,
    "kind": "method",
    "name": "publish",
    "memberof": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection#publish",
    "access": "public",
    "description": "Publish CourseFavorites. If logged in as ADMIN get all, otherwise only get the CourseFavorites for the studentID.\nAlso publishes the CourseFavorites scoreboard.",
    "lineNumber": 82,
    "params": [],
    "return": null
  },
  {
    "__docId__": 476,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\nStudent.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 477,
    "kind": "method",
    "name": "getCourseDoc",
    "memberof": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection#getCourseDoc",
    "access": "public",
    "description": "Returns the Course associated with the FavoriteCourse with the given instanceID.",
    "lineNumber": 126,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 478,
    "kind": "method",
    "name": "getCourseSlug",
    "memberof": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection#getCourseSlug",
    "access": "public",
    "description": "Returns the Course slug for the favorite's corresponding Course.",
    "lineNumber": 137,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 479,
    "kind": "method",
    "name": "getStudentDoc",
    "memberof": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection#getStudentDoc",
    "access": "public",
    "description": "Returns the Student profile associated with the FavoriteCourse with the given instanceID.",
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 480,
    "kind": "method",
    "name": "getStudentUsername",
    "memberof": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection#getStudentUsername",
    "access": "public",
    "description": "Returns the username associated with the studentID.",
    "lineNumber": 160,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 481,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks semesterID, courseID, and studentID.",
    "lineNumber": 172,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 482,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteCourseCollection.ts~FavoriteCourseCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the FavoriteCourse docID in a format acceptable to define().",
    "lineNumber": 191,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IFavoriteCourseDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 483,
    "kind": "file",
    "name": "api/favorite/FavoriteInterestCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\nimport { FavoriteInterests } from './FavoriteInterestCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('FavoriteInterestCollection', function testSuite() {\n    const collectionName = FavoriteInterests.getCollectionName();\n    const definitionData = {\n      interest: 'algorithms',\n      username: 'abi@hawaii.edu',\n    };\n    const updateData: any = { retired: true };\n\n    before(function (done) {\n      this.timeout(5000);\n      defineTestFixturesMethod.call(['minimal', 'abi.student'], done);\n    });\n\n    it('#define, #update, #removeIt Methods', async function test() {\n      await withLoggedInUser();\n      await withRadGradSubscriptions(Meteor.userId());\n      const docID = await defineMethod.callPromise({ collectionName, definitionData });\n      expect(FavoriteInterests.isDefined(docID), 'define: isDefined').to.be.true;\n      expect(FavoriteInterests.countNonRetired()).to.equal(1);\n      updateData.id = docID;\n      await updateMethod.callPromise({ collectionName, updateData });\n      expect(FavoriteInterests.countNonRetired()).to.equal(0);\n      expect(FavoriteInterests.isDefined(docID), 'retired: isDefined').to.be.true; // still in client collection\n      await removeItMethod.callPromise({ collectionName, instance: docID });\n      expect(FavoriteInterests.countNonRetired()).to.equal(0);\n      expect(FavoriteInterests.isDefined(docID), 'removeIt: isDefined').to.be.false;\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteInterestCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 484,
    "kind": "file",
    "name": "api/favorite/FavoriteInterestCollection.methods.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { CallPromiseMixin } from 'meteor/didericis:callpromise-mixin';\nimport { ValidatedMethod } from 'meteor/mdg:validated-method';\nimport _ from 'lodash';\nimport { ROLE } from '../role/Role';\nimport { AdvisorProfiles } from '../user/AdvisorProfileCollection';\nimport { FacultyProfiles } from '../user/FacultyProfileCollection';\nimport { MentorProfiles } from '../user/MentorProfileCollection';\nimport { StudentProfiles } from '../user/StudentProfileCollection';\nimport { FavoriteInterests } from './FavoriteInterestCollection';\n\nexport const getUserIDsWithFavoriteInterestMethod = new ValidatedMethod({\n  name: 'FavoriteInterests.users',\n  mixins: [CallPromiseMixin],\n  validate: null,\n  run({ interestID, role }) {\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to get favorites.');\n    }\n    if (Meteor.isServer) {\n      let userIDs;\n      const favUserIDs = _.map(FavoriteInterests.find({ interestID }).fetch(), 'userID');\n      switch (role.toUpperCase()) {\n        case ROLE.ADVISOR:\n          userIDs = _.map(AdvisorProfiles.find().fetch(), 'userID');\n          break;\n        case ROLE.ALUMNI:\n          userIDs = _.map(StudentProfiles.find({ isAlumni: true }).fetch(), 'userID');\n          break;\n        case ROLE.FACULTY:\n          userIDs = _.map(FacultyProfiles.find().fetch(), 'userID');\n          break;\n        case ROLE.MENTOR:\n          userIDs = _.map(MentorProfiles.find().fetch(), 'userID');\n          break;\n        default:\n          userIDs = _.map(StudentProfiles.find({ isAlumni: false }).fetch(), 'userID');\n          break;\n      }\n      return _.intersection(userIDs, favUserIDs);\n    }\n    return [];\n  },\n});\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteInterestCollection.methods.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 485,
    "kind": "variable",
    "name": "getUserIDsWithFavoriteInterestMethod",
    "memberof": "api/favorite/FavoriteInterestCollection.methods.ts",
    "static": true,
    "longname": "api/favorite/FavoriteInterestCollection.methods.ts~getUserIDsWithFavoriteInterestMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/favorite/FavoriteInterestCollection.methods.ts",
    "importStyle": "{getUserIDsWithFavoriteInterestMethod}",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 486,
    "kind": "file",
    "name": "api/favorite/FavoriteInterestCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport { FavoriteInterests } from './FavoriteInterestCollection';\nimport { makeSampleInterest } from '../interest/SampleInterests';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { Slugs } from '../slug/SlugCollection';\nimport { Interests } from '../interest/InterestCollection';\nimport { Users } from '../user/UserCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('FavoriteInterestCollection', function testSuite() {\n    let interest;\n    let interestName;\n    let username;\n    let userID;\n    let firstName;\n\n    before(function setup() {\n      this.timeout(5000);\n      removeAllEntities();\n      interest = makeSampleInterest();\n      interestName = Interests.findDoc(interest).name;\n      userID = makeSampleUser();\n      const profile = Users.getProfile(userID);\n      username = profile.username;\n      firstName = profile.firstName;\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1() {\n      const docID = FavoriteInterests.define({ interest, username });\n      expect(FavoriteInterests.isDefined(docID)).to.be.true;\n      FavoriteInterests.removeIt(docID);\n      expect(FavoriteInterests.isDefined(docID)).to.be.false;\n    });\n\n    it('Cannot define duplicates', function test2() {\n      const docID1 = FavoriteInterests.define({ interest, username });\n      const docID2 = FavoriteInterests.define({ interest, username });\n      expect(docID1).to.equal(docID2);\n      expect(FavoriteInterests.isDefined(docID2)).to.be.true;\n      FavoriteInterests.removeIt(docID2);\n      expect(FavoriteInterests.isDefined(docID1)).to.be.false;\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      const docID = FavoriteInterests.define({ interest, username });\n      fc.assert(\n        fc.property(fc.boolean(), (retired) => {\n          FavoriteInterests.update(docID, { retired });\n          const fav = FavoriteInterests.findDoc(docID);\n          expect(fav.retired).to.equal(retired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      let fav = FavoriteInterests.findOne({});\n      let docID = fav._id;\n      const dumpObject = FavoriteInterests.dumpOne(docID);\n      FavoriteInterests.removeIt(docID);\n      expect(FavoriteInterests.isDefined(docID)).to.be.false;\n      docID = FavoriteInterests.restoreOne(dumpObject);\n      expect(FavoriteInterests.isDefined(docID)).to.be.true;\n      fav = FavoriteInterests.findDoc(docID);\n      expect(fav.interestID).to.equal(interest);\n      expect(fav.userID).to.equal(userID);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const errors = FavoriteInterests.checkIntegrity();\n      expect(errors).to.have.lengthOf(0);\n    });\n\n    it('Can get docs and slug', function test6() {\n      const docID = FavoriteInterests.define({ interest, username });\n      const interestDoc = FavoriteInterests.getInterestDoc(docID);\n      expect(interestDoc).to.exist;\n      expect(interestDoc.name).to.equal(interestName);\n      const interestSlug = Slugs.getNameFromID(interestDoc.slugID);\n      expect(FavoriteInterests.getInterestSlug(docID)).to.equal(interestSlug);\n      const studentDoc = FavoriteInterests.getStudentDoc(docID);\n      expect(studentDoc).to.exist;\n      expect(studentDoc.firstName).to.equal(firstName);\n      const studentUsername = FavoriteInterests.getStudentUsername(docID);\n      expect(studentUsername.startsWith('student')).to.be.true;\n      expect(studentUsername).to.equal(username);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteInterestCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 487,
    "kind": "file",
    "name": "api/favorite/FavoriteInterestCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport _ from 'lodash';\nimport { ReactiveAggregate } from 'meteor/jcbernack:reactive-aggregate';\nimport BaseCollection from '../base/BaseCollection';\nimport { Interests } from '../interest/InterestCollection';\nimport { Users } from '../user/UserCollection';\nimport { ROLE } from '../role/Role';\nimport { IFavoriteInterestDefine, IFavoriteUpdate } from '../../typings/radgrad';\n\nclass FavoriteInterestCollection extends BaseCollection {\n  public readonly publicationNames: {\n    scoreboard: string;\n  }\n\n  /** Creates the FavoriteInterest collection */\n  constructor() {\n    super('FavoriteInterest', new SimpleSchema({\n      interestID: SimpleSchema.RegEx.Id,\n      userID: SimpleSchema.RegEx.Id,\n      retired: { type: Boolean, optional: true },\n    }));\n    this.publicationNames = {\n      scoreboard: `${this.collectionName}.scoreboard`,\n    };\n  }\n\n  /**\n   * Defines a new FavoriteInterest.\n   * @param interest the interest slug.\n   * @param student the student's username.\n   * @param retired the retired status.\n   * @returns {void|*|boolean|{}}\n   */\n  define({ interest, username, retired = false }) {\n    const interestID = Interests.getID(interest);\n    const userID = Users.getID(username);\n    const doc = this.collection.findOne({ userID, interestID });\n    if (doc) {\n      return doc._id;\n    }\n    return this.collection.insert({ interestID, userID, retired });\n  }\n\n  /**\n   * Updates the retired status.\n   * @param docID the ID of the FavoriteInterest.\n   * @param retired the new retired value.\n   */\n  update(docID, { retired }) {\n    this.assertDefined(docID);\n    const updateData: IFavoriteUpdate = {};\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the FavoriteInterest.\n   * @param docID The docID of the FavoriteInterest.\n   */\n  removeIt(docID) {\n    this.assertDefined(docID);\n    // OK, clear to delete.\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Removes all the FavoriteInterests for the user.\n   * @param user the username.\n   */\n  removeUser(user) {\n    const userID = Users.getID(user);\n    this.collection.remove({ userID });\n  }\n\n  /**\n   * Publish InterestFavorites. If logged in as ADMIN get all, otherwise only get the InterestFavorites for the\n   * studentID.\n   * Also publishes the InterestFavorites scoreboard.\n   */\n  publish() {\n    if (Meteor.isServer) {\n      const instance = this;\n      Meteor.publish(this.collectionName, function filterStudentID(studentID) { // eslint-disable-line meteor/audit-argument-checks\n        if (_.isNil(studentID)) {\n          return this.ready();\n        }\n        const profile = Users.getProfile(studentID);\n        if (_.includes([ROLE.ADMIN, ROLE.ADVISOR], profile.role)) {\n          return instance.collection.find();\n        }\n        return instance.collection.find({ userID: studentID });\n      });\n      Meteor.publish(this.publicationNames.scoreboard, function publishInterestScoreboard() {\n        ReactiveAggregate(this, instance.collection, [\n          {\n            $group: {\n              _id: '$interestID',\n              count: { $sum: 1 },\n            },\n          },\n          { $project: { count: 1, interestID: 1 } },\n        ], { clientCollection: 'InterestFavoritesScoreboard' });\n      });\n    }\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\n   * Student.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  assertValidRoleForMethod(userId) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.FACULTY, ROLE.MENTOR, ROLE.STUDENT]);\n  }\n\n  /**\n   * Returns the Interest associated with the FavoriteInterest with the given instanceID.\n   * @param instanceID The id of the InterestInstance.\n   * @returns {Object} The associated Interest.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  getInterestDoc(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Interests.findDoc(instance.interestID);\n  }\n\n  /**\n   * Returns the Interest slug for the favorite's corresponding Interest.\n   * @param instanceID The FavoriteInterest ID.\n   * @return {string} The interest slug.\n   */\n  getInterestSlug(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Interests.findSlugByID(instance.interestID);\n  }\n\n  /**\n   * Returns the Student profile associated with the FavoriteInterest with the given instanceID.\n   * @param instanceID The ID of the FavoriteInterest.\n   * @returns {Object} The associated Student profile.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  getStudentDoc(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Users.getProfile(instance.userID);\n  }\n\n  /**\n   * Returns the username associated with the userID.\n   * @param instanceID the FavoriteInterest id.\n   * @returns {*}\n   */\n  getStudentUsername(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Users.getProfile(instance.userID).username;\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks semesterID, interestID, and userID.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  checkIntegrity() {\n    const problems = [];\n    this.find()\n      .forEach(doc => {\n        if (!Interests.isDefined(doc.interestID)) {\n          problems.push(`Bad interestID: ${doc.interestID}`);\n        }\n        if (!Users.isDefined(doc.userID)) {\n          problems.push(`Bad userID: ${doc.userID}`);\n        }\n      });\n     return problems;\n  }\n\n  /**\n   * Returns an object representing the FavoriteInterest with given docID in a format acceptable to define().\n   * @param docID the docID of a FavoriteInterest\n   * @returns {IFavoriteInterestDefine}\n   */\n  dumpOne(docID): IFavoriteInterestDefine {\n    const doc = this.findDoc(docID);\n    const interest = Interests.findSlugByID(doc.interestID);\n    const username = Users.getProfile(doc.userID).username;\n    const retired = doc.retired;\n    return { interest, username, retired };\n  }\n}\n\nexport const FavoriteInterests = new FavoriteInterestCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteInterestCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 488,
    "kind": "variable",
    "name": "FavoriteInterests",
    "memberof": "api/favorite/FavoriteInterestCollection.ts",
    "static": true,
    "longname": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterests",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/favorite/FavoriteInterestCollection.ts",
    "importStyle": "{FavoriteInterests}",
    "description": null,
    "lineNumber": 225,
    "undocument": true,
    "type": {
      "types": [
        "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection"
      ]
    }
  },
  {
    "__docId__": 489,
    "kind": "class",
    "name": "FavoriteInterestCollection",
    "memberof": "api/favorite/FavoriteInterestCollection.ts",
    "static": true,
    "longname": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/favorite/FavoriteInterestCollection.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 11,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 490,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection#constructor",
    "access": "public",
    "description": "Creates the FavoriteInterest collection",
    "lineNumber": 17
  },
  {
    "__docId__": 491,
    "kind": "member",
    "name": "publicationNames",
    "memberof": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection",
    "static": false,
    "longname": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection#publicationNames",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "{\"scoreboard\": *}"
      ]
    }
  },
  {
    "__docId__": 492,
    "kind": "method",
    "name": "define",
    "memberof": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection#define",
    "access": "public",
    "description": "Defines a new FavoriteInterest.",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 493,
    "kind": "method",
    "name": "update",
    "memberof": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection#update",
    "access": "public",
    "description": "Updates the retired status.",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 494,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection#removeIt",
    "access": "public",
    "description": "Remove the FavoriteInterest.",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 495,
    "kind": "method",
    "name": "removeUser",
    "memberof": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection#removeUser",
    "access": "public",
    "description": "Removes all the FavoriteInterests for the user.",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 496,
    "kind": "method",
    "name": "publish",
    "memberof": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection#publish",
    "access": "public",
    "description": "Publish InterestFavorites. If logged in as ADMIN get all, otherwise only get the InterestFavorites for the\nstudentID.\nAlso publishes the InterestFavorites scoreboard.",
    "lineNumber": 83,
    "params": [],
    "return": null
  },
  {
    "__docId__": 497,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\nStudent.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 117,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 498,
    "kind": "method",
    "name": "getInterestDoc",
    "memberof": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection#getInterestDoc",
    "access": "public",
    "description": "Returns the Interest associated with the FavoriteInterest with the given instanceID.",
    "lineNumber": 127,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 499,
    "kind": "method",
    "name": "getInterestSlug",
    "memberof": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection#getInterestSlug",
    "access": "public",
    "description": "Returns the Interest slug for the favorite's corresponding Interest.",
    "lineNumber": 138,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 500,
    "kind": "method",
    "name": "getStudentDoc",
    "memberof": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection#getStudentDoc",
    "access": "public",
    "description": "Returns the Student profile associated with the FavoriteInterest with the given instanceID.",
    "lineNumber": 150,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 501,
    "kind": "method",
    "name": "getStudentUsername",
    "memberof": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection#getStudentUsername",
    "access": "public",
    "description": "Returns the username associated with the userID.",
    "lineNumber": 161,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 502,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks semesterID, interestID, and userID.",
    "lineNumber": 173,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 503,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteInterestCollection.ts~FavoriteInterestCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the FavoriteInterest with given docID in a format acceptable to define().",
    "lineNumber": 192,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IFavoriteInterestDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 504,
    "kind": "file",
    "name": "api/favorite/FavoriteOpportunityCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\nimport { FavoriteOpportunities } from './FavoriteOpportunityCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('FavoriteOpportunityCollection', function testSuite() {\n    const collectionName = FavoriteOpportunities.getCollectionName();\n    const definitionData = {\n      opportunity: 'acm-icpc',\n      student: 'abi@hawaii.edu',\n    };\n    const updateData: any = { retired: true };\n\n    before(function (done) {\n      this.timeout(5000);\n      defineTestFixturesMethod.call(['minimal', 'abi.student', 'opportunities'], done);\n    });\n\n    it('#define, #update, #removeIt Methods', async function test() {\n      await withLoggedInUser();\n      await withRadGradSubscriptions(Meteor.userId());\n      const docID = await defineMethod.callPromise({ collectionName, definitionData });\n      expect(FavoriteOpportunities.isDefined(docID), 'define: isDefined').to.be.true;\n      expect(FavoriteOpportunities.countNonRetired()).to.equal(1);\n      updateData.id = docID;\n      await updateMethod.callPromise({ collectionName, updateData });\n      expect(FavoriteOpportunities.countNonRetired()).to.equal(0);\n      expect(FavoriteOpportunities.isDefined(docID), 'retired: isDefined').to.be.true; // still in client collection\n      await removeItMethod.callPromise({ collectionName, instance: docID });\n      expect(FavoriteOpportunities.countNonRetired()).to.equal(0);\n      expect(FavoriteOpportunities.isDefined(docID), 'removeIt: isDefined').to.be.false;\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteOpportunityCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 505,
    "kind": "file",
    "name": "api/favorite/FavoriteOpportunityCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport { FavoriteOpportunities } from './FavoriteOpportunityCollection';\nimport { makeSampleOpportunity } from '../opportunity/SampleOpportunities';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { Slugs } from '../slug/SlugCollection';\nimport { ROLE } from '../role/Role';\nimport { Users } from '../user/UserCollection';\nimport { Opportunities } from '../opportunity/OpportunityCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('FavoriteOpportunityCollection', function testSuite() {\n    let opportunity;\n    let opportunityName;\n    let student;\n    let sponsor;\n    let username;\n    let firstName;\n\n    before(function setup() {\n      this.timeout(5000);\n      removeAllEntities();\n      sponsor = makeSampleUser(ROLE.FACULTY);\n      opportunity = makeSampleOpportunity(sponsor);\n      opportunityName = Opportunities.findDoc(opportunity).name;\n      student = makeSampleUser();\n      const profile = Users.getProfile(student);\n      username = profile.username;\n      firstName = profile.firstName;\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1() {\n      const docID = FavoriteOpportunities.define({ opportunity, student });\n      expect(FavoriteOpportunities.isDefined(docID)).to.be.true;\n      FavoriteOpportunities.removeIt(docID);\n      expect(FavoriteOpportunities.isDefined(docID)).to.be.false;\n    });\n\n    it('Cannot define duplicates', function test2() {\n      const docID1 = FavoriteOpportunities.define({ opportunity, student });\n      const docID2 = FavoriteOpportunities.define({ opportunity, student });\n      expect(docID1).to.equal(docID2);\n      expect(FavoriteOpportunities.isDefined(docID2)).to.be.true;\n      FavoriteOpportunities.removeIt(docID1);\n      expect(FavoriteOpportunities.isDefined(docID2)).to.be.false;\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      const docID = FavoriteOpportunities.define({ opportunity, student });\n      fc.assert(\n        fc.property(fc.boolean(), (retired) => {\n          FavoriteOpportunities.update(docID, { retired });\n          const fav = FavoriteOpportunities.findDoc(docID);\n          expect(fav.retired).to.equal(retired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      let fav = FavoriteOpportunities.findOne({});\n      let docID = fav._id;\n      const dumpObject = FavoriteOpportunities.dumpOne(docID);\n      FavoriteOpportunities.removeIt(docID);\n      expect(FavoriteOpportunities.isDefined(docID)).to.be.false;\n      docID = FavoriteOpportunities.restoreOne(dumpObject);\n      expect(FavoriteOpportunities.isDefined(docID)).to.be.true;\n      fav = FavoriteOpportunities.findDoc(docID);\n      expect(fav.opportunityID).to.equal(opportunity);\n      expect(fav.studentID).to.equal(student);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const errors = FavoriteOpportunities.checkIntegrity();\n      expect(errors).to.have.lengthOf(0);\n    });\n\n    it('Can get docs and slug', function test6() {\n      const docID = FavoriteOpportunities.define({ opportunity, student });\n      const opportunityDoc = FavoriteOpportunities.getOpportunityDoc(docID);\n      expect(opportunityDoc).to.exist;\n      expect(opportunityDoc.name).to.equal(opportunityName);\n      expect(opportunityDoc.sponsorID).to.equal(sponsor);\n      const opportunitySlug = Slugs.getNameFromID(opportunityDoc.slugID);\n      expect(FavoriteOpportunities.getOpportunitySlug(docID)).to.equal(opportunitySlug);\n      const studentDoc = FavoriteOpportunities.getStudentDoc(docID);\n      expect(studentDoc).to.exist;\n      expect(studentDoc.firstName).to.equal(firstName);\n      const studentUsername = FavoriteOpportunities.getStudentUsername(docID);\n      expect(studentUsername.startsWith('student')).to.be.true;\n      expect(studentUsername).to.equal(username);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteOpportunityCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 506,
    "kind": "file",
    "name": "api/favorite/FavoriteOpportunityCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport _ from 'lodash';\nimport { ReactiveAggregate } from 'meteor/jcbernack:reactive-aggregate';\nimport BaseCollection from '../base/BaseCollection';\nimport { Users } from '../user/UserCollection';\nimport { ROLE } from '../role/Role';\nimport { Opportunities } from '../opportunity/OpportunityCollection';\nimport { IFavoriteOpportunityDefine, IFavoriteUpdate } from '../../typings/radgrad';\n\nclass FavoriteOpportunityCollection extends BaseCollection {\n  public readonly publicationNames: {\n    scoreboard: string;\n  }\n\n  /** Creates the FavoriteOpportunity collection */\n  constructor() {\n    super('FavoriteOpportunity', new SimpleSchema({\n      opportunityID: SimpleSchema.RegEx.Id,\n      studentID: SimpleSchema.RegEx.Id,\n      retired: { type: Boolean, optional: true },\n    }));\n    this.publicationNames = {\n      scoreboard: `${this.collectionName}.scoreboard`,\n    };\n  }\n\n  /**\n   * Defines a new FavoriteOpportunity.\n   * @param opportunity the opportunity slug.\n   * @param student the student's username.\n   * @param retired the retired status.\n   * @returns {void|*|boolean|{}}\n   */\n  define({ opportunity, student, retired = false }) {\n    const opportunityID = Opportunities.getID(opportunity);\n    const studentID = Users.getID(student);\n    const doc = this.collection.findOne({ studentID, opportunityID });\n    if (doc) {\n      return doc._id;\n    }\n    return this.collection.insert({ opportunityID, studentID, retired });\n  }\n\n  /**\n   * Updates the retired status.\n   * @param docID the ID of the FavoriteOpportunity.\n   * @param retired the new retired value.\n   */\n  update(docID, { retired }) {\n    this.assertDefined(docID);\n    const updateData: IFavoriteUpdate = {};\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the FavoriteOpportunity.\n   * @param docID The docID of the FavoriteOpportunity.\n   */\n  removeIt(docID) {\n    this.assertDefined(docID);\n    // OK, clear to delete.\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Removes all the FavoriteOpportunities for the user.\n   * @param user the username.\n   */\n  removeUser(user) {\n    const studentID = Users.getID(user);\n    this.collection.remove({ studentID });\n  }\n\n  /**\n   * Publish OpportunityFavorites. If logged in as ADMIN get all, otherwise only get the OpportunityFavorites for the\n   * studentID.\n   * Also publishes the OpportunityFavorites scoreboard.\n   */\n  publish() {\n    if (Meteor.isServer) {\n      const instance = this;\n      Meteor.publish(this.collectionName, function filterStudentID(studentID) { // eslint-disable-line meteor/audit-argument-checks\n        if (_.isNil(studentID)) {\n          return this.ready();\n        }\n        const profile = Users.getProfile(studentID);\n        if (_.includes([ROLE.ADMIN, ROLE.ADVISOR], profile.role)) {\n          return instance.collection.find();\n        }\n        return instance.collection.find({ studentID });\n      });\n      Meteor.publish(this.publicationNames.scoreboard, function publishOpportunityScoreboard() {\n        ReactiveAggregate(this, instance.collection, [\n          {\n            $group: {\n              _id: '$opportunityID',\n              count: { $sum: 1 },\n            },\n          },\n          { $project: { count: 1, opportunityID: 1 } },\n        ], { clientCollection: 'OpportunityFavoritesScoreboard' });\n      });\n    }\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\n   * Student.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  assertValidRoleForMethod(userId) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.STUDENT]);\n  }\n\n  /**\n   * Returns the Opportunity associated with the FavoriteOpportunity with the given instanceID.\n   * @param instanceID The id of the OpportunityInstance.\n   * @returns {Object} The associated Opportunity.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  getOpportunityDoc(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Opportunities.findDoc(instance.opportunityID);\n  }\n\n  /**\n   * Returns the Opportunity slug for the favorite's corresponding Opportunity.\n   * @param instanceID The FavoriteOpportunity ID.\n   * @return {string} The opportunity slug.\n   */\n  getOpportunitySlug(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Opportunities.findSlugByID(instance.opportunityID);\n  }\n\n  /**\n   * Returns the Student profile associated with the FavoriteOpportunity with the given instanceID.\n   * @param instanceID The ID of the FavoriteOpportunity.\n   * @returns {Object} The associated Student profile.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  getStudentDoc(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Users.getProfile(instance.studentID);\n  }\n\n  /**\n   * Returns the username associated with the studentID.\n   * @param instanceID the FavoriteOpportunity id.\n   * @returns {*}\n   */\n  getStudentUsername(instanceID) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Users.getProfile(instance.studentID).username;\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks semesterID, opportunityID, and studentID.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  checkIntegrity() {\n    const problems = [];\n    this.find()\n      .forEach(doc => {\n        if (!Opportunities.isDefined(doc.opportunityID)) {\n          problems.push(`Bad opportunityID: ${doc.opportunityID}`);\n        }\n        if (!Users.isDefined(doc.studentID)) {\n          problems.push(`Bad studentID: ${doc.studentID}`);\n        }\n      });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the FavoriteOpportunity docID in a format acceptable to define().\n   * @param docID The docID of a FavoriteOpportunity.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  dumpOne(docID): IFavoriteOpportunityDefine {\n    const doc = this.findDoc(docID);\n    const opportunity = Opportunities.findSlugByID(doc.opportunityID);\n    const student = Users.getProfile(doc.studentID).username;\n    const retired = doc.retired;\n    return { opportunity, student, retired };\n  }\n\n}\n\nexport const FavoriteOpportunities = new FavoriteOpportunityCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteOpportunityCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 507,
    "kind": "variable",
    "name": "FavoriteOpportunities",
    "memberof": "api/favorite/FavoriteOpportunityCollection.ts",
    "static": true,
    "longname": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunities",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/favorite/FavoriteOpportunityCollection.ts",
    "importStyle": "{FavoriteOpportunities}",
    "description": null,
    "lineNumber": 225,
    "undocument": true,
    "type": {
      "types": [
        "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection"
      ]
    }
  },
  {
    "__docId__": 508,
    "kind": "class",
    "name": "FavoriteOpportunityCollection",
    "memberof": "api/favorite/FavoriteOpportunityCollection.ts",
    "static": true,
    "longname": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/favorite/FavoriteOpportunityCollection.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 11,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 509,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection#constructor",
    "access": "public",
    "description": "Creates the FavoriteOpportunity collection",
    "lineNumber": 17
  },
  {
    "__docId__": 510,
    "kind": "member",
    "name": "publicationNames",
    "memberof": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection",
    "static": false,
    "longname": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection#publicationNames",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "{\"scoreboard\": *}"
      ]
    }
  },
  {
    "__docId__": 511,
    "kind": "method",
    "name": "define",
    "memberof": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection#define",
    "access": "public",
    "description": "Defines a new FavoriteOpportunity.",
    "lineNumber": 35,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 512,
    "kind": "method",
    "name": "update",
    "memberof": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection#update",
    "access": "public",
    "description": "Updates the retired status.",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 513,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection#removeIt",
    "access": "public",
    "description": "Remove the FavoriteOpportunity.",
    "lineNumber": 63,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 514,
    "kind": "method",
    "name": "removeUser",
    "memberof": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection#removeUser",
    "access": "public",
    "description": "Removes all the FavoriteOpportunities for the user.",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 515,
    "kind": "method",
    "name": "publish",
    "memberof": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection#publish",
    "access": "public",
    "description": "Publish OpportunityFavorites. If logged in as ADMIN get all, otherwise only get the OpportunityFavorites for the\nstudentID.\nAlso publishes the OpportunityFavorites scoreboard.",
    "lineNumber": 83,
    "params": [],
    "return": null
  },
  {
    "__docId__": 516,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\nStudent.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 117,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 517,
    "kind": "method",
    "name": "getOpportunityDoc",
    "memberof": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection#getOpportunityDoc",
    "access": "public",
    "description": "Returns the Opportunity associated with the FavoriteOpportunity with the given instanceID.",
    "lineNumber": 127,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 518,
    "kind": "method",
    "name": "getOpportunitySlug",
    "memberof": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection#getOpportunitySlug",
    "access": "public",
    "description": "Returns the Opportunity slug for the favorite's corresponding Opportunity.",
    "lineNumber": 138,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 519,
    "kind": "method",
    "name": "getStudentDoc",
    "memberof": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection#getStudentDoc",
    "access": "public",
    "description": "Returns the Student profile associated with the FavoriteOpportunity with the given instanceID.",
    "lineNumber": 150,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 520,
    "kind": "method",
    "name": "getStudentUsername",
    "memberof": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection#getStudentUsername",
    "access": "public",
    "description": "Returns the username associated with the studentID.",
    "lineNumber": 161,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 521,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks semesterID, opportunityID, and studentID.",
    "lineNumber": 173,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 522,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/favorite/FavoriteOpportunityCollection.ts~FavoriteOpportunityCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the FavoriteOpportunity docID in a format acceptable to define().",
    "lineNumber": 192,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IFavoriteOpportunityDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 523,
    "kind": "file",
    "name": "api/favorite/FavoriteTypes.ts",
    "content": "// types for Favorites\nexport enum FAVORITE_TYPE {\n  ACADEMICPLAN = 'academicPlan',\n  CAREERGOAL = 'careerGoal',\n  COURSE = 'course',\n  INTEREST = 'interest',\n  OPPORTUNITY = 'opportunity',\n}\n\nexport type IFavoriteTypes =\n  FAVORITE_TYPE.ACADEMICPLAN\n  | FAVORITE_TYPE.CAREERGOAL\n  | FAVORITE_TYPE.COURSE\n  | FAVORITE_TYPE.INTEREST\n  | FAVORITE_TYPE.OPPORTUNITY;\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/FavoriteTypes.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 524,
    "kind": "file",
    "name": "api/favorite/index.ts",
    "content": "import './FavoriteAcademicPlanCollection';\nimport './FavoriteCareerGoalCollection';\nimport './FavoriteCourseCollection';\nimport './FavoriteInterestCollection.methods';\nimport './FavoriteInterestCollection';\nimport './FavoriteOpportunityCollection';\nimport './FavoriteTypes';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/favorite/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 525,
    "kind": "file",
    "name": "api/feed/FeedCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { Feeds } from './FeedCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('FeedCollection Meteor Methods ', function test() {\n    const collectionName = Feeds.getCollectionName();\n    let docID;\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal', 'abi.student', 'opportunities'], done);\n    });\n\n    it('Define Method (new-user)', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      const definitionData = { user: 'abi@hawaii.edu', feedType: Feeds.NEW_USER };\n      docID = await defineMethod.callPromise({ collectionName, definitionData });\n    });\n\n    it('Update Method', async function () {\n      const id = docID;\n      const description = 'updated Feed description';\n      await updateMethod.callPromise({ collectionName, updateData: { id, description } });\n    });\n\n    it('Remove Method', async function () {\n      await removeItMethod.callPromise({ collectionName, instance: docID });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/feed/FeedCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 526,
    "kind": "file",
    "name": "api/feed/FeedCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport { ROLE } from '../role/Role';\nimport { makeSampleUser, makeSampleUserArray } from '../user/SampleUsers';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { Feeds } from './FeedCollection';\nimport { Users } from '../user/UserCollection';\nimport { Courses } from '../course/CourseCollection';\nimport { Opportunities } from '../opportunity/OpportunityCollection';\nimport { makeSampleAcademicTermSlug } from '../academic-term/SampleAcademicTerms';\nimport { makeSampleCourse } from '../course/SampleCourses';\nimport { makeSampleOpportunity } from '../opportunity/SampleOpportunities';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('FeedCollection', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function tearDown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(50000);\n      fc.assert(\n        fc.property(fc.integer(0, 6), fc.integer(1, 6), (choice, level) => {\n          const sponsor = makeSampleUser(ROLE.FACULTY);\n          let docID;\n          switch (choice) {\n            case 0:\n              docID = Feeds.define({\n                feedType: Feeds.NEW_USER,\n                user: Users.getProfile(makeSampleUser()).username,\n              });\n              break;\n            case 1:\n              docID = Feeds.define({\n                feedType: Feeds.NEW_COURSE,\n                course: Courses.findSlugByID(makeSampleCourse()),\n              });\n              break;\n            case 2:\n              docID = Feeds.define({\n                feedType: Feeds.NEW_OPPORTUNITY,\n                opportunity: Opportunities.findSlugByID(makeSampleOpportunity(sponsor)),\n              });\n              break;\n            case 3:\n              docID = Feeds.define({\n                feedType: Feeds.VERIFIED_OPPORTUNITY,\n                user: Users.getProfile(makeSampleUser()).username,\n                opportunity: Opportunities.findSlugByID(makeSampleOpportunity(sponsor)),\n                academicTerm: makeSampleAcademicTermSlug(),\n              });\n              break;\n            case 4:\n              docID = Feeds.define({\n                feedType: Feeds.NEW_COURSE_REVIEW,\n                user: Users.getProfile(makeSampleUser()).username,\n                course: Courses.findSlugByID(makeSampleCourse()),\n              });\n              break;\n            case 5:\n              docID = Feeds.define({\n                feedType: Feeds.NEW_OPPORTUNITY_REVIEW,\n                user: Users.getProfile(makeSampleUser()).username,\n                opportunity: Opportunities.findSlugByID(makeSampleOpportunity(sponsor)),\n              });\n              break;\n            default:\n              docID = Feeds.define({\n                feedType: Feeds.NEW_LEVEL,\n                user: Users.getProfile(makeSampleUser()).username,\n                level,\n              });\n          }\n          expect(Feeds.isDefined(docID)).to.be.true;\n          Feeds.removeIt(docID);\n          expect(Feeds.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicates', function test2() { // Test if duplicate documents can be defined\n      const user = Users.getProfile(makeSampleUser()).username;\n      const docID = Feeds.define({\n        feedType: Feeds.NEW_USER,\n        user,\n      });\n      expect(Feeds.isDefined(docID)).to.be.true;\n      const docID2 = Feeds.define({\n        feedType: Feeds.NEW_USER,\n        user,\n      });\n      expect(docID).to.equal(docID2);\n      expect(Feeds.isDefined(docID2)).to.be.true;\n    });\n\n    it('Can update', function test3(done) { // Test updating documents\n      this.timeout(25000);\n      let doc = Feeds.findOne({});\n      const docID = doc._id;\n      fc.assert(\n        // { description, picture, users, opportunity, course, academicTerm, retired }\n        fc.property(fc.lorem(10), fc.lorem(1), fc.boolean(),\n          (description, picture, retired) => {\n          const users = makeSampleUserArray(2);\n          const course = makeSampleCourse();\n          const sponsor = makeSampleUser(ROLE.FACULTY);\n          const opportunity = makeSampleOpportunity(sponsor);\n          const academicTerm = makeSampleAcademicTermSlug();\n          Feeds.update(docID, { description, picture, users, opportunity, course, academicTerm, retired });\n          doc = Feeds.findDoc(docID);\n          expect(doc.description).to.equal(description);\n          expect(doc.picture).to.equal(picture);\n          expect(doc.retired).to.equal(retired);\n          expect(AcademicTerms.findSlugByID(doc.termID)).to.equal(academicTerm);\n          expect(doc.courseID).to.equal(course);\n          expect(doc.opportunityID).to.equal(opportunity);\n          }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() { // Tests dumpOne and restoreOne\n      const origDoc = Feeds.findOne({});\n      let docID = origDoc._id;\n      const dumpObject = Feeds.dumpOne(docID);\n      Feeds.removeIt(docID);\n      expect(Feeds.isDefined(docID)).to.be.false;\n      docID = Feeds.restoreOne(dumpObject);\n      expect(Feeds.isDefined(docID)).to.be.true;\n      const doc = Feeds.findDoc(docID);\n      expect(doc.retired).to.equal(origDoc.retired);\n      expect(doc.userIDs).to.deep.equal(origDoc.userIDs);\n    });\n\n    it('Can checkIntegrity no errors', function test5() { // Tests checkIntegrity\n      const problems = Feeds.checkIntegrity();\n      expect(problems).to.have.lengthOf(0);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/feed/FeedCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 527,
    "kind": "file",
    "name": "api/feed/FeedCollection.ts",
    "content": "import SimpleSchema from 'simpl-schema';\nimport { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport moment from 'moment';\nimport { ROLE } from '../role/Role';\nimport { Courses } from '../course/CourseCollection';\nimport { Opportunities } from '../opportunity/OpportunityCollection';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { Slugs } from '../slug/SlugCollection';\nimport { Users } from '../user/UserCollection';\nimport BaseCollection from '../base/BaseCollection';\nimport { IFeedDefine, IFeedUpdate } from '../../typings/radgrad';\nimport { defaultProfilePicture } from '../user/BaseProfileCollection';\n\n/**\n * Returns the number of whole days between date a and b.\n * @param a The first date.\n * @param b The second date.\n * @returns {number} The number of days between a and b.\n * @memberOf api/feed\n */\nfunction dateDiffInDays(a: string, b: string) {\n  const ams = Date.parse(a);\n  const bms = Date.parse(b);\n  const MS_PER_DAY = 1000 * 60 * 60 * 24;\n  return Math.floor((ams - bms) / MS_PER_DAY);\n}\n\n/**\n * Returns true if the timestamp associated with feed is within a day of timestamp.\n * @param feed The feed.\n * @param timestamp A timestamp.\n * @returns {boolean} True if feed's timestamp is within a day of timestamp.\n * @memberOf api/feed\n */\nfunction withinPastDay(feed: { timestamp: string }, timestamp: string) {\n  const feedTime = feed.timestamp;\n  const currentFeedTime = timestamp;\n  const timeDiff = dateDiffInDays(currentFeedTime, feedTime);\n  return (timeDiff === 0);\n}\n\n/**\n * Represents a feed instance.\n * @extends api/base.BaseCollection\n * @memberOf api/feed\n */\nclass FeedCollection extends BaseCollection {\n  public NEW_USER: string;\n  public NEW_COURSE: string;\n  public NEW_OPPORTUNITY: string;\n  public VERIFIED_OPPORTUNITY: string;\n  public NEW_COURSE_REVIEW: string;\n  public NEW_OPPORTUNITY_REVIEW: string;\n  public NEW_LEVEL: string;\n\n  /**\n   * Creates the Feed collection.\n   */\n  constructor() {\n    super('Feed', new SimpleSchema({\n      feedType: String,\n      description: String,\n      timestamp: Date,\n      picture: String,\n      userIDs: { type: Array }, 'userIDs.$': SimpleSchema.RegEx.Id,\n      opportunityID: { type: SimpleSchema.RegEx.Id, optional: true },\n      courseID: { type: SimpleSchema.RegEx.Id, optional: true },\n      termID: { type: SimpleSchema.RegEx.Id, optional: true },\n      retired: { type: Boolean, optional: true },\n    }));\n    this.NEW_USER = 'new-user';\n    this.NEW_COURSE = 'new-course';\n    this.NEW_OPPORTUNITY = 'new-opportunity';\n    this.VERIFIED_OPPORTUNITY = 'verified-opportunity';\n    this.NEW_COURSE_REVIEW = 'new-course-review';\n    this.NEW_OPPORTUNITY_REVIEW = 'new-opportunity-review';\n    this.NEW_LEVEL = 'new-level';\n    this.defineSchema = new SimpleSchema({\n      user: { type: String, optional: true },\n      course: { type: String, optional: true },\n      opportunity: { type: String, optional: true },\n      academicTerm: { type: String, optional: true },\n      level: { type: SimpleSchema.Integer, min: 1, max: 6, optional: true },\n      feedType: String,\n      timestamp: { type: Date, optional: true },\n    });\n    this.updateSchema = new SimpleSchema({\n      description: { type: String, optional: true },\n      picture: { type: String, optional: true },\n      userIDs: { type: Array, optional: true },\n      'userIDs.$': String,\n      opportunity: { type: String, optional: true },\n      course: { type: String, optional: true },\n      academicTerm: { type: String, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines a new Feed instance.\n   * @param feedDefinition An object representing the new Feed.\n   * feedDefinition must have a field named 'feedType' which should be one of the following strings:\n   * new-user, new-course, new-opportunity, new-verified-opportunity, new-course-review, or new-opportunity-review.\n   * Based upon the feedType, the object should contain additional fields providing the information necessary to\n   * define that new feed.\n   */\n  public define(feedDefinition: IFeedDefine) {\n    if (feedDefinition.feedType === this.NEW_USER) {\n      return this.defineNewUser(feedDefinition);\n    }\n    if (feedDefinition.feedType === this.NEW_COURSE) {\n      return this.defineNewCourse(feedDefinition);\n    }\n    if (feedDefinition.feedType === this.NEW_OPPORTUNITY) {\n      return this.defineNewOpportunity(feedDefinition);\n    }\n    if (feedDefinition.feedType === this.VERIFIED_OPPORTUNITY) {\n      return this.defineNewVerifiedOpportunity(feedDefinition);\n    }\n    if (feedDefinition.feedType === this.NEW_COURSE_REVIEW) {\n      return this.defineNewCourseReview(feedDefinition);\n    }\n    if (feedDefinition.feedType === this.NEW_OPPORTUNITY_REVIEW) {\n      return this.defineNewOpportunityReview(feedDefinition);\n    }\n    if (feedDefinition.feedType === this.NEW_LEVEL) {\n      return this.defineNewLevel(feedDefinition);\n    }\n    throw new Meteor.Error(`Unknown feed type: ${feedDefinition.feedType}`);\n  }\n\n  /**\n   * Update a Feed instance\n   * @param docID The docID to be updated.\n   * Description, pictures, users, opportunity, course, and academicTerm can be updated.\n   * The timestamp and feedtype fields cannot be updated once created.\n   * @throws { Meteor.Error } If docID is not defined, or if users, opportunity, or course are not defined.\n   */\n  public update(docID: string, { description, picture, users, opportunity, course, academicTerm, retired }: IFeedUpdate) {\n    this.assertDefined(docID);\n    const updateData: { description?: string; picture?: string; userIDs?: string[]; opportunityID?: string; courseID?: string; termID?: string; retired?: boolean; } = {};\n    if (description) {\n      updateData.description = description;\n    }\n    if (picture) {\n      updateData.picture = picture;\n    }\n    if (users) {\n      const userIDs = Users.getIDs(users);\n      updateData.userIDs = userIDs;\n    }\n    if (opportunity) {\n      updateData.opportunityID = Opportunities.getID(opportunity);\n    }\n    if (course) {\n      updateData.courseID = Courses.getID(course);\n    }\n    if (academicTerm) {\n      updateData.termID = AcademicTerms.getID(academicTerm);\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Adds user to the Feed.  If there is no new-user feed within the past day, then a new Feed is created and its\n   * docID is returned.\n   * If there is a new-user feed within the past day, then this user is added to that Feed instance and its\n   * docID is returned.\n   * @example\n   * Feeds._defineNewUser({ feedType: Feeds.NEW_USER,\n   *                      user: 'abi@hawaii.edu',\n   *                      timestamp: '12345465465' });\n   * @param { Object } description Object with keys user and timestamp.\n   * Note that user can be either a single username string or an array of usernames.\n   * @returns The newly created docID.\n   * @throws {Meteor.Error} If not a valid user.\n   */\n  private defineNewUser({ user, feedType, timestamp = moment().toDate(), retired = false }: IFeedDefine) {\n    // First, see if we've already defined any users within the past day.\n    const recentFeedID = this.checkPastDayFeed(this.NEW_USER);\n    // If there's a recentFeed, then update it instead with this user's info.\n    if (recentFeedID) {\n      this.updateNewUser(user, recentFeedID);\n      return recentFeedID;\n    }\n    // Otherwise create and return a new feed instance.\n    // First, create an array of users if we weren't passed one initially.\n    const users = (_.isArray(user)) ? user : [user];\n    const userIDs = Users.getIDs(users);\n    let picture = Users.getProfile(userIDs[0]).picture;\n    let description = 'A new user has joined RadGrad';\n    if (userIDs.length > 1) {\n      description = 'Multiple users have joined RadGrad';\n      picture = defaultProfilePicture;\n    }\n    const feedID = this.collection.insert({ userIDs, description, feedType, timestamp, picture, retired });\n    return feedID;\n  }\n\n  /**\n   * Defines a new Feed (new course).\n   * @example\n   * Feeds._defineNewCourse({ feedType: Feeds.NEW_COURSE,\n   *                        course: 'ics_100'\n   *                        timestamp: '12345465465', });\n   * @param { Object } description Object with keys course, feedType, and timestamp.\n   * @returns The newly created docID.\n   * @throws {Meteor.Error} If not a valid course.\n   */\n  private defineNewCourse({ course, feedType, timestamp = moment().toDate(), retired = false }: IFeedDefine) {\n    const courseID = Courses.getID(course);\n    const c = Courses.findDoc(courseID);\n    const description = `[${c.name}](/explorer/courses/${Slugs.getNameFromID(c.slugID)}) has been added to Courses`;\n    const picture = '/images/radgrad_logo.png';\n    const feedID = this.collection.insert({\n      userIDs: [],\n      courseID,\n      description,\n      feedType,\n      picture,\n      timestamp,\n      retired,\n    });\n    return feedID;\n  }\n\n  /**\n   * Defines a new Feed (new opportunity).\n   * @example\n   * Feeds._defineNewOpportunity({ feedType: Feeds.NEW_OPPORTUNITY,\n   *                             opportunity: 'att-hackathon'\n   *                             timestamp: '12345465465', });\n   * @param { Object } description Object with keys opportunity, feedType, and timestamp.\n   * @returns The newly created docID.\n   * @throws {Meteor.Error} If not a valid opportunity.\n   */\n  private defineNewOpportunity({ opportunity, feedType, timestamp = moment().toDate(), retired = false }: IFeedDefine) {\n    const opportunityID = Opportunities.getID(opportunity);\n    const o = Opportunities.findDoc(opportunityID);\n    const description = `[${o.name}](/explorer/opportunities/${Slugs.getNameFromID(o.slugID)}) has been added to Opportunities`;\n    const picture = '/images/radgrad_logo.png';\n    const feedID = this.collection.insert({\n      userIDs: [],\n      opportunityID,\n      description,\n      timestamp,\n      picture,\n      feedType,\n      retired,\n    });\n    return feedID;\n  }\n\n  /**\n   * Adds the verified opportunity to the Feed.\n   * If there is no verified-opportunity feed within the past day, then a new Feed instance is created and its docID\n   * is returned.\n   * If there is a verified-opportunity feed within the past day, then this info is added to it and its docID is\n   * returned.\n   * @example\n   * Feeds.defineNewVerifiedOpportunity({ feedType: Feeds.VERIFIED_OPPORTUNITY,\n   *                                      user: 'abi@hawaii.edu',\n   *                                      opportunity: 'att-hackathon'\n   *                                      academicTerm: 'Spring-2013'\n   *                                      timestamp: '12345465465', });\n   * @param { Object } description Object with keys user, opportunity, academicTerm, feedType, and timestamp.\n   * Note that user can be either a single username string or an array of usernames.\n   * @returns The docID associated with this info.\n   * @throws {Meteor.Error} If not a valid opportunity, academicTerm, or user.\n   */\n  private defineNewVerifiedOpportunity({ user, opportunity, academicTerm, feedType, timestamp = moment().toDate(), retired = false }: IFeedDefine) {\n    // First, see if we've already defined any verified-opportunities for this opportunity within the past day.\n    const recentFeedID = this.checkPastDayFeed(this.VERIFIED_OPPORTUNITY, opportunity);\n    // If there's a recentFeed, then update it instead with this user's info and return.\n    if (recentFeedID) {\n      this.updateVerifiedOpportunity(user, recentFeedID);\n      return recentFeedID;\n    }\n    // Otherwise, define a new feed instance.\n    const users = (_.isArray(user)) ? user : [user];\n    const userIDs = Users.getIDs(users);\n    const termID = AcademicTerms.getID(academicTerm);\n    const opportunityID = Opportunities.getID(opportunity);\n    const o = Opportunities.findDoc(opportunityID);\n    const description = `[${o.name}](/explorer/opportunities/${Slugs.getNameFromID(o.slugID)}) (${AcademicTerms.toString(termID, false)})\n    ${(userIDs.length > 1) ? ' was verified for multiple RadGrad students' : ' was verified for a RadGrad student'}`;\n    const picture = '/images/radgrad_logo.png';\n    const feedID = this.collection.insert({\n      userIDs,\n      opportunityID,\n      termID,\n      description,\n      timestamp,\n      picture,\n      feedType,\n      retired,\n    });\n    return feedID;\n  }\n\n  /**\n   * Defines a new Feed (new course review).\n   * @example\n   * Feeds.defineNewCourseReview({ feedType: Feeds.NEW_COURSE_REVIEW,\n   *                              user: 'abi@hawaii.edu',\n   *                              course: 'ics_111'\n   *                              timestamp: '12345465465', });\n   * @param { Object } description Object with keys user, course, feedType, and timestamp.\n   * User can either be the string username or an array containing a single username.\n   * @returns The newly created docID.\n   * @throws {Meteor.Error} If not a valid course or user.\n   */\n  private defineNewCourseReview({ user, course, feedType, timestamp = moment().toDate(), retired = false }: IFeedDefine) {\n    const userID = Users.getID((_.isArray(user)) ? user[0] : user);\n    const courseID = Courses.getID(course);\n    const c = Courses.findDoc(courseID);\n    const description = `A new course review has been added for [${c.name}](/explorer/courses/${Slugs.getNameFromID(c.slugID)})`;\n    const picture = '/images/radgrad_logo.png';\n    const feedID = this.collection.insert({\n      userIDs: [userID],\n      courseID,\n      description,\n      timestamp,\n      picture,\n      feedType,\n      retired,\n    });\n    return feedID;\n  }\n\n  /**\n   * Defines a new Feed (new opportunity review).\n   * @example\n   * Feeds._defineNewOpportunityReview({ feedType: Feeds.NEW_OPPORTUNITY_REVIEW,\n   *                                   user: 'abi@hawaii.edu',\n   *                                   opportunity: 'att-hackathon'\n   *                                   timestamp: '12345465465', });\n   * @param { Object } description Object with keys user, opportunity, feedType, and timestamp.\n   * User can either be the string username or an array containing a single username.\n   * @returns The newly created docID.\n   * @throws {Meteor.Error} If not a valid opportunity or user.\n   */\n  private defineNewOpportunityReview({ user, opportunity, feedType, timestamp = moment().toDate(), retired = false }: IFeedDefine) {\n    const userID = Users.getID((_.isArray(user)) ? user[0] : user);\n    const opportunityID = Opportunities.getID(opportunity);\n    const o = Opportunities.findDoc(opportunityID);\n    const description = `A new opportunity review has been added for [${o.name}](/explorer/opportunities/${Slugs.getNameFromID(o.slugID)})`;\n    const picture = '/images/radgrad_logo.png';\n    const feedID = this.collection.insert({\n      userIDs: [userID], opportunityID, description, timestamp, picture,\n      feedType, retired,\n    });\n    return feedID;\n  }\n\n  /**\n   * Defines a new Feed (new level).\n   * @example\n   * Feeds._defineNewLevel({ feedType: Feeds.NEW_LEVEL,\n   *                         user: 'abi@hawaii.edu'\n   *                         level: 6,\n   *                      });\n   * @param user the username.\n   * @param level the new level.\n   * @param feedType Feeds.NEW_LEVEL.\n   * @param timestamp The time of the Feed.\n   * @private\n   */\n  private defineNewLevel({ user, level, feedType, timestamp = moment().toDate(), retired = false }: IFeedDefine) {\n    // First, see if we've already defined any users within the past day.\n    const recentFeedID = this.checkPastDayLevelFeed(level, timestamp.toString());\n    // If there's a recentFeed, then update it instead with this user's info.\n    if (recentFeedID) {\n      this.updateNewLevel(user, recentFeedID, level);\n      return recentFeedID;\n    }\n\n    const userID = Users.getID((_.isArray(user)) ? user[0] : user);\n    const description = `A RadGrad student has achieved Level ${level}`;\n    let picture = Users.getProfile(userID).picture;\n    if (!picture) {\n      picture = defaultProfilePicture;\n    }\n    const feedID = this.collection.insert({\n      userIDs: [userID], description, timestamp, picture,\n      feedType, retired,\n    });\n    return feedID;\n  }\n\n  /**\n   * Returns a feedID with the same feedType (and opportunity, if feedType is Feeds.VERIFIED_OPPORTUNITY)\n   * if it exists within the past 24 hours.\n   * Returns false if no such feedID is found.\n   * Opportunity is required only if feedType is Feeds.VERIFIED_OPPORTUNITY\n   * @returns {Object} The feedID if found.\n   * @returns {boolean} False if feedID is not found.\n   */\n  public checkPastDayFeed(feedType: string, opportunity?: string, timestamp: any = moment().toDate()) {\n    let ret = '';\n    const instance = this;\n    const existingFeed = _.find(this.collection.find().fetch(), (feed) => {\n      if (withinPastDay(feed, timestamp)) {\n        if (feed.feedType === feedType) {\n          if (feedType === instance.VERIFIED_OPPORTUNITY) {\n            const opportunityID = Opportunities.getID(opportunity);\n            if (opportunityID === feed.opportunityID) {\n              return true;\n            }\n          } else {\n            return true;\n          }\n        }\n      }\n      return false;\n    });\n    if (existingFeed) {\n      ret = existingFeed._id;\n    }\n    return ret;\n  }\n\n  public checkPastDayLevelFeed(level, timestamp = moment().format()) {\n    let ret = '';\n    const instance = this;\n    const existingFeed = _.find(this.collection.find().fetch(), (feed) => {\n      if (withinPastDay(feed, timestamp)) {\n        if (feed.feedType === instance.NEW_LEVEL) {\n          // check the level\n          if (feed.description.includes(`${level}.`)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    });\n    if (existingFeed) {\n      ret = existingFeed._id;\n    }\n    return ret;\n  }\n\n  /**\n   * Updates the existingFeedID with the new userID information\n   * @param userID the new userID, existingFeedID the existing feed of the same type within the past 24 hours\n   * @throws {Meteor.Error} If username is not a username, or if existingFeedID is not a feedID.\n   */\n  private updateNewUser(username, existingFeedID) {\n    const userID = Users.getID(username);\n    this.assertDefined(existingFeedID);\n    const existingFeed = this.findDoc(existingFeedID);\n    const userIDs = existingFeed.userIDs;\n    userIDs.push(userID);\n    const description = 'Multiple users have joined RadGrad';\n    const picture = defaultProfilePicture;\n    this.collection.update(existingFeedID, { $set: { userIDs, description, picture } });\n  }\n\n  private updateNewLevel(user, existingFeedID, level) {\n    const userID = Users.getID((_.isArray(user)) ? user[0] : user);\n    this.assertDefined(existingFeedID);\n    const existingFeed = this.findDoc(existingFeedID);\n    const userIDs = existingFeed.userIDs;\n    userIDs.push(userID);\n    const description = `Multiple RadGrad students have achieved level ${level}`;\n    const picture = defaultProfilePicture;\n    this.collection.update(existingFeedID, { $set: { userIDs, description, picture } });\n  }\n\n  /**\n   * Updates the existingFeedID with the new userID information\n   * @param userID the new userID, existingFeedID the existing feed of the same type within the past 24 hours\n   * @throws {Meteor.Error} If username is not a username, or if existingFeedID is not a feedID.\n   */\n  private updateVerifiedOpportunity(username: string, existingFeedID: string) {\n    const userID = Users.getID(username);\n    this.assertDefined(existingFeedID);\n    const existingFeed = this.findDoc(existingFeedID);\n    const userIDs = existingFeed.userIDs;\n    userIDs.push(userID);\n    const o = Opportunities.findDoc(existingFeed.opportunityID);\n    const description = `[${o.name}](/explorer/opportunities/${Slugs.getNameFromID(o.slugID)}) (${AcademicTerms.toString(existingFeed.termID, false)}) has been verified for multiple RadGrad students`;\n    this.collection.update(existingFeedID, { $set: { userIDs, description } });\n  }\n\n  /**\n   * Removes all Feed documents referring to user.\n   * @param user The user, either the ID or the username.\n   * @throws { Meteor.Error } If user is not an ID or username.\n   */\n  public removeUser(user: string) {\n    const userID = Users.getID(user);\n    // There could be some collateral damage here, but whatever.\n    this.collection.remove({ userIDs: { $in: [userID] } });\n  }\n\n  /**\n   * Asserts that userId is logged in as an Admin, Faculty, Student, or Advisor.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not in the allowed roles.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.STUDENT, ROLE.FACULTY]);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks slugID, userID, opportunityID, and courseID.\n   * Note that userID, opportunityID, and courseID are all optional.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find().forEach((doc) => {\n      _.forEach(doc.userIDs, (userID) => {\n        if (!Users.isDefined(userID)) {\n          problems.push(`Bad userID: ${userID}`);\n        }\n      });\n      if (doc.opportunityID && !Opportunities.isDefined(doc.opportunityID)) {\n        problems.push(`Bad opportunityID: ${doc.opportunityID}`);\n      }\n      if (doc.courseID && !Courses.isDefined(doc.courseID)) {\n        problems.push(`Bad courseID: ${doc.courseID}`);\n      }\n      if (doc.termID && !AcademicTerms.isDefined(doc.termID)) {\n        problems.push(`Bad termID: ${doc.termID}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the Feed docID in a format acceptable to define().\n   * @param docID The docID of a Feed.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IFeedDefine {\n    const doc = this.findDoc(docID);\n    let user;\n    if (doc.userIDs) {\n      user = _.map(doc.userIDs, (userID) => Users.getProfile(userID).username);\n    }\n    let opportunity;\n    if (doc.opportunityID) {\n      opportunity = Opportunities.findSlugByID(doc.opportunityID);\n    }\n    let course;\n    if (doc.courseID) {\n      course = Courses.findSlugByID(doc.courseID);\n    }\n    let academicTerm;\n    if (doc.termID) {\n      academicTerm = AcademicTerms.findSlugByID(doc.termID);\n    }\n    const feedType = doc.feedType;\n    const timestamp = doc.timestamp;\n    const retired = doc.retired;\n    return { user, opportunity, course, academicTerm, feedType, timestamp, retired };\n  }\n\n  /**\n   * Publish a maximum of the last 25 feeds to users\n   */\n  public publish() {\n    if (Meteor.isServer) {\n      Meteor.publish(this.collectionName, () => this.collection.find({}, { sort: { timestamp: -1 }, limit: 25 }));\n    }\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @memberOf api/feed\n */\nexport const Feeds = new FeedCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/feed/FeedCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 528,
    "kind": "function",
    "name": "dateDiffInDays",
    "memberof": "api/feed/FeedCollection.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/feed/FeedCollection.ts~dateDiffInDays",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/feed/FeedCollection.ts",
    "importStyle": null,
    "description": "Returns the number of whole days between date a and b.",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "b",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 529,
    "kind": "function",
    "name": "withinPastDay",
    "memberof": "api/feed/FeedCollection.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/feed/FeedCollection.ts~withinPastDay",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/feed/FeedCollection.ts",
    "importStyle": null,
    "description": "Returns true if the timestamp associated with feed is within a day of timestamp.",
    "lineNumber": 36,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "feed",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "timestamp",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 530,
    "kind": "variable",
    "name": "Feeds",
    "memberof": "api/feed/FeedCollection.ts",
    "static": true,
    "longname": "api/feed/FeedCollection.ts~Feeds",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/feed/FeedCollection.ts",
    "importStyle": "{Feeds}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 590,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/feed"
      }
    ],
    "type": {
      "types": [
        "api/feed/FeedCollection.ts~FeedCollection"
      ]
    }
  },
  {
    "__docId__": 531,
    "kind": "class",
    "name": "FeedCollection",
    "memberof": "api/feed/FeedCollection.ts",
    "static": true,
    "longname": "api/feed/FeedCollection.ts~FeedCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/feed/FeedCollection.ts",
    "importStyle": null,
    "description": "Represents a feed instance.",
    "lineNumber": 48,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 532,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#constructor",
    "access": "public",
    "description": "Creates the Feed collection.",
    "lineNumber": 55
  },
  {
    "__docId__": 533,
    "kind": "member",
    "name": "NEW_USER",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#NEW_USER",
    "access": "public",
    "description": null,
    "lineNumber": 67,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 534,
    "kind": "member",
    "name": "NEW_COURSE",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#NEW_COURSE",
    "access": "public",
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 535,
    "kind": "member",
    "name": "NEW_OPPORTUNITY",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#NEW_OPPORTUNITY",
    "access": "public",
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 536,
    "kind": "member",
    "name": "VERIFIED_OPPORTUNITY",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#VERIFIED_OPPORTUNITY",
    "access": "public",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 537,
    "kind": "member",
    "name": "NEW_COURSE_REVIEW",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#NEW_COURSE_REVIEW",
    "access": "public",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 538,
    "kind": "member",
    "name": "NEW_OPPORTUNITY_REVIEW",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#NEW_OPPORTUNITY_REVIEW",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 539,
    "kind": "member",
    "name": "NEW_LEVEL",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#NEW_LEVEL",
    "access": "public",
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 540,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 541,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 83,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 542,
    "kind": "method",
    "name": "define",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#define",
    "access": "public",
    "description": "Defines a new Feed instance.",
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "IFeedDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "feedDefinition",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 543,
    "kind": "method",
    "name": "update",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#update",
    "access": "public",
    "description": "Update a Feed instance",
    "lineNumber": 140,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IFeedUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 544,
    "kind": "method",
    "name": "defineNewUser",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#defineNewUser",
    "access": "public",
    "description": "Adds user to the Feed.  If there is no new-user feed within the past day, then a new Feed is created and its\ndocID is returned.\nIf there is a new-user feed within the past day, then this user is added to that Feed instance and its\ndocID is returned.",
    "lineNumber": 182,
    "params": [
      {
        "nullable": null,
        "types": [
          "IFeedDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 545,
    "kind": "method",
    "name": "defineNewCourse",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#defineNewCourse",
    "access": "public",
    "description": "Defines a new Feed (new course).",
    "lineNumber": 214,
    "params": [
      {
        "nullable": null,
        "types": [
          "IFeedDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 546,
    "kind": "method",
    "name": "defineNewOpportunity",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#defineNewOpportunity",
    "access": "public",
    "description": "Defines a new Feed (new opportunity).",
    "lineNumber": 241,
    "params": [
      {
        "nullable": null,
        "types": [
          "IFeedDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 547,
    "kind": "method",
    "name": "defineNewVerifiedOpportunity",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#defineNewVerifiedOpportunity",
    "access": "public",
    "description": "Adds the verified opportunity to the Feed.\nIf there is no verified-opportunity feed within the past day, then a new Feed instance is created and its docID\nis returned.\nIf there is a verified-opportunity feed within the past day, then this info is added to it and its docID is\nreturned.",
    "lineNumber": 275,
    "params": [
      {
        "nullable": null,
        "types": [
          "IFeedDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 548,
    "kind": "method",
    "name": "defineNewCourseReview",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#defineNewCourseReview",
    "access": "public",
    "description": "Defines a new Feed (new course review).",
    "lineNumber": 317,
    "params": [
      {
        "nullable": null,
        "types": [
          "IFeedDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 549,
    "kind": "method",
    "name": "defineNewOpportunityReview",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#defineNewOpportunityReview",
    "access": "public",
    "description": "Defines a new Feed (new opportunity review).",
    "lineNumber": 347,
    "params": [
      {
        "nullable": null,
        "types": [
          "IFeedDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 550,
    "kind": "method",
    "name": "defineNewLevel",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#defineNewLevel",
    "access": "public",
    "description": "Defines a new Feed (new level).",
    "lineNumber": 373,
    "params": [
      {
        "nullable": null,
        "types": [
          "IFeedDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 551,
    "kind": "method",
    "name": "checkPastDayFeed",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#checkPastDayFeed",
    "access": "public",
    "description": "Returns a feedID with the same feedType (and opportunity, if feedType is Feeds.VERIFIED_OPPORTUNITY)\nif it exists within the past 24 hours.\nReturns false if no such feedID is found.\nOpportunity is required only if feedType is Feeds.VERIFIED_OPPORTUNITY",
    "lineNumber": 403,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "feedType",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opportunity",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "timestamp",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 552,
    "kind": "method",
    "name": "checkPastDayLevelFeed",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#checkPastDayLevelFeed",
    "access": "public",
    "description": "",
    "lineNumber": 427,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "level",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "timestamp",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 553,
    "kind": "method",
    "name": "updateNewUser",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#updateNewUser",
    "access": "public",
    "description": "Updates the existingFeedID with the new userID information",
    "lineNumber": 452,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "existingFeedID",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 554,
    "kind": "method",
    "name": "updateNewLevel",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#updateNewLevel",
    "access": "public",
    "description": "",
    "lineNumber": 463,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "existingFeedID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "level",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 555,
    "kind": "method",
    "name": "updateVerifiedOpportunity",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#updateVerifiedOpportunity",
    "access": "public",
    "description": "Updates the existingFeedID with the new userID information",
    "lineNumber": 479,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "existingFeedID",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 556,
    "kind": "method",
    "name": "removeUser",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#removeUser",
    "access": "public",
    "description": "Removes all Feed documents referring to user.",
    "lineNumber": 495,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 557,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Asserts that userId is logged in as an Admin, Faculty, Student, or Advisor.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 507,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 558,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks slugID, userID, opportunityID, and courseID.\nNote that userID, opportunityID, and courseID are all optional.",
    "lineNumber": 518,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 559,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the Feed docID in a format acceptable to define().",
    "lineNumber": 544,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IFeedDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 560,
    "kind": "method",
    "name": "publish",
    "memberof": "api/feed/FeedCollection.ts~FeedCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feed/FeedCollection.ts~FeedCollection#publish",
    "access": "public",
    "description": "Publish a maximum of the last 25 feeds to users",
    "lineNumber": 571,
    "params": [],
    "return": null
  },
  {
    "__docId__": 561,
    "kind": "file",
    "name": "api/feed/index.ts",
    "content": "/** @namespace api/feed */\nimport './FeedCollection';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/feed/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 562,
    "kind": "file",
    "name": "api/feedback/FeedbackFunctions.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { defineTestFixturesMethod } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('Feedback Functions Meteor Methods ', function test() {\n    // const collectionName = FeedbackInstances.getCollectionName();\n\n    before(function (done) {\n      this.timeout(5000);\n      defineTestFixturesMethod.call(['minimal', 'abi.student',\n        'extended.courses.interests', 'academicplan', 'abi.courseinstances'], done);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/feedback/FeedbackFunctions.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 563,
    "kind": "file",
    "name": "api/feedback/FeedbackFunctions.ts",
    "content": "import _ from 'lodash';\nimport { AcademicPlans } from '../degree-plan/AcademicPlanCollection';\nimport { CourseInstances } from '../course/CourseInstanceCollection';\nimport { Courses } from '../course/CourseCollection';\nimport { FeedbackInstances } from './FeedbackInstanceCollection';\nimport { clearFeedbackInstancesMethod } from './FeedbackInstanceCollection.methods';\nimport { defineMethod } from '../base/BaseCollection.methods';\nimport { OpportunityInstances } from '../opportunity/OpportunityInstanceCollection';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { StudentProfiles } from '../user/StudentProfileCollection';\nimport * as courseUtils from '../course/CourseUtilities';\nimport * as oppUtils from '../opportunity/OpportunityUtilities';\nimport * as yearUtils from '../degree-plan/AcademicYearUtilities';\nimport * as planUtils from '../degree-plan/PlanChoiceUtilities';\nimport { Slugs } from '../slug/SlugCollection';\nimport { Users } from '../user/UserCollection';\nimport { FavoriteAcademicPlans } from '../favorite/FavoriteAcademicPlanCollection';\n\n/**\n * Provides FeedbackFunctions. Each FeedbackFunction is a method of the singleton instance FeedbackFunctions.\n * Each FeedbackFunction accepts a studentID and updates the FeedbackInstanceCollection based upon the current state\n * of the student. Normally, the FeedbackFunction will first delete any FeedbackInstances it previously created\n * for that student (if any), then add new ones if appropriate.\n *\n * Note that FeedbackFunctions call Meteor Methods to define and delete FeedbackInstances, so these functions must\n * be called on the client side.\n * @example\n * import { FeedbackFunctions } from '../feedback/FeedbackFunctions';\n *   :\n * FeedbackFunctions.recommendedCoursesThisAcademicTermByInterest(studentID);\n * @class FeedbackFunctions\n * @memberOf api/feedback\n */\nexport class FeedbackFunctionClass {\n  public feedbackFunctionNames = [\n    'checkPrerequisites',\n    'checkCompletePlan',\n    'checkOverloadedAcademicTerms',\n    'generateRecommendedCourse',\n    'generateRecommended400LevelCourse',\n    'generateRecommendedCurrentAcademicTermOpportunities',\n    'generateNextLevelRecommendation',\n  ];\n\n  /**\n   * Checks the student's degree plan to ensure that all the prerequisites are met.\n   * @param user the student's ID.\n   */\n  public checkPrerequisites(user: string) {\n    const functionName = 'checkPrerequisites';\n    const feedbackType = FeedbackInstances.WARNING;\n    const currentAcademicTerm = AcademicTerms.getCurrentAcademicTermDoc();\n    const studentID = Users.getID(user);\n\n    // First clear any feedback instances previously created for this student.\n    clearFeedbackInstancesMethod.call({ user, functionName });\n\n    // Now iterate through all the CourseInstances associated with this student.\n    const cis = CourseInstances.find({ studentID }).fetch();\n    cis.forEach((ci) => {\n      const academicTerm = AcademicTerms.findDoc(ci.termID);\n      if (academicTerm.termNumber > currentAcademicTerm.termNumber) {\n        const academicTermName = AcademicTerms.toString(ci.termID, false);\n        const course = Courses.findDoc(ci.courseID);\n        if (course) {\n          const prereqs = course.prerequisites;\n          prereqs.forEach((p) => {\n            const courseID = Slugs.getEntityID(p, 'Course');\n            const prerequisiteCourse = Courses.findDoc({ _id: courseID });\n            const preCiIndex = _.findIndex(cis, (obj) => obj.courseID === courseID);\n            if (preCiIndex !== -1) {\n              const preCi = cis[preCiIndex];\n              const preCourse = Courses.findDoc(preCi.courseID);\n              const preAcademicTerm = AcademicTerms.findDoc(preCi.termID);\n              if (preAcademicTerm) {\n                if (preAcademicTerm.termNumber >= academicTerm.termNumber) {\n                  const academicTermName2 = AcademicTerms.toString(preAcademicTerm._id, false);\n                  const description = `${academicTermName}: ${course.num}'s prerequisite ${preCourse.num} is ` +\n                    `after or in ${academicTermName2}.`;\n                  const definitionData = { user, functionName, description, feedbackType };\n                  defineMethod.call({ collectionName: 'FeedbackInstanceCollection', definitionData });\n                }\n              }\n            } else {\n              const description = `${academicTermName}: Prerequisite ${prerequisiteCourse.num} for ${course.num}` +\n                ' not found.';\n              const definitionData = { user, functionName, description, feedbackType };\n              defineMethod.call({ collectionName: 'FeedbackInstanceCollection', definitionData });\n            }\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * Checks the student's degree plan to ensure that it satisfies the degree requirements.\n   * @param user the student's ID.\n   */\n  public checkCompletePlan(user: string) {\n    const functionName = 'checkCompletePlan';\n    console.log(`Running feedback function ${functionName}`);\n    const feedbackType = FeedbackInstances.WARNING;\n\n    // First clear any feedback instances previously created for this student.\n    clearFeedbackInstancesMethod.call({ user, functionName });\n\n    const studentProfile = Users.getProfile(user);\n    const courseIDs = StudentProfiles.getCourseIDs(user);\n    const favPlans = FavoriteAcademicPlans.find({ studentID: studentProfile.userID }).fetch();\n    _.forEach(favPlans, (fav) => {\n      let courses = [];\n      const academicPlan = AcademicPlans.findDoc(fav.academicPlanID);\n      courses = academicPlan.courseList.slice(0);\n      courses = this.missingCourses(courseIDs, courses);\n      if (courses.length > 0) {\n        let description = 'Your degree plan is missing: \\n\\n';\n        const basePath = this.getBasePath(user);\n        _.forEach(courses, (slug) => {\n          if (!planUtils.isSingleChoice(slug)) {\n            const slugs = planUtils.complexChoiceToArray(slug);\n            description = `${description}\\n\\n- `;\n            _.forEach(slugs, (s) => {\n              const id = Slugs.getEntityID(planUtils.stripCounter(s), 'Course');\n              const course = Courses.findDoc(id);\n              description = `${description} [${course.num} ${course.shortName}](${basePath}explorer/courses/${s}) or `;\n            });\n            description = description.substring(0, description.length - 4);\n            description = `${description}, `;\n          } else if (slug.indexOf('400+') !== -1) {\n            description = `${description} \\n- a 400 level elective, `;\n          } else if (slug.indexOf('300+') !== -1) {\n            description = `${description} \\n- a 300+ level elective, `;\n          } else {\n            const id = Slugs.getEntityID(planUtils.stripCounter(slug), 'Course');\n            const course = Courses.findDoc(id);\n            description = `${description} \\n- [${course.num} ${course.shortName}](${basePath}explorer/courses/${planUtils.stripCounter(slug)}), `;\n          }\n        });\n        description = description.substring(0, description.length - 2);\n        const definitionData = { user, functionName, description, feedbackType };\n        defineMethod.call({ collectionName: 'FeedbackInstanceCollection', definitionData });\n      }\n    });\n  }\n\n  /**\n   * Checks the student's degree plan to ensure that there aren't too many courses in any one academicTerm.\n   * @param user the student's ID.\n   */\n  public checkOverloadedAcademicTerms(user: string) {\n    const functionName = 'checkOverloadedAcademicTerms';\n    console.log(`Running feedback function ${functionName}`);\n    const feedbackType = FeedbackInstances.WARNING;\n    const studentID = Users.getID(user);\n\n    // First clear any feedback instances previously created for this student.\n    clearFeedbackInstancesMethod.call({ user, functionName });\n\n    const currentAcademicTerm = AcademicTerms.getCurrentAcademicTermDoc();\n    const academicTerms = yearUtils.getStudentTerms(user);\n    let haveOverloaded = false;\n    let description = 'Your plan is overloaded. ';\n    _.forEach(academicTerms, (termID) => {\n      const academicTerm = AcademicTerms.findDoc(termID);\n      if (academicTerm.termNumber > currentAcademicTerm.termNumber) {\n        const cis = CourseInstances.find({ studentID, termID, note: /ICS/ }).fetch();\n        if (cis.length > 2) {\n          haveOverloaded = true;\n          description = `${description} ${AcademicTerms.toString(termID, false)}, `;\n        }\n      }\n    });\n    description = description.substring(0, description.length - 2);\n    if (haveOverloaded) {\n      const definitionData = { user, functionName, description, feedbackType };\n      defineMethod.call({ collectionName: 'FeedbackInstanceCollection', definitionData });\n    }\n  }\n\n  /**\n   * Creates recommended courses based upon the student's interests. Only generates feedback if the student's plan\n   * is missing courses.\n   * @param user the student's ID.\n   */\n  public generateRecommendedCourse(user: string) {\n    const functionName = 'generateRecommendedCourse';\n    console.log(`Running feedback function ${functionName}`);\n    const feedbackType = FeedbackInstances.RECOMMENDATION;\n\n    // First clear any feedback instances previously created for this student.\n    clearFeedbackInstancesMethod.call({ user, functionName });\n\n    const coursesTakenSlugs = [];\n    const studentProfile = Users.getProfile(user);\n    const courseIDs = StudentProfiles.getCourseIDs(user);\n    const favPlans = FavoriteAcademicPlans.find({ studentID: studentProfile.userID }).fetch();\n    _.forEach(favPlans, (fav) => {\n      const academicPlanID = fav.academicPlanID;\n      const academicPlan = AcademicPlans.findDoc(academicPlanID);\n      const coursesNeeded = academicPlan.courseList.slice(0);\n      _.forEach(courseIDs, (cID) => {\n        const course = Courses.findDoc(cID);\n        coursesTakenSlugs.push(Slugs.getNameFromID(course.slugID));\n      });\n      const missing = this.missingCourses(courseIDs, coursesNeeded);\n      if (missing.length > 0) {\n        let description = 'Consider taking the following class to meet the degree requirement: ';\n        // if (missing.length > 1) {\n        //   description = 'Consider taking the following classes to meet the degree requirement: ';\n        // }\n        const basePath = this.getBasePath(user);\n        let slug = missing[0];\n        if (planUtils.isComplexChoice(slug) || planUtils.isSimpleChoice(slug)) {\n          slug = planUtils.complexChoiceToArray(slug);\n        }\n        if (Array.isArray(slug)) {\n          const course = courseUtils.chooseBetween(slug, user, coursesTakenSlugs);\n          if (course) {\n            const courseSlug = Slugs.findDoc(course.slugID);\n            description = `${description} \\n\\n- [${course.num} ${course.shortName}](${basePath}explorer/courses/${courseSlug.name}), `;\n          }\n        } else if (slug.startsWith('ics_4')) {\n          const bestChoice = courseUtils.chooseStudent400LevelCourse(user, coursesTakenSlugs);\n          if (bestChoice) {\n            const cSlug = Slugs.findDoc(bestChoice.slugID);\n            description = `${description} \\n- [${bestChoice.num} ${bestChoice.shortName}](${basePath}explorer/courses/${cSlug.name}), `;\n          }\n        } else if (slug.startsWith('ics')) {\n          const courseID = Slugs.getEntityID(planUtils.stripCounter(slug), 'Course');\n          const course = Courses.findDoc(courseID);\n          description = `${description} \\n\\n- [${course.num} ${course.shortName}](${basePath}explorer/courses/${slug}), `;\n        }\n        const definitionData = { user, functionName, description, feedbackType };\n        defineMethod.call({ collectionName: 'FeedbackInstanceCollection', definitionData });\n      }\n    });\n  }\n\n  public generateRecommended400LevelCourse(user: string) {\n    const functionName = 'generateRecommended400LevelCourse';\n    // console.log(`Running feedback function ${functionName}`);\n    const feedbackType = FeedbackInstances.RECOMMENDATION;\n\n    // First clear any feedback instances previously created for this student.\n    clearFeedbackInstancesMethod.call({ user, functionName });\n\n    const coursesTakenSlugs = [];\n    const studentProfile = Users.getProfile(user);\n    const courseIDs = StudentProfiles.getCourseIDs(user);\n    const favPlans = FavoriteAcademicPlans.find({ studentID: studentProfile.userID }).fetch();\n    _.forEach(favPlans, (fav) => {\n      const academicPlan = AcademicPlans.findDoc(fav.academicPlanID);\n      const coursesNeeded = academicPlan.courseList.slice(0);\n      _.forEach(courseIDs, (cID) => {\n        const course = Courses.findDoc(cID);\n        coursesTakenSlugs.push(Slugs.getNameFromID(course.slugID));\n      });\n      if (this.missingCourses(courseIDs, coursesNeeded).length > 0) {\n        let bestChoices = courseUtils.bestStudent400LevelCourses(user, coursesTakenSlugs);\n        const basePath = this.getBasePath(user);\n        if (bestChoices) {\n          const len = bestChoices.length;\n          if (len > 5) {\n            bestChoices = _.drop(bestChoices, len - 5);\n          }\n          let description = 'Consider taking the following classes to meet the degree requirement: ';\n          _.forEach(bestChoices, (course) => {\n            const slug = Slugs.findDoc(course.slugID);\n            description = `${description} \\n- [${course.num} ${course.shortName}](${basePath}explorer/courses/${slug.name}), `;\n          });\n          description = description.substring(0, description.length - 2);\n          const definitionData = { user, functionName, description, feedbackType };\n          defineMethod.call({ collectionName: 'FeedbackInstanceCollection', definitionData });\n        }\n      } else {\n        // TODO Why is this second call to clear needed? We do it at the top of this function.\n        clearFeedbackInstancesMethod.call({ user, functionName });\n      }\n    });\n  }\n\n  /**\n   * Creates a recommended opportunities FeedbackInstance for the given student and the current academicTerm.\n   * @param user the student's ID.\n   */\n  public generateRecommendedCurrentAcademicTermOpportunities(user: string) {\n    const functionName = 'generateRecommendedCurrentAcademicTermOpportunities';\n    // console.log(`Running feedback function ${functionName}`);\n    const feedbackType = FeedbackInstances.RECOMMENDATION;\n    const studentID = Users.getID(user);\n\n    // First clear any feedback instances previously created for this student.\n    clearFeedbackInstancesMethod.call({ user, functionName });\n\n    let bestChoices = oppUtils.getStudentCurrentAcademicTermOpportunityChoices(user);\n    const basePath = this.getBasePath(user);\n    const termID = AcademicTerms.getCurrentTermID();\n    const oppInstances = OpportunityInstances.find({ studentID, termID }).fetch();\n    if (oppInstances.length === 0) { // only make suggestions if there are no opportunities planned.\n      // console.log(bestChoices);\n      if (bestChoices) {\n        const len = bestChoices.length;\n        if (len > 3) {\n          bestChoices = _.drop(bestChoices, len - 3);\n        }\n        let description = 'Consider the following opportunities for this academicTerm: ';\n        _.forEach(bestChoices, (opp) => {\n          const slug = Slugs.findDoc(opp.slugID);\n          description = `${description} \\n- [${opp.name}](${basePath}explorer/opportunities/${slug.name}), `;\n        });\n        description = description.substring(0, description.length - 2);\n        const definitionData = { user, functionName, description, feedbackType };\n        defineMethod.call({ collectionName: 'FeedbackInstanceCollection', definitionData });\n      }\n    }\n  }\n\n  /**\n   * Creates a recommendation for getting to the next RadGrad Level.\n   * @param user The student's ID.\n   */\n  public generateNextLevelRecommendation(user: string) {\n    const functionName = 'generateNextLevelRecommendation';\n    // console.log(`Running feedback function ${functionName}`);\n    const feedbackType = FeedbackInstances.RECOMMENDATION;\n\n    // First clear any feedback instances previously created for this student.\n    clearFeedbackInstancesMethod.call({ user, functionName });\n\n    const studentProfile = Users.getProfile(user);\n    // Need to build the route not use current route since might be the Advisor.\n    const basePath = this.getBasePath(user);\n    let description = 'Getting to the next Level: ';\n    switch (studentProfile.level) {\n      case 0:\n        description = `${description} Take and pass [ICS 111](${basePath}explorer/courses/ics111) and [ICS 141](${basePath}explorer/courses/ics141)`;\n        break;\n      case 1:\n        description = `${description} Take and pass [ICS 211](${basePath}explorer/courses/ics211) and [ICS 241](${basePath}explorer/courses/ics241)`;\n        break;\n      case 2:\n        description = `${description} Get some innovation and experience [ICE points](${basePath}home/ice)`;\n        break;\n      case 3:\n        description = `${description} Get some more innovation and experience [ICE points](${basePath}home/ice)`;\n        break;\n      case 4:\n        description = `${description} Get some more innovation and experience [ICE points](${basePath}home/ice) and go review something.`;\n        break;\n      case 5:\n        description = `${description} Get some more innovation and experience [ICE points](${basePath}home/ice) and do more reviews.`;\n        break;\n      default:\n        description = '';\n    }\n    if (description) {\n      const definitionData = { user, functionName, description, feedbackType };\n      defineMethod.call({ collectionName: 'FeedbackInstanceCollection', definitionData });\n    }\n  }\n\n  /**\n   * Returns an array of the course slugs that are missing from the plan.\n   * @param courseIDs The IDs of the courses taken by the student.\n   * @param coursesNeeded An array of the course slugs needed for the degree.\n   * @return {*|Array.<T>}\n   */\n  private missingCourses(courseIDs, coursesNeeded) {\n    const planChoices = coursesNeeded.splice(0);\n    _.forEach(courseIDs, (id) => {\n      const course = Courses.findDoc(id);\n      const slug = Slugs.getNameFromID(course.slugID);\n      const index = planUtils.planIndexOf(planChoices, slug);\n      if (index !== -1) {\n        planChoices.splice(index, 1);\n      }\n    });\n    return planChoices;\n  }\n\n  private getBasePath(studentID) {\n    // console.log(studentID);\n    // const getPosition = (str, subString, index) => {\n    //   return str.split(subString, index).join(subString).length;\n    // };\n    // if (FlowRouter.current()) {\n    //   const currentRoute = FlowRouter.current().path;\n    //   if (currentRoute.startsWith('/advisor')) {\n    //     const username = Users.getProfile(studentID).username;\n    //     basePath = `/student/${username}/`;\n    //   } else {\n    //     const index = getPosition(currentRoute, '/', 3);\n    //     basePath = currentRoute.substring(0, index + 1);\n    //   }\n    // }\n    return '';\n  }\n}\n\n/**\n * Singleton instance for all FeedbackFunctions.\n * @type {FeedbackFunctionClass}\n * @memberOf api/feedback\n */\nexport const FeedbackFunctions = new FeedbackFunctionClass();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/feedback/FeedbackFunctions.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 564,
    "kind": "class",
    "name": "FeedbackFunctionClass",
    "memberof": "api/feedback/FeedbackFunctions.ts",
    "static": true,
    "longname": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/feedback/FeedbackFunctions.ts",
    "importStyle": "{FeedbackFunctionClass}",
    "description": "Provides FeedbackFunctions. Each FeedbackFunction is a method of the singleton instance FeedbackFunctions.\nEach FeedbackFunction accepts a studentID and updates the FeedbackInstanceCollection based upon the current state\nof the student. Normally, the FeedbackFunction will first delete any FeedbackInstances it previously created\nfor that student (if any), then add new ones if appropriate.\n\nNote that FeedbackFunctions call Meteor Methods to define and delete FeedbackInstances, so these functions must\nbe called on the client side.",
    "lineNumber": 34,
    "interface": false
  },
  {
    "__docId__": 565,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true
  },
  {
    "__docId__": 566,
    "kind": "member",
    "name": "feedbackFunctionNames",
    "memberof": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass",
    "static": false,
    "longname": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass#feedbackFunctionNames",
    "access": "public",
    "description": "",
    "lineNumber": 35,
    "type": {
      "types": [
        "string[]"
      ]
    }
  },
  {
    "__docId__": 567,
    "kind": "method",
    "name": "checkPrerequisites",
    "memberof": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass#checkPrerequisites",
    "access": "public",
    "description": "Checks the student's degree plan to ensure that all the prerequisites are met.",
    "lineNumber": 49,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 568,
    "kind": "method",
    "name": "checkCompletePlan",
    "memberof": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass#checkCompletePlan",
    "access": "public",
    "description": "Checks the student's degree plan to ensure that it satisfies the degree requirements.",
    "lineNumber": 100,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 569,
    "kind": "method",
    "name": "checkOverloadedAcademicTerms",
    "memberof": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass#checkOverloadedAcademicTerms",
    "access": "public",
    "description": "Checks the student's degree plan to ensure that there aren't too many courses in any one academicTerm.",
    "lineNumber": 151,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 570,
    "kind": "method",
    "name": "generateRecommendedCourse",
    "memberof": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass#generateRecommendedCourse",
    "access": "public",
    "description": "Creates recommended courses based upon the student's interests. Only generates feedback if the student's plan\nis missing courses.",
    "lineNumber": 186,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 571,
    "kind": "method",
    "name": "generateRecommended400LevelCourse",
    "memberof": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass#generateRecommended400LevelCourse",
    "access": "public",
    "description": "",
    "lineNumber": 240,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 572,
    "kind": "method",
    "name": "generateRecommendedCurrentAcademicTermOpportunities",
    "memberof": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass#generateRecommendedCurrentAcademicTermOpportunities",
    "access": "public",
    "description": "Creates a recommended opportunities FeedbackInstance for the given student and the current academicTerm.",
    "lineNumber": 287,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 573,
    "kind": "method",
    "name": "generateNextLevelRecommendation",
    "memberof": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass#generateNextLevelRecommendation",
    "access": "public",
    "description": "Creates a recommendation for getting to the next RadGrad Level.",
    "lineNumber": 323,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 574,
    "kind": "method",
    "name": "missingCourses",
    "memberof": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass#missingCourses",
    "access": "public",
    "description": "Returns an array of the course slugs that are missing from the plan.",
    "lineNumber": 369,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "courseIDs",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "coursesNeeded",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 575,
    "kind": "method",
    "name": "getBasePath",
    "memberof": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackFunctions.ts~FeedbackFunctionClass#getBasePath",
    "access": "public",
    "description": "",
    "lineNumber": 382,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 576,
    "kind": "variable",
    "name": "FeedbackFunctions",
    "memberof": "api/feedback/FeedbackFunctions.ts",
    "static": true,
    "longname": "api/feedback/FeedbackFunctions.ts~FeedbackFunctions",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/feedback/FeedbackFunctions.ts",
    "importStyle": "{FeedbackFunctions}",
    "description": "Singleton instance for all FeedbackFunctions.",
    "lineNumber": 437,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/feedback"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "FeedbackFunctionClass"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 577,
    "kind": "file",
    "name": "api/feedback/FeedbackInstanceCollection.methods.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { ValidatedMethod } from 'meteor/mdg:validated-method';\nimport { FeedbackInstances } from './FeedbackInstanceCollection';\n\n/**\n * Custom method for removing all the instances associated with a student and feedback function.\n * @memberOf api/feedback\n */\nexport const clearFeedbackInstancesMethod = new ValidatedMethod({\n  name: 'FeedbackInstances.clear',\n  validate: null,\n  run({ user, functionName }) {\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to clear FeedbackInstances.');\n    }\n    return FeedbackInstances.clear(user, functionName);\n  },\n});\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/feedback/FeedbackInstanceCollection.methods.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 578,
    "kind": "variable",
    "name": "clearFeedbackInstancesMethod",
    "memberof": "api/feedback/FeedbackInstanceCollection.methods.ts",
    "static": true,
    "longname": "api/feedback/FeedbackInstanceCollection.methods.ts~clearFeedbackInstancesMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/feedback/FeedbackInstanceCollection.methods.ts",
    "importStyle": "{clearFeedbackInstancesMethod}",
    "description": "Custom method for removing all the instances associated with a student and feedback function.",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/feedback"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 579,
    "kind": "file",
    "name": "api/feedback/FeedbackInstanceCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport {} from 'mocha';\nimport { FeedbackInstances } from './FeedbackInstanceCollection';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { removeAllEntities } from '../base/BaseUtilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('FeedbackInstanceCollection', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(5000);\n      fc.assert(\n        fc.property(fc.lorem(5), fc.lorem(20), fc.nat(FeedbackInstances.feedbackTypes.length - 1), fc.boolean(), (functionName, description, typeIndex, retired) => {\n          const userID = makeSampleUser();\n          const feedbackType = FeedbackInstances.feedbackTypes[typeIndex];\n          const docID = FeedbackInstances.define({ user: userID, functionName, description, feedbackType, retired });\n          expect(FeedbackInstances.isDefined(docID)).to.be.true;\n          FeedbackInstances.removeIt(docID);\n          expect(FeedbackInstances.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicates', function test2() {\n      const user = makeSampleUser();\n      const functionName = faker.lorem.words();\n      const description = faker.lorem.paragraph();\n      const feedbackType = FeedbackInstances.feedbackTypes[0];\n      const docID1 = FeedbackInstances.define({ user, functionName, description, feedbackType });\n      const docID2 = FeedbackInstances.define({ user, functionName, description, feedbackType });\n      expect(docID1).to.equal(docID2);\n      expect(FeedbackInstances.isDefined(docID1)).to.be.true;\n      FeedbackInstances.removeIt(docID2);\n      expect(FeedbackInstances.isDefined(docID1)).to.be.false;\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      const user = makeSampleUser();\n      const functionName = faker.lorem.words();\n      const description = faker.lorem.paragraph();\n      const feedbackType = FeedbackInstances.feedbackTypes[0];\n      const docID = FeedbackInstances.define({ user, functionName, description, feedbackType });\n      fc.assert(\n        fc.property(fc.lorem(5), fc.lorem(20), fc.nat(FeedbackInstances.feedbackTypes.length - 1), fc.boolean(), (funcName, descrip, typeIndex, retired) => {\n          const newUser = makeSampleUser();\n          const newFeedbackType = FeedbackInstances.feedbackTypes[typeIndex];\n          FeedbackInstances.update(docID, { user: newUser, description: descrip, functionName: funcName, feedbackType: newFeedbackType, retired });\n          const fi = FeedbackInstances.findDoc(docID);\n          expect(fi.userID).to.equal(newUser);\n          expect(fi.description).to.equal(descrip);\n          expect(fi.functionName).to.equal(funcName);\n          expect(fi.feedbackType).to.equal(newFeedbackType);\n          expect(fi.retired).to.equal(retired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      let fi = FeedbackInstances.findOne({});\n      let docID = fi._id;\n      const dumpObject = FeedbackInstances.dumpOne(docID);\n      FeedbackInstances.removeIt(docID);\n      expect(FeedbackInstances.isDefined(docID)).to.be.false;\n      docID = FeedbackInstances.restoreOne(dumpObject);\n      expect(FeedbackInstances.isDefined(docID)).to.be.true;\n      fi = FeedbackInstances.findDoc(docID);\n      expect(fi.description).to.equal(dumpObject.description);\n      expect(fi.functionName).to.equal(dumpObject.functionName);\n      expect(fi.feedbackType).to.equal(dumpObject.feedbackType);\n      expect(fi.retired).to.equal(dumpObject.retired);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const errors = FeedbackInstances.checkIntegrity();\n      expect(errors).to.have.lengthOf(0);\n    });\n\n    it('Can clear', function test6() {\n      const user = makeSampleUser();\n      const functionName = 'checkPrerequisites';\n      const description = 'The prereqs for ICS 314 were not satisfied.';\n      const feedbackType = FeedbackInstances.RECOMMENDATION;\n      const docID = FeedbackInstances.define({ user, functionName, description, feedbackType });\n      expect(FeedbackInstances.isDefined(docID)).to.be.true;\n      FeedbackInstances.clear(user, functionName);\n      expect(FeedbackInstances.isDefined(docID)).to.be.false;\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/feedback/FeedbackInstanceCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 580,
    "kind": "file",
    "name": "api/feedback/FeedbackInstanceCollection.ts",
    "content": "import _ from 'lodash';\nimport { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport { ROLE } from '../role/Role';\nimport { Users } from '../user/UserCollection';\nimport BaseCollection from '../base/BaseCollection';\nimport { IFeedbackInstanceDefine, IFeedbackInstanceUpdate } from '../../typings/radgrad';\n\n/**\n * Each FeedbackInstance represents one recommendation or warning for a user.\n * @extends api/base.BaseCollection\n * @memberOf api/feedback\n */\nclass FeedbackInstanceCollection extends BaseCollection {\n  public WARNING: string;\n  public RECOMMENDATION: string;\n  public feedbackTypes: string[];\n\n  /**\n   * Creates the FeedbackInstance collection.\n   */\n  constructor() {\n    super('FeedbackInstance', new SimpleSchema({\n      userID: { type: SimpleSchema.RegEx.Id },\n      functionName: String,\n      description: String,\n      feedbackType: String,\n      retired: { type: Boolean, optional: true },\n    }));\n    this.WARNING = 'Warning';\n    this.RECOMMENDATION = 'Recommendation';\n    this.feedbackTypes = [this.WARNING, this.RECOMMENDATION];\n    if (Meteor.isServer) {\n      this.collection._ensureIndex({ _id: 1, userID: 1, feedbackType: 1 });\n    }\n    this.defineSchema = new SimpleSchema({\n      user: String,\n      functionName: String,\n      description: String,\n      feedbackType: { type: String, allowedValues: this.feedbackTypes },\n      retired: { type: Boolean, optional: true },\n    });\n    this.updateSchema = new SimpleSchema({\n      user: { type: String, optional: true },\n      functionName: { type: String, optional: true },\n      description: { type: String, optional: true },\n      feedbackType: { type: String, allowedValues: this.feedbackTypes, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines a new FeedbackInstance.\n   * @example\n   * FeedbackInstances.define({ user: 'joesmith',\n   *                            functionName: 'checkPrerequisites',\n   *                            description: 'The prerequisite ICS 211 for the class ICS 314 is not satisfied.',\n   *                            feedbackType: 'Warning' });\n   * @param { Object } User, functionName, description, and feedbackType are all required.\n   * user must be a username or docID for a user (presumably a student).\n   * functionName is the name of a feedback function.\n   * Description is the string to appear as the feedback.\n   * feedbackType is either 'Recommendation' or 'Warning'.\n   * @throws {Meteor.Error} If user or feedbackType cannot be resolved.\n   * @returns The newly created docID.\n   */\n  public define({ user, functionName, description, feedbackType, retired = false }: IFeedbackInstanceDefine) {\n    // Validate Feedback and user.\n    const userID = Users.getID(user);\n    if (!_.includes(this.feedbackTypes, feedbackType)) {\n      throw new Meteor.Error(`FeedbackInstances.define passed illegal feedbackType: ${feedbackType}`);\n    }\n    const doc = this.collection.findOne({ userID, functionName, description, feedbackType });\n    if (doc) {\n      return doc._id;\n    }\n    // Define and return the new FeedbackInstance\n    const feedbackInstanceID = this.collection.insert({ userID, functionName, description, feedbackType, retired });\n    return feedbackInstanceID;\n  }\n\n  /**\n   * Update the course instance. Only a subset of fields can be updated.\n   * @param docID\n   * @param user\n   * @param description\n   * @param feedbackType\n   * @param functionName\n   */\n  public update(docID: string, { user, description, feedbackType, functionName, retired }: IFeedbackInstanceUpdate) {\n    this.assertDefined(docID);\n    const updateData: { userID?: string; description?: string; feedbackType?: string; functionName?: string; retired?: boolean; } = {};\n    if (user) {\n      updateData.userID = user;\n    }\n    if (description) {\n      updateData.description = description;\n    }\n    if (feedbackType) {\n      updateData.feedbackType = feedbackType;\n    }\n    if (functionName) {\n      updateData.functionName = functionName;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Returns the FeedbackInstance associated with the given user, functionName, and feedbackType.\n   * @param user The user (slug or ID)\n   * @param functionName The feedback function name.\n   * @param feedbackType The feedback type.\n   * @returns {any}\n   */\n  public findFeedbackInstance(user: string, functionName: string, feedbackType: string) {\n    const userID = Users.getID(user);\n    return this.collection.findOne({ userID, functionName, feedbackType });\n  }\n\n  /**\n   * Returns true if there exists a FeedbackInstance for the given user, functionName and feedbackType.\n   * @param user the user (slug or ID)\n   * @param functionName the feedback function name\n   * @param feedbackType the feedback type.\n   * @returns {boolean}\n   */\n  public isFeedbackInstance(user: string, functionName: string, feedbackType: string) {\n    return !!this.findFeedbackInstance(user, functionName, feedbackType);\n  }\n\n  /**\n   * Removes all FeedbackInstances associated with user and functionName.\n   * @param user The user (typically a student).\n   * @param functionName The FeedbackFunction name.\n   */\n  public clear(user: string, functionName: string) {\n    const userID = Users.getID(user);\n    this.collection.remove({ userID, functionName });\n  }\n\n  /**\n   * Removes all FeedbackInstance documents referring to user.\n   * @param user The user, either the ID or the username.\n   * @throws { Meteor.Error } If user is not an ID or username.\n   */\n  public removeUser(user: string) {\n    const userID = Users.getID(user);\n    this.collection.remove({ userID });\n  }\n\n  /**\n   * Returns a cursor to all the Warnings associated with this user.\n   * @param user The user of interest.\n   */\n  public findWarnings(user: string) {\n    const userID = Users.getID(user);\n    return this.collection.find({ userID, feedbackType: this.WARNING });\n  }\n\n  /**\n   * Returns a cursor to all the Warnings associated with this user.\n   * @param user The user of interest.\n   */\n  public findRecommendations(user: string) {\n    const userID = Users.getID(user);\n    return this.collection.find({ userID, feedbackType: this.RECOMMENDATION });\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\n   * user.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.STUDENT]);\n  }\n\n  /**\n   * Depending on the logged in user publish only their FeedbackInstances. If\n   * the user is in the Role.ADMIN then publish all FeedbackInstances.\n   */\n  public publish() {\n    if (Meteor.isServer) {\n      const instance = this;\n      // eslint-disable-next-line meteor/audit-argument-checks\n      Meteor.publish(this.collectionName, function publish(userID) {\n        if (_.isNil(userID)) {\n          return this.ready();\n        }\n        if (!this.userId) { // https://github.com/meteor/meteor/issues/9619\n          return this.ready();\n        }\n        const profile = Users.getProfile(userID);\n        if (profile.role === ROLE.ADMIN || Meteor.isAppTest) {\n          return instance.collection.find();\n        }\n        return instance.collection.find({ userID, retired: { $not: { $eq: true } } });\n      });\n    }\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks userID\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (!Users.isDefined(doc.userID)) {\n        problems.push(`Bad userID: ${doc.userID}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the FeedbackInstance docID in a format acceptable to define().\n   * @param docID The docID of a FeedbackInstance.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IFeedbackInstanceDefine {\n    const doc = this.findDoc(docID);\n    const user = Users.getProfile(doc.userID).username;\n    const functionName = doc.functionName;\n    const description = doc.description;\n    const feedbackType = doc.feedbackType;\n    const retired = doc.retired;\n    return { user, functionName, description, feedbackType, retired };\n  }\n\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @memberOf api/feedback\n */\nexport const FeedbackInstances = new FeedbackInstanceCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/feedback/FeedbackInstanceCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 581,
    "kind": "variable",
    "name": "FeedbackInstances",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts",
    "static": true,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstances",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/feedback/FeedbackInstanceCollection.ts",
    "importStyle": "{FeedbackInstances}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 259,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/feedback"
      }
    ],
    "type": {
      "types": [
        "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection"
      ]
    }
  },
  {
    "__docId__": 582,
    "kind": "class",
    "name": "FeedbackInstanceCollection",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts",
    "static": true,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/feedback/FeedbackInstanceCollection.ts",
    "importStyle": null,
    "description": "Each FeedbackInstance represents one recommendation or warning for a user.",
    "lineNumber": 14,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 583,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#constructor",
    "access": "public",
    "description": "Creates the FeedbackInstance collection.",
    "lineNumber": 17
  },
  {
    "__docId__": 584,
    "kind": "member",
    "name": "WARNING",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#WARNING",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 585,
    "kind": "member",
    "name": "RECOMMENDATION",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#RECOMMENDATION",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 586,
    "kind": "member",
    "name": "feedbackTypes",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#feedbackTypes",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 587,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 588,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 589,
    "kind": "method",
    "name": "define",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#define",
    "access": "public",
    "description": "Defines a new FeedbackInstance.",
    "lineNumber": 67,
    "params": [
      {
        "nullable": null,
        "types": [
          "IFeedbackInstanceDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 590,
    "kind": "method",
    "name": "update",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#update",
    "access": "public",
    "description": "Update the course instance. Only a subset of fields can be updated.",
    "lineNumber": 90,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IFeedbackInstanceUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 591,
    "kind": "method",
    "name": "findFeedbackInstance",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#findFeedbackInstance",
    "access": "public",
    "description": "Returns the FeedbackInstance associated with the given user, functionName, and feedbackType.",
    "lineNumber": 118,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "functionName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "feedbackType",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 592,
    "kind": "method",
    "name": "isFeedbackInstance",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#isFeedbackInstance",
    "access": "public",
    "description": "Returns true if there exists a FeedbackInstance for the given user, functionName and feedbackType.",
    "lineNumber": 130,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "functionName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "feedbackType",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 593,
    "kind": "method",
    "name": "clear",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#clear",
    "access": "public",
    "description": "Removes all FeedbackInstances associated with user and functionName.",
    "lineNumber": 139,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "functionName",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 594,
    "kind": "method",
    "name": "removeUser",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#removeUser",
    "access": "public",
    "description": "Removes all FeedbackInstance documents referring to user.",
    "lineNumber": 149,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 595,
    "kind": "method",
    "name": "findWarnings",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#findWarnings",
    "access": "public",
    "description": "Returns a cursor to all the Warnings associated with this user.",
    "lineNumber": 158,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 596,
    "kind": "method",
    "name": "findRecommendations",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#findRecommendations",
    "access": "public",
    "description": "Returns a cursor to all the Warnings associated with this user.",
    "lineNumber": 167,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 597,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\nuser.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 179,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 598,
    "kind": "method",
    "name": "publish",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#publish",
    "access": "public",
    "description": "Depending on the logged in user publish only their FeedbackInstances. If\nthe user is in the Role.ADMIN then publish all FeedbackInstances.",
    "lineNumber": 187,
    "params": [],
    "return": null
  },
  {
    "__docId__": 599,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks userID",
    "lineNumber": 213,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 600,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/feedback/FeedbackInstanceCollection.ts~FeedbackInstanceCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the FeedbackInstance docID in a format acceptable to define().",
    "lineNumber": 228,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IFeedbackInstanceDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 601,
    "kind": "file",
    "name": "api/feedback/index.ts",
    "content": "/** @namespace api/feedback */\nimport './FeedbackFunctions';\nimport './FeedbackInstanceCollection';\nimport './FeedbackInstanceCollection.methods';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/feedback/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 602,
    "kind": "file",
    "name": "api/help/HelpMessageCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { HelpMessages } from './HelpMessageCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('HelpMessageCollection Meteor Methods ', function test() {\n    const collectionName = HelpMessages.getCollectionName();\n    const routeName = 'Admin_Database_Dump_Page';\n    const definitionData = { routeName, title: 'Admin Database Dump Page', text: 'help!' };\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      await defineMethod.callPromise({ collectionName, definitionData });\n    });\n\n    it('Update Method', async function () {\n      const id = HelpMessages.findDocByRouteName(routeName)._id;\n      const title = 'new title';\n      const text = 'new help text';\n      await updateMethod.callPromise({ collectionName, updateData: { id, title, text } });\n    });\n\n    it('Remove Method', async function () {\n      const instance = HelpMessages.findDocByRouteName(routeName)._id;\n      await removeItMethod.callPromise({ collectionName, instance });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/help/HelpMessageCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 603,
    "kind": "file",
    "name": "api/help/HelpMessageCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport 'mocha';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { HelpMessages } from './HelpMessageCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('HelpMessageCollection', function testSuite() {\n\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function tearDown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(5000);\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(5), fc.lorem(20), fc.boolean(), (fcRoute, fcTitle, fcText, fcRetired) => {\n          const docID = HelpMessages.define({ routeName: fcRoute, title: fcTitle, text: fcText, retired: fcRetired });\n          expect(HelpMessages.isDefined(docID)).to.be.true;\n          const hm = HelpMessages.findDoc(docID);\n          expect(hm.routeName).to.equal(fcRoute);\n          expect(hm.title).to.equal(fcTitle);\n          expect(hm.text).to.equal(fcText);\n          expect(hm.retired).to.equal(fcRetired);\n          HelpMessages.removeIt(docID);\n          expect(HelpMessages.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicates', function test2() {\n      const routeName = faker.lorem.word();\n      const title = faker.lorem.words();\n      const text = faker.lorem.paragraph();\n      const docID1 = HelpMessages.define({ routeName, title, text });\n      const docID2 = HelpMessages.define({ routeName, title, text });\n      expect(docID1).to.equal(docID2);\n      expect(HelpMessages.isDefined(docID1)).to.be.true;\n      HelpMessages.removeIt(docID2);\n      expect(HelpMessages.isDefined(docID1)).to.be.false;\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      const routeName = faker.lorem.word();\n      const title = faker.lorem.words();\n      const text = faker.lorem.paragraph();\n      const docID = HelpMessages.define({ routeName, title, text });\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(5), fc.lorem(20), fc.boolean(), (fcRoute, fcTitle, fcText, fcRetired) => {\n          expect(HelpMessages.isDefined(docID)).to.be.true;\n          HelpMessages.update(docID, { routeName: fcRoute, title: fcTitle, text: fcText, retired: fcRetired });\n          const hm = HelpMessages.findDoc(docID);\n          expect(hm.routeName).to.equal(fcRoute);\n          expect(hm.title).to.equal(fcTitle);\n          expect(hm.text).to.equal(fcText);\n          expect(hm.retired).to.equal(fcRetired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      let hm = HelpMessages.findOne({});\n      const routeName = hm.routeName;\n      const title = hm.title;\n      const text = hm.text;\n      const retired = hm.retired;\n      let docID = hm._id;\n      const dumpObject = HelpMessages.dumpOne(docID);\n      HelpMessages.removeIt(docID);\n      expect(HelpMessages.isDefined(docID)).to.be.false;\n      docID = HelpMessages.restoreOne(dumpObject);\n      hm = HelpMessages.findDoc(docID);\n      expect(hm.routeName).to.equal(routeName);\n      expect(hm.title).to.equal(title);\n      expect(hm.text).to.equal(text);\n      expect(hm.retired).to.equal(retired);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      expect(HelpMessages.checkIntegrity()).to.have.lengthOf(0);\n    });\n\n    it('Can get by RouteName', function test6() {\n      const hm = HelpMessages.findOne({});\n      const routeName = hm.routeName;\n      const title = HelpMessages.getHelpTitle(routeName);\n      expect(title).to.equal(hm.title);\n      const text = HelpMessages.getHelpText(routeName);\n      expect(text).to.equal(hm.text);\n      const helpMessage = HelpMessages.findDocByRouteName(routeName);\n      expect(helpMessage).to.exist;\n      expect(helpMessage.title).to.equal(hm.title);\n      expect(helpMessage.text).to.equal(hm.text);\n      expect(helpMessage.retired).to.equal(hm.retired);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/help/HelpMessageCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 604,
    "kind": "file",
    "name": "api/help/HelpMessageCollection.ts",
    "content": "import SimpleSchema from 'simpl-schema';\nimport _ from 'lodash';\nimport BaseCollection from '../base/BaseCollection';\nimport { IHelpDefine, IHelpUpdate } from '../../typings/radgrad';\n\n/**\n * Represents a Help message for a RadGrad page.\n * @extends api/base.BaseCollection\n * @memberOf api/help\n */\nclass HelpMessageCollection extends BaseCollection {\n  /**\n   * Creates the HelpMessage collection.\n   */\n  constructor() {\n    super('HelpMessage', new SimpleSchema({\n      routeName: { type: String },\n      title: { type: String },\n      text: { type: String },\n      retired: { type: Boolean, optional: true },\n    }));\n    this.defineSchema = new SimpleSchema({\n      routeName: String,\n      title: String,\n      text: String,\n      retired: { type: Boolean, optional: true },\n    });\n    this.updateSchema = new SimpleSchema({\n      routeName: { type: String, optional: true },\n      title: { type: String, optional: true },\n      text: { type: String, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines the help for a given routeName.\n   * @param routeName the route name.\n   * @param title the title of the help.\n   * @param text the help text.\n   * @return {any} the ID of the help.\n   */\n  public define({ routeName, title, text, retired = false }: IHelpDefine): string {\n    const doc = this.collection.findOne({ routeName, title, text, retired });\n    if (doc) {\n      return doc._id;\n    }\n    return this.collection.insert({ routeName, title, text, retired });\n  }\n\n  /**\n   * Update a Help Message\n   * @param docID The docID to be updated.\n   * @param routeName The new routeName (optional).\n   * @param title The new title (optional)\n   * @param text New help text. (optional).\n   * @throws { Meteor.Error } If docID is not defined.\n   */\n  public update(docID: string, { routeName, title, text, retired }: IHelpUpdate) {\n    this.assertDefined(docID);\n    const updateData: IHelpUpdate = {};\n    if (routeName) {\n      updateData.routeName = routeName;\n    }\n    if (title) {\n      updateData.title = title;\n    }\n    if (text) {\n      updateData.text = text;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the Help Message..\n   * @param docID The docID of the entity to be removed.\n   * @throws { Meteor.Error } If docID is not a Help Message.\n   */\n  public removeIt(docID: string) {\n    this.assertDefined(docID);\n    // OK, clear to delete.\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Returns the text for the given routeName.\n   * @param routeName The route name.\n   */\n  public getHelpText(routeName: string): string {\n    return this.collection.findOne({ routeName }).text;\n  }\n\n  /**\n   * Returns the title for the given routeName.\n   * @param routeName The route name.\n   */\n  public getHelpTitle(routeName: string): string {\n    return this.collection.findOne({ routeName }).title;\n  }\n\n  /**\n   * Returns an empty array (no integrity checking done on this collection.)\n   * @returns {Array} An empty array.\n   */\n  public checkIntegrity(): string[] {\n    return [];\n  }\n\n  /**\n   * Returns the HelpMessage doc associated with RouteName.\n   * @param routeName The routeName\n   * @returns The doc, or null if not found.\n   */\n  public findDocByRouteName(routeName: string) {\n    return this.collection.findOne({ routeName });\n  }\n\n  /**\n   * Returns an object representing the HelpMessage docID in a format acceptable to define().\n   * @param docID The docID of a HelpMessage.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IHelpDefine {\n    const doc = this.findDoc(docID);\n    const routeName = doc.routeName;\n    const title = doc.title;\n    const text = doc.text;\n    const retired = doc.retired;\n    return { routeName, title, text, retired };\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @memberOf api/help\n * @type {api/help.HelpMessageCollection}\n */\nexport const HelpMessages = new HelpMessageCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/help/HelpMessageCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 605,
    "kind": "variable",
    "name": "HelpMessages",
    "memberof": "api/help/HelpMessageCollection.ts",
    "static": true,
    "longname": "api/help/HelpMessageCollection.ts~HelpMessages",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/help/HelpMessageCollection.ts",
    "importStyle": "{HelpMessages}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 161,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/help"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/help.HelpMessageCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 606,
    "kind": "class",
    "name": "HelpMessageCollection",
    "memberof": "api/help/HelpMessageCollection.ts",
    "static": true,
    "longname": "api/help/HelpMessageCollection.ts~HelpMessageCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/help/HelpMessageCollection.ts",
    "importStyle": null,
    "description": "Represents a Help message for a RadGrad page.",
    "lineNumber": 11,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 607,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/help/HelpMessageCollection.ts~HelpMessageCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/help/HelpMessageCollection.ts~HelpMessageCollection#constructor",
    "access": "public",
    "description": "Creates the HelpMessage collection.",
    "lineNumber": 14
  },
  {
    "__docId__": 608,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/help/HelpMessageCollection.ts~HelpMessageCollection",
    "static": false,
    "longname": "api/help/HelpMessageCollection.ts~HelpMessageCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 609,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/help/HelpMessageCollection.ts~HelpMessageCollection",
    "static": false,
    "longname": "api/help/HelpMessageCollection.ts~HelpMessageCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 610,
    "kind": "method",
    "name": "define",
    "memberof": "api/help/HelpMessageCollection.ts~HelpMessageCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/help/HelpMessageCollection.ts~HelpMessageCollection#define",
    "access": "public",
    "description": "Defines the help for a given routeName.",
    "lineNumber": 43,
    "params": [
      {
        "nullable": null,
        "types": [
          "IHelpDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 611,
    "kind": "method",
    "name": "update",
    "memberof": "api/help/HelpMessageCollection.ts~HelpMessageCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/help/HelpMessageCollection.ts~HelpMessageCollection#update",
    "access": "public",
    "description": "Update a Help Message",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IHelpUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 612,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/help/HelpMessageCollection.ts~HelpMessageCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/help/HelpMessageCollection.ts~HelpMessageCollection#removeIt",
    "access": "public",
    "description": "Remove the Help Message..",
    "lineNumber": 82,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 613,
    "kind": "method",
    "name": "getHelpText",
    "memberof": "api/help/HelpMessageCollection.ts~HelpMessageCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/help/HelpMessageCollection.ts~HelpMessageCollection#getHelpText",
    "access": "public",
    "description": "Returns the text for the given routeName.",
    "lineNumber": 92,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "routeName",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 614,
    "kind": "method",
    "name": "getHelpTitle",
    "memberof": "api/help/HelpMessageCollection.ts~HelpMessageCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/help/HelpMessageCollection.ts~HelpMessageCollection#getHelpTitle",
    "access": "public",
    "description": "Returns the title for the given routeName.",
    "lineNumber": 100,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "routeName",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 615,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/help/HelpMessageCollection.ts~HelpMessageCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/help/HelpMessageCollection.ts~HelpMessageCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an empty array (no integrity checking done on this collection.)",
    "lineNumber": 108,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 616,
    "kind": "method",
    "name": "findDocByRouteName",
    "memberof": "api/help/HelpMessageCollection.ts~HelpMessageCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/help/HelpMessageCollection.ts~HelpMessageCollection#findDocByRouteName",
    "access": "public",
    "description": "Returns the HelpMessage doc associated with RouteName.",
    "lineNumber": 117,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "routeName",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 617,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/help/HelpMessageCollection.ts~HelpMessageCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/help/HelpMessageCollection.ts~HelpMessageCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the HelpMessage docID in a format acceptable to define().",
    "lineNumber": 126,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IHelpDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 618,
    "kind": "file",
    "name": "api/help/index.ts",
    "content": "/** @namespace api/help */\nimport './HelpMessageCollection';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/help/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 619,
    "kind": "file",
    "name": "api/ice/IceProcessor.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport {} from 'mocha';\nimport { Courses } from '../course/CourseCollection';\nimport { CourseInstances } from '../course/CourseInstanceCollection';\nimport * as ICE from './IceProcessor';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { defineTestFixtures } from '../test/test-utilities';\nimport { Ice } from '../../typings/radgrad';\nimport { makeSampleIce } from './SampleIce';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('IceProcessor', function testSuite() {\n    it('Can check isICE and assertICE', function test1() {\n      const ice: Ice = makeSampleIce();\n      const notIce: { i: number; d: number; e: number; } = { i: 0, d: 10, e: 15 };\n      ICE.assertICE(ice);\n      expect(ICE.isICE(ice)).to.be.true;\n      expect(ICE.isICE(undefined)).to.be.false;\n      expect(() => ICE.assertICE(ice)).to.not.throw(Error);\n      expect(() => ICE.assertICE(notIce)).to.throw(Error);\n    });\n\n    it('Can makeCourseICE', function test2() {\n      expect(ICE.makeCourseICE('ics_111', 'A').c).to.equal(ICE.gradeCompetency.A);\n      expect(ICE.makeCourseICE('ics_112', 'A+').c).to.equal(ICE.gradeCompetency.A);\n      expect(ICE.makeCourseICE('ics_113', 'A-').c).to.equal(ICE.gradeCompetency.A);\n      expect(ICE.makeCourseICE('ics_113', 'A*').c).to.equal(ICE.gradeCompetency.C);\n      expect(ICE.makeCourseICE('ics_111', 'B+').c).to.equal(ICE.gradeCompetency.B);\n      expect(ICE.makeCourseICE('ics_111', 'B').c).to.equal(ICE.gradeCompetency.B);\n      expect(ICE.makeCourseICE('ics_111', 'B-').c).to.equal(ICE.gradeCompetency.B);\n      expect(ICE.makeCourseICE(Courses.unInterestingSlug, 'A').c).to.equal(ICE.gradeCompetency.C);\n    });\n\n    it('Can getEarnedICE and getProjectedICE', function test3(done) {\n      this.timeout(5000);\n      defineTestFixtures(['minimal', 'extended.courses.interests', 'abi.student', 'abi.courseinstances']);\n      const cis = CourseInstances.find().fetch();\n      const earnedICE = ICE.getEarnedICE(cis);\n      expect(ICE.isICE(earnedICE)).to.be.true;\n      expect(earnedICE.i).to.be.equal(0);\n      expect(earnedICE.c).to.be.equal(80);\n      expect(earnedICE.e).to.be.equal(0);\n      const projectedICE = ICE.getProjectedICE(cis);\n      expect(ICE.isICE(projectedICE)).to.be.true;\n      expect(projectedICE.i).to.be.equal(0);\n      expect(projectedICE.c).to.be.equal(116);\n      expect(projectedICE.e).to.be.equal(0);\n      removeAllEntities();\n      done();\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/ice/IceProcessor.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 620,
    "kind": "file",
    "name": "api/ice/IceProcessor.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport SimpleSchema from 'simpl-schema';\nimport { Courses } from '../course/CourseCollection';\nimport { Ice } from '../../typings/radgrad';\n\nexport const iceSchema = new SimpleSchema({\n  i: {\n    type: SimpleSchema.Integer,\n    min: 0,\n  },\n  c: {\n    type: SimpleSchema.Integer,\n    min: 0,\n  },\n  e: {\n    type: SimpleSchema.Integer,\n    min: 0,\n  },\n});\n\n/**\n * Polyfill definition of isInteger in case it's not defined.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger}\n * @type {*|Function}\n */\nNumber.isInteger = Number.isInteger ||\n    function test(value) {\n      return typeof value === 'number' &&\n          isFinite(value) &&\n          Math.floor(value) === value;\n    };\n\n/**\n * The competency points earned for each grade A, B, or C.\n * @memberOf api/ice\n */\nexport const gradeCompetency: { A: number; B: number; C: number; } = {\n  A: 10,\n  B: 6,\n  C: 0,\n};\n\n/**\n * Returns true if the object passed conforms to the ICE object specifications.\n * Note this does not test to see if additional fields are present.\n * @param obj The object, which must be an object with fields i, c, and e.\n * @returns {boolean} True if all fields are present and are numbers.\n * @memberOf api/ice\n */\nexport function isICE(obj: Ice): boolean {\n  return (((typeof obj) === 'object') && Number.isInteger(obj.i) && Number.isInteger(obj.c) && Number.isInteger(obj.e));\n}\n\n/**\n * Throws error if obj is not an ICE object.\n * @param obj The object to be tested for ICEness.\n * @throws { Meteor.Error } If obj is not ICE.\n * @memberOf api/ice\n */\nexport function assertICE(obj) {\n  if ((obj === null) || (typeof obj !== 'object') || !(isICE(obj))) {\n    throw new Meteor.Error(`${obj} was not an ICE object.`);\n  }\n}\n\n/**\n * Returns an ICE object based upon the course slug and the passed grade.\n * Students only earn ICE competency points for 'interesting' courses. Interesting\n * courses are courses that have non other slugs.\n * If an A, then return 9 competency points.\n * If a B, then return 5 competency points.\n * Otherwise return zero points.\n * @param course The course slug. If it's the \"uninteresting\" slug, then disregard it.\n * @param grade The grade\n * @returns {{i: number, c: number, e: number}} The ICE object.\n * @memberOf api/ice\n */\nexport function makeCourseICE(course, grade) {\n  const i = 0;\n  let c = 0;\n  const e = 0;\n  // Uninteresting courses get no ICE points.\n  if (course === Courses.unInterestingSlug) {\n    return { i, c, e };\n  }\n  // Courses get competency points only if you get an A or a B.\n  if (_.includes(['B+', 'B', 'B-'], grade)) {\n    c = gradeCompetency.B;\n  } else\n    if (_.includes(['A+', 'A', 'A-'], grade)) {\n      c = gradeCompetency.A;\n    }\n  return { i, c, e };\n}\n\n/**\n * Returns an ICE object that represents the earned ICE points from the passed Course\\Opportunity Instance Documents.\n * ICE values are counted only if verified is true.\n * @param docs An array of CourseInstance or OpportunityInstance documents.\n * @returns {{i: number, c: number, e: number}} The ICE object.\n * @memberOf api/ice\n */\nexport function getEarnedICE(docs) {\n  const total = { i: 0, c: 0, e: 0 };\n  docs.forEach((instance) => {\n    if (!(isICE(instance.ice))) {\n      throw new Meteor.Error(`getEarnedICE passed ${instance} without a valid .ice field.`);\n    }\n    if (instance.verified === true) {\n      total.i += instance.ice.i;\n      total.c += instance.ice.c;\n      total.e += instance.ice.e;\n    }\n    return null;\n  });\n  return total;\n}\n\n/**\n * Returns an ICE object that represents the total ICE points from the passed Course/Opportunity Instance Documents.\n * ICE values are counted whether or not they are verified.\n * @param docs An array of CourseInstance or OpportunityInstance documents.\n * @returns {{i: number, c: number, e: number}} The ICE object.\n * @memberOf api/ice\n */\nexport function getProjectedICE(docs) {\n  const total = { i: 0, c: 0, e: 0 };\n  docs.forEach((instance) => {\n    if (!(isICE(instance.ice))) {\n      throw new Meteor.Error(`getProjectedICE passed ${instance} without a valid .ice field.`);\n    }\n    total.i += instance.ice.i;\n    total.c += instance.ice.c;\n    total.e += instance.ice.e;\n    return null;\n  });\n  return total;\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/ice/IceProcessor.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 621,
    "kind": "variable",
    "name": "iceSchema",
    "memberof": "api/ice/IceProcessor.ts",
    "static": true,
    "longname": "api/ice/IceProcessor.ts~iceSchema",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/ice/IceProcessor.ts",
    "importStyle": "{iceSchema}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 622,
    "kind": "variable",
    "name": "gradeCompetency",
    "memberof": "api/ice/IceProcessor.ts",
    "static": true,
    "longname": "api/ice/IceProcessor.ts~gradeCompetency",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/ice/IceProcessor.ts",
    "importStyle": "{gradeCompetency}",
    "description": "The competency points earned for each grade A, B, or C.",
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/ice"
      }
    ],
    "type": {
      "types": [
        "{\"A\": number, \"B\": number, \"C\": *}"
      ]
    }
  },
  {
    "__docId__": 623,
    "kind": "function",
    "name": "isICE",
    "memberof": "api/ice/IceProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/ice/IceProcessor.ts~isICE",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/ice/IceProcessor.ts",
    "importStyle": "{isICE}",
    "description": "Returns true if the object passed conforms to the ICE object specifications.\nNote this does not test to see if additional fields are present.",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "Ice"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 624,
    "kind": "function",
    "name": "assertICE",
    "memberof": "api/ice/IceProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/ice/IceProcessor.ts~assertICE",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/ice/IceProcessor.ts",
    "importStyle": "{assertICE}",
    "description": "Throws error if obj is not an ICE object.",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "obj",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 625,
    "kind": "function",
    "name": "makeCourseICE",
    "memberof": "api/ice/IceProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/ice/IceProcessor.ts~makeCourseICE",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/ice/IceProcessor.ts",
    "importStyle": "{makeCourseICE}",
    "description": "Returns an ICE object based upon the course slug and the passed grade.\nStudents only earn ICE competency points for 'interesting' courses. Interesting\ncourses are courses that have non other slugs.\nIf an A, then return 9 competency points.\nIf a B, then return 5 competency points.\nOtherwise return zero points.",
    "lineNumber": 79,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "course",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "grade",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "{\"i\": *, \"c\": *, \"e\": *}"
      ]
    }
  },
  {
    "__docId__": 626,
    "kind": "function",
    "name": "getEarnedICE",
    "memberof": "api/ice/IceProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/ice/IceProcessor.ts~getEarnedICE",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/ice/IceProcessor.ts",
    "importStyle": "{getEarnedICE}",
    "description": "Returns an ICE object that represents the earned ICE points from the passed Course\\Opportunity Instance Documents.\nICE values are counted only if verified is true.",
    "lineNumber": 104,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docs",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 627,
    "kind": "function",
    "name": "getProjectedICE",
    "memberof": "api/ice/IceProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/ice/IceProcessor.ts~getProjectedICE",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/ice/IceProcessor.ts",
    "importStyle": "{getProjectedICE}",
    "description": "Returns an ICE object that represents the total ICE points from the passed Course/Opportunity Instance Documents.\nICE values are counted whether or not they are verified.",
    "lineNumber": 127,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docs",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 628,
    "kind": "file",
    "name": "api/ice/SampleIce.ts",
    "content": "import faker from 'faker';\n\nexport const makeSampleIce = () => {\n  const i = faker.random.number(100);\n  const c = faker.random.number(100);\n  const e = faker.random.number(100);\n  // console.log(`{ i = ${i}, c = ${c}, e = ${e} }`);\n  return { i, c, e };\n};\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/ice/SampleIce.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 629,
    "kind": "function",
    "name": "makeSampleIce",
    "memberof": "api/ice/SampleIce.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/ice/SampleIce.ts~makeSampleIce",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/ice/SampleIce.ts",
    "importStyle": "{makeSampleIce}",
    "description": null,
    "lineNumber": 2,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "{\"i\": *, \"c\": *, \"e\": *}"
      ]
    }
  },
  {
    "__docId__": 630,
    "kind": "file",
    "name": "api/ice/index.ts",
    "content": "/** @namespace api/ice */\nimport './IceProcessor';\nimport './SampleIce';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/ice/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 631,
    "kind": "file",
    "name": "api/index.ts",
    "content": "/** @namespace api */\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 632,
    "kind": "file",
    "name": "api/integrity/IntegrityChecker.methods.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport { ValidatedMethod } from 'meteor/mdg:validated-method';\nimport { checkIntegrity } from './IntegrityChecker';\nimport { ROLE } from '../role/Role';\nimport { Users } from '../user/UserCollection';\n\n/**\n * The check integrity ValidatedMethod.\n * @memberOf api/integrity\n */\nexport const checkIntegrityMethod = new ValidatedMethod({\n  name: 'IntegrityCheck',\n  validate: null,\n  run() {\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to check integrity.');\n    } else {\n      const profile = Users.getProfile(this.userId);\n      if (!_.includes([ROLE.ADMIN, ROLE.ADVISOR], profile.role)) {\n        throw new Meteor.Error('unauthorized', 'You must be an admin or advisor to check integrity.');\n      }\n    }\n    return checkIntegrity();\n  },\n});\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/integrity/IntegrityChecker.methods.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 633,
    "kind": "variable",
    "name": "checkIntegrityMethod",
    "memberof": "api/integrity/IntegrityChecker.methods.ts",
    "static": true,
    "longname": "api/integrity/IntegrityChecker.methods.ts~checkIntegrityMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/integrity/IntegrityChecker.methods.ts",
    "importStyle": "{checkIntegrityMethod}",
    "description": "The check integrity ValidatedMethod.",
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/integrity"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 634,
    "kind": "file",
    "name": "api/integrity/IntegrityChecker.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport moment from 'moment';\nimport { RadGrad } from '../radgrad/RadGrad';\n\n/**\n * Checks the integrity of all the collection classes in RadGrad.\n * @returns {{count: number, message: string}}\n * @memberOf api/integrity\n */\nexport function checkIntegrity() {\n  let message = `Integrity check results\n (${moment().format('MMM Do YYYY, H:mm:ss a')})`;\n  const startTime = moment();\n  let count = 0;\n  _.forEach(_.sortBy(RadGrad.collections, (c) => c.collectionName), (collection) => {\n    message += `\\n  ${collection.collectionName} (${collection.count()})`;\n    const collectionStrings = collection.checkIntegrity();\n    _.forEach(collectionStrings, (collectionString) => {\n      count += 1;\n      message += `\\n    ${collectionString}`;\n    });\n  });\n  message += `\\nTotal problems: ${count}`;\n  const endTime = moment();\n  message += `\\nElapsed time: ${endTime.diff(startTime, 'seconds', true)} seconds`;\n  return { count, message };\n}\n\n/**\n * Checks the integrity of the database, and throws an Error if there are any integrity problems.\n * @returns Null if nothing is wrong.\n * @throws { Meteor.Error } If there is an integrity problem.\n * @memberOf api/integrity\n */\nexport function assertIntegrity() {\n  console.log('assertIntegrity');\n  const { count, message } = checkIntegrity();\n  if (count > 0) {\n    throw new Meteor.Error(message);\n  }\n  return null;\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/integrity/IntegrityChecker.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 635,
    "kind": "function",
    "name": "checkIntegrity",
    "memberof": "api/integrity/IntegrityChecker.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/integrity/IntegrityChecker.ts~checkIntegrity",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/integrity/IntegrityChecker.ts",
    "importStyle": "{checkIntegrity}",
    "description": "Checks the integrity of all the collection classes in RadGrad.",
    "lineNumber": 11,
    "params": [],
    "return": {
      "types": [
        "{\"count\": *, \"message\": *}"
      ]
    }
  },
  {
    "__docId__": 636,
    "kind": "function",
    "name": "assertIntegrity",
    "memberof": "api/integrity/IntegrityChecker.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/integrity/IntegrityChecker.ts~assertIntegrity",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/integrity/IntegrityChecker.ts",
    "importStyle": "{assertIntegrity}",
    "description": "Checks the integrity of the database, and throws an Error if there are any integrity problems.",
    "lineNumber": 36,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 637,
    "kind": "file",
    "name": "api/integrity/index.ts",
    "content": "/** @namespace api/integrity */\nimport './IntegrityChecker';\nimport './IntegrityChecker.methods';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/integrity/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 638,
    "kind": "file",
    "name": "api/interest/InterestCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { Interests } from './InterestCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('InterestCollection Meteor Methods ', function test() {\n    const collectionName = Interests.getCollectionName();\n    const definitionData = {\n      name: 'name',\n      slug: 'interest-slug-example',\n      interestType: 'cs-disciplines',\n      description: 'description',\n    };\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      await defineMethod.callPromise({ collectionName, definitionData });\n    });\n\n    it('Update Method', async function () {\n      const id = Interests.findIdBySlug(definitionData.slug);\n      const name = 'updated interest name';\n      const description = 'updated description';\n      await updateMethod.callPromise({ collectionName, updateData: { id, name, description } });\n    });\n\n    it('Remove Method', async function () {\n      await removeItMethod.callPromise({ collectionName, instance: definitionData.slug });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/interest/InterestCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 639,
    "kind": "file",
    "name": "api/interest/InterestCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport 'mocha';\nimport { Interests } from './InterestCollection';\nimport { makeSampleInterestType } from './SampleInterests';\nimport { removeAllEntities } from '../base/BaseUtilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('InterestCollection', function testSuite() {\n\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(5000);\n      const interestTypeID = makeSampleInterestType();\n      fc.assert(\n        fc.property(fc.lorem(3), fc.lorem(1), fc.lorem(24), fc.boolean(), (fcName, fcSlug, fcDescription, fcRetired) => {\n          const docID = Interests.define({ name: fcName, slug: fcSlug, description: fcDescription, interestType: interestTypeID, retired: fcRetired });\n          expect(Interests.isDefined(docID)).to.be.true;\n          const interestDoc = Interests.findDoc(docID);\n          expect(interestDoc.name).to.equal(fcName);\n          expect(interestDoc.description).to.equal(fcDescription);\n          expect(interestDoc.interestTypeID).to.equal(interestTypeID);\n          expect(interestDoc.retired).to.equal(fcRetired);\n          Interests.removeIt(docID);\n          expect(Interests.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicates', function test2() {\n      const interestTypeID = makeSampleInterestType();\n      const name = faker.lorem.words();\n      const slug = faker.lorem.word();\n      const description = faker.lorem.paragraph();\n      const docID1 = Interests.define({ name, slug, description, interestType: interestTypeID });\n      expect(Interests.isDefined(docID1)).to.be.true;\n      expect(() => Interests.define({ name, slug, description, interestType: interestTypeID })).to.throw(Error);\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      let interestDoc = Interests.findOne({});\n      const docID = interestDoc._id;\n      fc.assert(\n        fc.property(fc.lorem(4), fc.lorem(24), fc.boolean(), (fcName, fcDescription, fcRetired) => {\n          const interestType = makeSampleInterestType();\n          Interests.update(docID, { name: fcName, description: fcDescription, interestType, retired: fcRetired });\n          interestDoc = Interests.findDoc(docID);\n          expect(interestDoc.name).to.equal(fcName);\n          expect(interestDoc.description).to.equal(fcDescription);\n          expect(interestDoc.interestTypeID).to.equal(interestType);\n          expect(interestDoc.retired).to.equal(fcRetired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      let interestDoc = Interests.findOne({});\n      let docID = interestDoc._id;\n      const dumpObject = Interests.dumpOne(docID);\n      Interests.removeIt(docID);\n      expect(Interests.isDefined(docID)).to.be.false;\n      docID = Interests.restoreOne(dumpObject);\n      interestDoc = Interests.findDoc(docID);\n      expect(interestDoc.name).to.equal(dumpObject.name);\n      expect(interestDoc.description).to.equal(dumpObject.description);\n      expect(interestDoc.retired).to.equal(dumpObject.retired);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const errors = Interests.checkIntegrity();\n      expect(errors).to.have.lengthOf(0);\n    });\n\n    // it('#assertDefined, assertAllDefined', function test() {\n    //   const docID = Interests.define(interest1);\n    //   expect(function foo() { Interests.assertDefined(docID); }).to.not.throw(Error);\n    //   expect(function foo() { Interests.assertDefined('foo'); }).to.throw(Error);\n    //   const docID2 = Interests.define(interest2);\n    //   expect(function foo() { Interests.assertAllDefined([docID, docID2]); }).to.not.throw(Error);\n    //   expect(function foo() { Interests.assertAllDefined(['foo']); }).to.throw(Error);\n    //   Interests.removeIt(slug);\n    //   Interests.removeIt(slug2);\n    // });\n\n    // it('#find, #findDoc, #findDocBySlug, #findIdBySlug, #findIdsBySlugs, #findNames', function test() {\n    //   const docID = Interests.define(interest1);\n    //   const docID2 = Interests.define(interest2);\n    //   expect(Interests.find().fetch()).to.have.lengthOf(2);\n    //   expect(function foo() { Interests.findDoc(docID); }).to.not.throw(Error);\n    //   expect(function foo() { Interests.findDoc('foo'); }).to.throw(Error);\n    //   expect(function foo() { Interests.findDocBySlug(slug); }).to.not.throw(Error);\n    //   expect(function foo() { Interests.findDocBySlug('foo'); }).to.throw(Error);\n    //   expect(function foo() { Interests.findIdBySlug(slug); }).to.not.throw(Error);\n    //   expect(function foo() { Interests.findIdsBySlugs([slug, slug2]); }).to.not.throw(Error);\n    //   expect(function foo() { Interests.findIdsBySlugs([slug, 'foo']); }).to.throw(Error);\n    //   expect(function foo() { Interests.findNames([docID, docID2]); }).to.not.throw(Error);\n    //   expect(function foo() { Interests.findNames([docID, 'foo']); }).to.throw(Error);\n    //   Interests.removeIt(slug);\n    //   Interests.removeIt(slug2);\n    // });\n\n    // it('#hasSlug', function test() {\n    //   const docID = Interests.define(interest1);\n    //   const slugID = Interests.findDoc(docID).slugID;\n    //   expect(Interests.hasSlug(slugID)).to.be.true;\n    //   expect(Interests.hasSlug('foo')).to.be.false;\n    //   Interests.removeIt(slug);\n    // });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/interest/InterestCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 640,
    "kind": "file",
    "name": "api/interest/InterestCollection.ts",
    "content": "import SimpleSchema from 'simpl-schema';\nimport { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport { Slugs } from '../slug/SlugCollection';\nimport { InterestTypes } from './InterestTypeCollection';\nimport { Courses } from '../course/CourseCollection';\nimport { CareerGoals } from '../career/CareerGoalCollection';\nimport { Opportunities } from '../opportunity/OpportunityCollection';\nimport { Teasers } from '../teaser/TeaserCollection';\nimport BaseSlugCollection from '../base/BaseSlugCollection';\nimport { IInterestDefine, IInterestUpdate } from '../../typings/radgrad';\n\n/**\n * Represents a specific interest, such as \"Software Engineering\".\n * Note that all Interests must have an associated InterestType.\n * @extends api/base.BaseSlugCollection\n * @memberOf api/interest\n */\nclass InterestCollection extends BaseSlugCollection {\n\n  /**\n   * Creates the Interest collection.\n   */\n  constructor() {\n    super('Interest', new SimpleSchema({\n      name: { type: String },\n      slugID: { type: SimpleSchema.RegEx.Id },\n      description: { type: String },\n      interestTypeID: { type: SimpleSchema.RegEx.Id },\n      retired: { type: Boolean, optional: true },\n    }));\n    this.defineSchema = new SimpleSchema({\n      name: String,\n      slug: String,\n      description: String,\n      interestType: String,\n      retired: { type: Boolean, optional: true },\n    });\n    this.updateSchema = new SimpleSchema({\n      name: { type: String, optional: true },\n      slug: { type: String, optional: true },\n      description: { type: String, optional: true },\n      interestType: { type: String, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines a new Interest and its associated Slug.\n   * @example\n   * Interests.define({ name: 'Software Engineering',\n   *                    slug: 'software-engineering',\n   *                    description: 'Methods for group development of large, high quality software systems',\n   *                    interestType: 'cs-disciplines' });\n   * @param { Object } description Object with keys name, slug, description, interestType.\n   * Slug must be previously undefined.\n   * InterestType must be an InterestType slug or ID.\n   * @throws {Meteor.Error} If the interest definition includes a defined slug or undefined interestType.\n   * @returns The newly created docID.\n   */\n  public define({ name, slug, description, interestType, retired = false }: IInterestDefine): string {\n    // console.log(`${this.collectionName}.define(${name}, ${slug}, ${description}, ${interestType}`);\n    // Get InterestTypeID, throw error if not found.\n    const interestTypeID = InterestTypes.getID(interestType);\n    // Get SlugID, throw error if found.\n    const slugID = Slugs.define({ name: slug, entityName: this.getType() });\n    // Define the Interest and get its ID\n    const interestID = this.collection.insert({ name, description, slugID, interestTypeID, retired });\n    // Connect the Slug to this Interest\n    Slugs.updateEntityID(slugID, interestID);\n    return interestID;\n  }\n\n  /**\n   * Update an Interest.\n   * @param docID The docID to be updated.\n   * @param name The new name (optional).\n   * @param description The new description (optional).\n   * @param interestType The new interestType slug or ID (optional).\n   * @throws { Meteor.Error } If docID is not defined, or if interestType is not valid.\n   */\n  public update(docID: string, { name, description, interestType, retired }: IInterestUpdate) {\n    this.assertDefined(docID);\n    const updateData: { name?: string, description?: string, interestTypeID?: string, retired?: boolean } = {};\n    if (name) {\n      updateData.name = name;\n    }\n    if (description) {\n      updateData.description = description;\n    }\n    if (interestType) {\n      const interestTypeID = InterestTypes.getID(interestType);\n      updateData.interestTypeID = interestTypeID;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n    return true;\n  }\n\n  /**\n   * Throws an error if docID (an interest) is referenced in any of the passed collections.\n   * @param collectionList A list of collection class instances.\n   * @param docID The docID of an interest.\n   * @throws { Meteor.Error } If the interest is referenced in any of the collections.\n   */\n  public assertUnusedInterest(collectionList, docID: string) {\n    const interest = this.findDoc(docID);\n    _.forEach(collectionList, (collection) => {\n      collection.find().map((doc) => {\n        if (collection.hasInterest(doc, docID)) {\n          throw new Meteor.Error(`Interest ${interest.name} is referenced by collection ${collection.collectionName}.`);\n        }\n        return true;\n      });\n    });\n  }\n\n  /**\n   * Remove the Interest.\n   * @param instance The docID or slug of the entity to be removed.\n   * @throws { Meteor.Error } If Interest is associated with any User, Course, Career Goal, or Opportunity.\n   */\n  public removeIt(instance: string) {\n    const docID = this.getID(instance);\n    // Check that this interest is not referenced by any User.\n    // TODO Should the profile collections be included below?\n    // No, but we need to check FavoriteInterests\n    this.assertUnusedInterest([Courses, CareerGoals, Opportunities, Teasers], docID);\n    // OK, clear to delete.\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Returns a list of Interest names corresponding to the passed list of Interest docIDs.\n   * @param instanceIDs A list of Interest docIDs.\n   * @returns { Array }\n   * @throws { Meteor.Error} If any of the instanceIDs cannot be found.\n   */\n  public findNames(instanceIDs: string[]) {\n    // console.log('Interests.findNames(%o)', instanceIDs);\n    return instanceIDs.map((instanceID) => this.findDoc(instanceID).name);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks slugID and interestTypeID.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find({}, {}).forEach((doc) => {\n      if (!Slugs.isDefined(doc.slugID)) {\n        problems.push(`Bad slugID: ${doc.slugID}`);\n      }\n      if (!InterestTypes.isDefined(doc.interestTypeID)) {\n        problems.push(`Bad interestTypeID: ${doc.interestTypeID}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the Interest docID in a format acceptable to define().\n   * @param docID The docID of an Interest.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID): IInterestDefine {\n    const doc = this.findDoc(docID);\n    const name = doc.name;\n    const slug = Slugs.getNameFromID(doc.slugID);\n    const description = doc.description;\n    const interestType = InterestTypes.findSlugByID(doc.interestTypeID);\n    const retired = doc.retired;\n    return { name, slug, description, interestType, retired };\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @type {api/interest.InterestCollection}\n * @memberOf api/interest\n */\nexport const Interests = new InterestCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/interest/InterestCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 641,
    "kind": "variable",
    "name": "Interests",
    "memberof": "api/interest/InterestCollection.ts",
    "static": true,
    "longname": "api/interest/InterestCollection.ts~Interests",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/interest/InterestCollection.ts",
    "importStyle": "{Interests}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 191,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/interest"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/interest.InterestCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 642,
    "kind": "class",
    "name": "InterestCollection",
    "memberof": "api/interest/InterestCollection.ts",
    "static": true,
    "longname": "api/interest/InterestCollection.ts~InterestCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/interest/InterestCollection.ts",
    "importStyle": null,
    "description": "Represents a specific interest, such as \"Software Engineering\".\nNote that all Interests must have an associated InterestType.",
    "lineNumber": 19,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseSlugCollection.js~BaseSlugCollection"
    ]
  },
  {
    "__docId__": 643,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/interest/InterestCollection.ts~InterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/interest/InterestCollection.ts~InterestCollection#constructor",
    "access": "public",
    "description": "Creates the Interest collection.",
    "lineNumber": 22
  },
  {
    "__docId__": 644,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/interest/InterestCollection.ts~InterestCollection",
    "static": false,
    "longname": "api/interest/InterestCollection.ts~InterestCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 645,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/interest/InterestCollection.ts~InterestCollection",
    "static": false,
    "longname": "api/interest/InterestCollection.ts~InterestCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 646,
    "kind": "method",
    "name": "define",
    "memberof": "api/interest/InterestCollection.ts~InterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/interest/InterestCollection.ts~InterestCollection#define",
    "access": "public",
    "description": "Defines a new Interest and its associated Slug.",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "IInterestDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 647,
    "kind": "method",
    "name": "update",
    "memberof": "api/interest/InterestCollection.ts~InterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/interest/InterestCollection.ts~InterestCollection#update",
    "access": "public",
    "description": "Update an Interest.",
    "lineNumber": 82,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IInterestUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 648,
    "kind": "method",
    "name": "assertUnusedInterest",
    "memberof": "api/interest/InterestCollection.ts~InterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/interest/InterestCollection.ts~InterestCollection#assertUnusedInterest",
    "access": "public",
    "description": "Throws an error if docID (an interest) is referenced in any of the passed collections.",
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "collectionList",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 649,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/interest/InterestCollection.ts~InterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/interest/InterestCollection.ts~InterestCollection#removeIt",
    "access": "public",
    "description": "Remove the Interest.",
    "lineNumber": 125,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 650,
    "kind": "method",
    "name": "findNames",
    "memberof": "api/interest/InterestCollection.ts~InterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/interest/InterestCollection.ts~InterestCollection#findNames",
    "access": "public",
    "description": "Returns a list of Interest names corresponding to the passed list of Interest docIDs.",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceIDs",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 651,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/interest/InterestCollection.ts~InterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/interest/InterestCollection.ts~InterestCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks slugID and interestTypeID.",
    "lineNumber": 152,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 652,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/interest/InterestCollection.ts~InterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/interest/InterestCollection.ts~InterestCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the Interest docID in a format acceptable to define().",
    "lineNumber": 170,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IInterestDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 653,
    "kind": "file",
    "name": "api/interest/InterestCollection.validators.ts",
    "content": "import { Interests } from './InterestCollection';\n\n/**\n * Custom validator for fields that must contain an Interest slug.\n * @returns Undefined if the value is an Interest slug, otherwise returns 'undefinedInterestSlug'.\n * @throws Error if there are no Slugs in the SlugCollection.\n * @memberOf api/interest\n */\nexport function isInterestSlugValidator() {\n  const ret = (Interests.hasSlug(this.value)) ? undefined : 'undefinedInterestSlug';\n  // console.log('isInterestSlugValidator', ret, this.value, Interests.hasSlug(this.value));\n  return ret;\n}\n\n/**\n * Custom validator for fields that must contain an Interest slug.\n * @returns Undefined if the value is an Interest slug, otherwise returns 'undefinedInterestSlug'.\n * @throws Error if there are no Slugs in the SlugCollection.\n * @memberOf api/interest\n */\nexport function isInterestArrayValidator() {\n  const ret = (Interests.hasSlug(this.value[0])) ? undefined : 'undefinedInterestSlug';\n  // console.log('isInterestSlugValidator', ret, this.value, Interests.hasSlug(this.value));\n  return ret;\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/interest/InterestCollection.validators.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 654,
    "kind": "function",
    "name": "isInterestSlugValidator",
    "memberof": "api/interest/InterestCollection.validators.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/interest/InterestCollection.validators.ts~isInterestSlugValidator",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/interest/InterestCollection.validators.ts",
    "importStyle": "{isInterestSlugValidator}",
    "description": "Custom validator for fields that must contain an Interest slug.",
    "lineNumber": 9,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 655,
    "kind": "function",
    "name": "isInterestArrayValidator",
    "memberof": "api/interest/InterestCollection.validators.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/interest/InterestCollection.validators.ts~isInterestArrayValidator",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/interest/InterestCollection.validators.ts",
    "importStyle": "{isInterestArrayValidator}",
    "description": "Custom validator for fields that must contain an Interest slug.",
    "lineNumber": 21,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 656,
    "kind": "file",
    "name": "api/interest/InterestTypeCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport 'mocha';\nimport { InterestTypes } from './InterestTypeCollection';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { Slugs } from '../slug/SlugCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('InterestTypeCollection', function testSuite() {\n    let name = 'Interest Name';\n    let slug = 'interest-slug';\n    let description = 'Interest Description';\n\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(5000);\n      fc.assert(\n        fc.property(fc.lorem(3), fc.lorem(1), fc.lorem(24), fc.boolean(), (fcName, fcSlug, fcDescription, fcRetired) => {\n          const docID = InterestTypes.define({\n            name: fcName,\n            slug: fcSlug,\n            description: fcDescription,\n            retired: fcRetired,\n          });\n          expect(InterestTypes.isDefined(docID)).to.be.true;\n          const typeDoc = InterestTypes.findDoc(docID);\n          expect(typeDoc.name).to.equal(fcName);\n          expect(typeDoc.description).to.equal(fcDescription);\n          expect(Slugs.getNameFromID(typeDoc.slugID)).to.equal(fcSlug);\n          expect(typeDoc.retired).to.equal(fcRetired);\n          InterestTypes.removeIt(docID);\n          expect(InterestTypes.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicates', function test2() {\n      name = faker.lorem.words();\n      slug = faker.lorem.word();\n      description = faker.lorem.paragraph();\n      const docID1 = InterestTypes.define({ name, slug, description });\n      expect(InterestTypes.isDefined(docID1)).to.be.true;\n      expect(() => InterestTypes.define({ name, slug, description })).to.throw(Error);\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      let typeDoc = InterestTypes.findOne({});\n      const docID = typeDoc._id;\n      fc.assert(\n        fc.property(fc.lorem(4), fc.lorem(24), fc.boolean(), (fcName, fcDescription, fcRetired) => {\n          InterestTypes.update(docID, { name: fcName, description: fcDescription, retired: fcRetired });\n          typeDoc = InterestTypes.findDoc(docID);\n          expect(typeDoc.name).to.equal(fcName);\n          expect(typeDoc.description).to.equal(fcDescription);\n          expect(typeDoc.retired).to.equal(fcRetired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      let typeDoc = InterestTypes.findOne({});\n      let docID = typeDoc._id;\n      const dumpObject = InterestTypes.dumpOne(docID);\n      InterestTypes.removeIt(docID);\n      expect(InterestTypes.isDefined(docID)).to.be.false;\n      docID = InterestTypes.restoreOne(dumpObject);\n      typeDoc = InterestTypes.findDoc(docID);\n      expect(typeDoc.name).to.equal(dumpObject.name);\n      expect(typeDoc.description).to.equal(dumpObject.description);\n      expect(typeDoc.retired).to.equal(dumpObject.retired);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const errors = InterestTypes.checkIntegrity();\n      expect(errors).to.have.lengthOf(0);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/interest/InterestTypeCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 657,
    "kind": "file",
    "name": "api/interest/InterestTypeCollection.ts",
    "content": "import _ from 'lodash';\nimport BaseTypeCollection from '../base/BaseTypeCollection';\nimport { ITypeDefine, ITypeUpdate } from '../../typings/radgrad';\n\n/**\n * InterestTypes help organize Interests into logically related groupings such as \"CS-Disciplines\", \"Locations\", etc.\n * @extends api/base.BaseTypeCollection\n * @memberOf api/interest\n */\nclass InterestTypeCollection extends BaseTypeCollection {\n\n  /**\n   * Creates the InterestType collection.\n   */\n  constructor() {\n    super('InterestType');\n  }\n\n  /**\n   * Defines a new InterestType with its name, slug, and description.\n   * @example\n   * InterestTypes.define({ name: 'Locations', slug: 'locations', description: 'Regions of interest.' });\n   * @param { Object } description Object with keys name, slug, and description.\n   * Slug must be globally unique and previously undefined.\n   * @throws { Meteor.Error } If the slug already exists.\n   * @returns The newly created docID.\n   */\n  public define({ name, slug, description, retired = false }: ITypeDefine) {\n    return super.define({ name, slug, description, retired });\n  }\n\n  /**\n   * Update an InterestType.\n   * @param docID the docID to be updated.\n   * @param name the new name (optional).\n   * @param description the new description (optional).\n   * @throws { Meteor.Error } If docID is not defined.\n   */\n  public update(docID, { name, description, retired }: ITypeUpdate) {\n    this.assertDefined(docID);\n    const updateData: ITypeUpdate = {};\n    if (!_.isNil(name)) {\n      updateData.name = name;\n    }\n    if (!_.isNil(description)) {\n      updateData.description = description;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n    return true;\n  }\n\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @type {api/interest.InterestTypeCollection}\n * @memberOf api/interest\n */\nexport const InterestTypes = new InterestTypeCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/interest/InterestTypeCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 658,
    "kind": "variable",
    "name": "InterestTypes",
    "memberof": "api/interest/InterestTypeCollection.ts",
    "static": true,
    "longname": "api/interest/InterestTypeCollection.ts~InterestTypes",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/interest/InterestTypeCollection.ts",
    "importStyle": "{InterestTypes}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 58,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/interest"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/interest.InterestTypeCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 659,
    "kind": "class",
    "name": "InterestTypeCollection",
    "memberof": "api/interest/InterestTypeCollection.ts",
    "static": true,
    "longname": "api/interest/InterestTypeCollection.ts~InterestTypeCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/interest/InterestTypeCollection.ts",
    "importStyle": null,
    "description": "InterestTypes help organize Interests into logically related groupings such as \"CS-Disciplines\", \"Locations\", etc.",
    "lineNumber": 10,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseTypeCollection.js~BaseTypeCollection"
    ]
  },
  {
    "__docId__": 660,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/interest/InterestTypeCollection.ts~InterestTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/interest/InterestTypeCollection.ts~InterestTypeCollection#constructor",
    "access": "public",
    "description": "Creates the InterestType collection.",
    "lineNumber": 13
  },
  {
    "__docId__": 661,
    "kind": "method",
    "name": "define",
    "memberof": "api/interest/InterestTypeCollection.ts~InterestTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/interest/InterestTypeCollection.ts~InterestTypeCollection#define",
    "access": "public",
    "description": "Defines a new InterestType with its name, slug, and description.",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "ITypeDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 662,
    "kind": "method",
    "name": "update",
    "memberof": "api/interest/InterestTypeCollection.ts~InterestTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/interest/InterestTypeCollection.ts~InterestTypeCollection#update",
    "access": "public",
    "description": "Update an InterestType.",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ITypeUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 663,
    "kind": "file",
    "name": "api/interest/MatchingInterests.ts",
    "content": "import _ from 'lodash';\nimport { Users } from '../user/UserCollection';\nimport { Interests } from './InterestCollection';\nimport { IInterest } from '../../typings/radgrad';\n\ninterface IHasInterests {\n  interestIDs: string[];\n}\n\nclass MatchingInterestsClass {\n  /**\n   * Returns the IInterests that match between ids1 and ids2.\n   * @param {string[]} ids1\n   * @param {string[]} ids2\n   * @returns {IInterest[]}\n   */\n  private matchingInterests(ids1: string[], ids2: string[]): IInterest[] {\n    const matching = [];\n    const interests1 = _.map(ids1, (id) => Interests.findDoc(id));\n    const interests2 = _.map(ids2, (id) => Interests.findDoc(id));\n    _.forEach(interests1, (interest1) => {\n      _.forEach(interests2, (interest2) => {\n        if (_.isEqual(interest1, interest2)) {\n          matching.push(interest2);\n        }\n      });\n    });\n    return matching;\n  }\n\n  /**\n   * Returns the matching user Interests for username and item.\n   * @param {string} username the name of the user.\n   * @param {IHasInterests} item the item with interestIDs.\n   * @returns {IInterest[]}\n   */\n  public matchingUserInterests(username: string, item: IHasInterests) {\n    const userInterestIDs = Users.getInterestIDsByType(username)[0];\n    return this.matchingInterests(userInterestIDs, item.interestIDs);\n  }\n\n  /**\n   * Returns the matching CareerGoal interests for username and item.\n   * @param {string} username the name of the user.\n   * @param {IHasInterests} item the item with interstIDs.\n   * @returns {IInterest[]}\n   */\n  public matchingCareerGoalInterests(username: string, item: IHasInterests) {\n    const userInterestIDs = Users.getInterestIDsByType(username)[1];\n    return this.matchingInterests(userInterestIDs, item.interestIDs);\n  }\n\n  /**\n   * Returns the Interests that don't match the user's interests.\n   * @param {string} username the user.\n   * @param {IHasInterests} item the item.\n   * @returns {IInterest[]}\n   */\n  public notMatchingInterests(username: string, item: IHasInterests) {\n    const userInterestIDs = Users.getInterestIDs(username);\n    const matches = this.matchingInterests(userInterestIDs, item.interestIDs);\n    const itemInterests = _.map(item.interestIDs, (id) => Interests.findDoc(id));\n    return _.filter(itemInterests, (courseInterest) => {\n      let ret = true;\n      _.forEach(matches, (matchingInterest) => {\n        if (_.isEqual(courseInterest, matchingInterest)) {\n          ret = false;\n        }\n      });\n      return ret;\n    });\n  }\n}\n\nexport const MatchingInterests = new MatchingInterestsClass();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/interest/MatchingInterests.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 664,
    "kind": "variable",
    "name": "MatchingInterests",
    "memberof": "api/interest/MatchingInterests.ts",
    "static": true,
    "longname": "api/interest/MatchingInterests.ts~MatchingInterests",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/interest/MatchingInterests.ts",
    "importStyle": "{MatchingInterests}",
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "type": {
      "types": [
        "api/interest/MatchingInterests.ts~MatchingInterestsClass"
      ]
    }
  },
  {
    "__docId__": 665,
    "kind": "class",
    "name": "MatchingInterestsClass",
    "memberof": "api/interest/MatchingInterests.ts",
    "static": true,
    "longname": "api/interest/MatchingInterests.ts~MatchingInterestsClass",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/interest/MatchingInterests.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 10,
    "pseudoExport": true,
    "interface": false
  },
  {
    "__docId__": 666,
    "kind": "method",
    "name": "matchingInterests",
    "memberof": "api/interest/MatchingInterests.ts~MatchingInterestsClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/interest/MatchingInterests.ts~MatchingInterestsClass#matchingInterests",
    "access": "public",
    "description": "Returns the IInterests that match between ids1 and ids2.",
    "lineNumber": 17,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "ids1",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "ids2",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 667,
    "kind": "method",
    "name": "matchingUserInterests",
    "memberof": "api/interest/MatchingInterests.ts~MatchingInterestsClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/interest/MatchingInterests.ts~MatchingInterestsClass#matchingUserInterests",
    "access": "public",
    "description": "Returns the matching user Interests for username and item.",
    "lineNumber": 37,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IHasInterests"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 668,
    "kind": "method",
    "name": "matchingCareerGoalInterests",
    "memberof": "api/interest/MatchingInterests.ts~MatchingInterestsClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/interest/MatchingInterests.ts~MatchingInterestsClass#matchingCareerGoalInterests",
    "access": "public",
    "description": "Returns the matching CareerGoal interests for username and item.",
    "lineNumber": 48,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IHasInterests"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 669,
    "kind": "method",
    "name": "notMatchingInterests",
    "memberof": "api/interest/MatchingInterests.ts~MatchingInterestsClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/interest/MatchingInterests.ts~MatchingInterestsClass#notMatchingInterests",
    "access": "public",
    "description": "Returns the Interests that don't match the user's interests.",
    "lineNumber": 59,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IHasInterests"
        ],
        "spread": false,
        "optional": false,
        "name": "item",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 670,
    "kind": "file",
    "name": "api/interest/SampleInterests.ts",
    "content": "import moment from 'moment';\nimport faker from 'faker';\nimport _ from 'lodash';\nimport { InterestTypes } from './InterestTypeCollection';\nimport { Interests } from './InterestCollection';\nimport slugify, { Slugs } from '../slug/SlugCollection';\n\n/**\n * Creates an InterestType with a unique slug and returns its docID.\n * @returns { String } The docID of the newly generated InterestType.\n * @memberOf api/interest\n */\nexport function makeSampleInterestType(): string {\n  const name = faker.lorem.word();\n  const slug = `${name}-type-${moment().format('YYYY-MM-DD-HH-mm-ss-SSSSS')}`;\n  const description = faker.lorem.paragraph();\n  // console.log('makeSampleInterestType', name, slug, description);\n  return InterestTypes.define({ name, slug, description });\n}\n\n/**\n * Creates an Interest with a unique slug and returns its docID.\n * Also creates a new InterestType.\n * @returns { String } The docID for the newly generated Interest.\n * @memberOf api/interest\n */\nexport function makeSampleInterest(): string {\n  const interestType = makeSampleInterestType();\n  const name = faker.lorem.word();\n  const slug = slugify(`${name}-${moment().format('YYYY-MM-DD-HH-mm-ss-SSSSS')}`);\n  const description = faker.lorem.paragraph();\n  // console.log('makeSampleInterest', { name, slug, description, interestType });\n  return Interests.define({ name, slug, description, interestType });\n}\n\n/**\n * Returns an array of interestIDs.\n * @param {number} numInterests the number of interestIDs. Defaults to 1.\n * @returns {string[]}\n */\nexport function makeSampleInterestArray(numInterests: number = 1): string[] {\n  const retVal = [];\n  for (let i = 0; i < numInterests; i++) {\n    retVal.push(makeSampleInterest());\n  }\n  return retVal;\n}\n\n/**\n * Returns an array of defined Interest slugs.\n * @param numInterests the number of Interests to define. Defaults to 1.\n * @return {string[]} An array of defined Interest Slugs.\n */\nexport function makeSampleInterestSlugArray(numInterests = 1): string[] {\n  const ids = makeSampleInterestArray(numInterests);\n  return _.map(ids, (id) => {\n    const doc = Interests.findDoc(id);\n    return Slugs.getNameFromID(doc.slugID);\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/interest/SampleInterests.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 671,
    "kind": "function",
    "name": "makeSampleInterestType",
    "memberof": "api/interest/SampleInterests.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/interest/SampleInterests.ts~makeSampleInterestType",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/interest/SampleInterests.ts",
    "importStyle": "{makeSampleInterestType}",
    "description": "Creates an InterestType with a unique slug and returns its docID.",
    "lineNumber": 13,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 672,
    "kind": "function",
    "name": "makeSampleInterest",
    "memberof": "api/interest/SampleInterests.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/interest/SampleInterests.ts~makeSampleInterest",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/interest/SampleInterests.ts",
    "importStyle": "{makeSampleInterest}",
    "description": "Creates an Interest with a unique slug and returns its docID.\nAlso creates a new InterestType.",
    "lineNumber": 27,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 673,
    "kind": "function",
    "name": "makeSampleInterestArray",
    "memberof": "api/interest/SampleInterests.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/interest/SampleInterests.ts~makeSampleInterestArray",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/interest/SampleInterests.ts",
    "importStyle": "{makeSampleInterestArray}",
    "description": "Returns an array of interestIDs.",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "numInterests",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 674,
    "kind": "function",
    "name": "makeSampleInterestSlugArray",
    "memberof": "api/interest/SampleInterests.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/interest/SampleInterests.ts~makeSampleInterestSlugArray",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/interest/SampleInterests.ts",
    "importStyle": "{makeSampleInterestSlugArray}",
    "description": "Returns an array of defined Interest slugs.",
    "lineNumber": 54,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "numInterests",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 675,
    "kind": "file",
    "name": "api/interest/index.ts",
    "content": "/** @namespace api/interest */\n\nimport './InterestCollection';\nimport './InterestTypeCollection';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/interest/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 676,
    "kind": "file",
    "name": "api/level/LevelProcessor.methods.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport { ValidatedMethod } from 'meteor/mdg:validated-method';\nimport { updateStudentLevel, updateAllStudentLevels, defaultCalcLevel } from './LevelProcessor';\nimport { ROLE } from '../role/Role';\nimport { RadGrad } from '../radgrad/RadGrad';\nimport { Users } from '../user/UserCollection';\n\n/**\n * The LevelProcessor calcLevel ValidatedMethod.\n * @memberOf api/level\n */\nexport const calcLevelMethod = new ValidatedMethod({\n  name: 'LevelProcessor.calcLevel',\n  validate: null,\n  run({ studentID }) {\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to calculate Levels.');\n    }\n    const profile = Users.getProfile(this.userId);\n    if (!_.includes([ROLE.ADMIN, ROLE.ADVISOR], profile.role)) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in as ADMIN or ADVISOR to calculate Levels.');\n    }\n    if (RadGrad.calcLevel) {\n      return RadGrad.calcLevel(studentID);\n    }\n    return defaultCalcLevel(studentID);\n  },\n});\n\n/**\n * The LevelProcessor updateLevel ValidatedMethod.\n * @memberOf api/level\n */\nexport const updateLevelMethod = new ValidatedMethod({\n  name: 'LevelProcessor.updateLevel',\n  validate: null,\n  run({ studentID }) {\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to calculate Levels.');\n    }\n    const profile = Users.getProfile(this.userId);\n    if (!_.includes([ROLE.ADMIN, ROLE.ADVISOR], profile.role)) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in as ADMIN or ADVISOR to calculate Levels.');\n    }\n    updateStudentLevel(this.userId, studentID);\n  },\n});\n\n/**\n * The LevelProcessor update all students' level validated method.\n * @memberOf api/level\n */\nexport const updateAllStudentLevelsMethod = new ValidatedMethod({\n  name: 'LevelProcessor.updateAllStudentLevels',\n  validate: null,\n  run() {\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to calculate Levels.');\n    }\n    const profile = Users.getProfile(this.userId);\n    if (!_.includes([ROLE.ADMIN, ROLE.ADVISOR], profile.role)) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in as ADMIN or ADVISOR to calculate Levels.');\n    }\n    const count = updateAllStudentLevels(this.userId);\n    return `Updated ${count} students' levels.`;\n  },\n});\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/level/LevelProcessor.methods.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 677,
    "kind": "variable",
    "name": "calcLevelMethod",
    "memberof": "api/level/LevelProcessor.methods.ts",
    "static": true,
    "longname": "api/level/LevelProcessor.methods.ts~calcLevelMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/level/LevelProcessor.methods.ts",
    "importStyle": "{calcLevelMethod}",
    "description": "The LevelProcessor calcLevel ValidatedMethod.",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/level"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 678,
    "kind": "variable",
    "name": "updateLevelMethod",
    "memberof": "api/level/LevelProcessor.methods.ts",
    "static": true,
    "longname": "api/level/LevelProcessor.methods.ts~updateLevelMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/level/LevelProcessor.methods.ts",
    "importStyle": "{updateLevelMethod}",
    "description": "The LevelProcessor updateLevel ValidatedMethod.",
    "lineNumber": 41,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/level"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 679,
    "kind": "variable",
    "name": "updateAllStudentLevelsMethod",
    "memberof": "api/level/LevelProcessor.methods.ts",
    "static": true,
    "longname": "api/level/LevelProcessor.methods.ts~updateAllStudentLevelsMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/level/LevelProcessor.methods.ts",
    "importStyle": "{updateAllStudentLevelsMethod}",
    "description": "The LevelProcessor update all students' level validated method.",
    "lineNumber": 67,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/level"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 680,
    "kind": "file",
    "name": "api/level/LevelProcessor.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport {} from 'mocha';\nimport { StudentProfiles } from '../user/StudentProfileCollection';\nimport { defaultCalcLevel } from './LevelProcessor';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { RadGrad } from '../radgrad/RadGrad';\nimport { defineTestFixtures } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\n// TODO: Waiting for test data based upon the Personae.\n\nif (Meteor.isServer) {\n  describe('LevelProcessor Tests', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Level 1 Student', function test() {\n      const profileID = StudentProfiles.define({\n        username: 'levelone@hawaii.edu',\n        firstName: 'Level',\n        lastName: 'One',\n        level: 6,\n      });\n      const profile = StudentProfiles.findDoc(profileID);\n      let level;\n      if (RadGrad.calcLevel) {\n        level = RadGrad.calcLevel(profile.userID);\n      } else {\n        level = defaultCalcLevel(profile.userID);\n      }\n      expect(level)\n        .to\n        .equal(1);\n    });\n\n    it('Betty Level 1', function levelOne() {\n      this.timeout(5000);\n      defineTestFixtures(['minimal', 'extended.courses.interests', 'betty.student']);\n      const bettyProfile = StudentProfiles.findDoc({ username: 'betty@hawaii.edu' });\n      expect(bettyProfile).to.exist;\n      const level = defaultCalcLevel(bettyProfile.userID);\n      expect(level)\n        .to\n        .equal(1); // no ice points\n      defineTestFixtures(['betty.level1']); // one A [0, 10, 0]\n      expect(defaultCalcLevel(bettyProfile.userID))\n        .to\n        .equal(1);\n    });\n\n    it('Betty Level 2', function levelTwo() {\n      this.timeout(5000);\n      defineTestFixtures(['betty.level2']); // ice [0, 16, 0]\n      const bettyProfile = StudentProfiles.findDoc({ username: 'betty@hawaii.edu' });\n      expect(defaultCalcLevel(bettyProfile.userID))\n        .to\n        .equal(2);\n    });\n\n    it('Betty Level 3', function levelThree() {\n      this.timeout(5000);\n      defineTestFixtures(['opportunities', 'extended.opportunities', 'betty.level3']); // [5, 26, 5]\n      const bettyProfile = StudentProfiles.findDoc({ username: 'betty@hawaii.edu' });\n      expect(defaultCalcLevel(bettyProfile.userID))\n        .to\n        .equal(3);\n    });\n\n    it('Betty Level 3 no picture', function noPicture() {\n      this.timeout(5000);\n      defineTestFixtures(['betty.level4']); // [30, 36, 35]\n      const bettyProfile = StudentProfiles.findDoc({ username: 'betty@hawaii.edu' });\n      expect(defaultCalcLevel(bettyProfile.userID))\n        .to\n        .equal(3);\n    });\n\n    it('Betty Level 4', function levelFour() {\n      this.timeout(10000);\n      removeAllEntities();\n      defineTestFixtures(['minimal', 'extended.courses.interests', 'betty.student.picture', 'betty.level1',\n        'betty.level2', 'opportunities', 'extended.opportunities', 'betty.level3', 'betty.level4']);\n      const bettyProfile = StudentProfiles.findDoc({ username: 'betty@hawaii.edu' });\n      expect(defaultCalcLevel(bettyProfile.userID))\n        .to\n        .equal(4); // CAM: This will have to change with issue-302\n    });\n\n    it('Betty Level 5', function levelFive() {\n      this.timeout(10000);\n      removeAllEntities();\n      defineTestFixtures(['minimal', 'extended.courses.interests', 'betty.student.picture', 'betty.level1',\n        'betty.level2', 'opportunities', 'extended.opportunities', 'betty.level3', 'betty.level5']);\n      const bettyProfile = StudentProfiles.findDoc({ username: 'betty@hawaii.edu' });\n      expect(defaultCalcLevel(bettyProfile.userID))\n        .to\n        .equal(5); // CAM: This will have to change with issue-302\n    });\n\n    it('Betty Level 6', function levelSix() {\n      this.timeout(10000);\n      removeAllEntities();\n      defineTestFixtures(['minimal', 'extended.courses.interests', 'betty.student.picture', 'betty.level1',\n        'betty.level2', 'opportunities', 'extended.opportunities', 'betty.level3', 'betty.level6']);\n      const bettyProfile = StudentProfiles.findDoc({ username: 'betty@hawaii.edu' });\n      expect(defaultCalcLevel(bettyProfile.userID))\n        .to\n        .equal(6); // CAM: This will have to change with issue-302\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/level/LevelProcessor.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 681,
    "kind": "file",
    "name": "api/level/LevelProcessor.ts",
    "content": "import _ from 'lodash';\nimport { Meteor } from 'meteor/meteor';\nimport { CourseInstances } from '../course/CourseInstanceCollection';\nimport { Feeds } from '../feed/FeedCollection';\nimport { getEarnedICE, getProjectedICE } from '../ice/IceProcessor';\nimport { OpportunityInstances } from '../opportunity/OpportunityInstanceCollection';\nimport { Reviews } from '../review/ReviewCollection';\nimport { StudentProfiles } from '../user/StudentProfileCollection';\nimport { defineMethod } from '../base/BaseCollection.methods';\nimport { RadGrad } from '../radgrad/RadGrad';\nimport { Ice } from '../../typings/radgrad';\n\n/**\n * Calculates the given student's Level.\n * @param studentID the studentID.\n * @returns {number}\n * @memberOf api/level\n */\nexport function defaultCalcLevel(studentID) {\n  const instances = _.concat(CourseInstances.find({ studentID })\n      .fetch(),\n    OpportunityInstances.find({ studentID })\n      .fetch());\n  const earnedICE: Ice = getEarnedICE(instances);\n  const plannedICE: Ice = getProjectedICE(instances);\n  const numReviews: number = Reviews.find({ studentID, reviewType: 'course', moderated: true, visible: true })\n    .count();\n  // console.log('defaultCalcLevel', earnedICE, plannedICE, numReviews);\n  let level = 1;\n  if (Meteor.isTest) {\n    return testCalcLevel(studentID);\n  }\n  if (earnedICE.i >= Meteor.settings.public.level.six.earnedICE.i &&\n    earnedICE.c >= Meteor.settings.public.level.six.earnedICE.c &&\n    earnedICE.e >= Meteor.settings.public.level.six.earnedICE.e &&\n    numReviews >= Meteor.settings.public.level.six.reviews &&\n    plannedICE.i >= Meteor.settings.public.level.six.plannedICE.i &&\n    plannedICE.c >= Meteor.settings.public.level.six.plannedICE.c &&\n    plannedICE.e >= Meteor.settings.public.level.six.plannedICE.e) {\n    level = 6;\n  } else if (earnedICE.i >= Meteor.settings.public.level.five.earnedICE.i &&\n    earnedICE.c >= Meteor.settings.public.level.five.earnedICE.c &&\n    earnedICE.e >= Meteor.settings.public.level.five.earnedICE.e &&\n    numReviews >= Meteor.settings.public.level.five.reviews &&\n    plannedICE.i >= Meteor.settings.public.level.five.plannedICE.i &&\n    plannedICE.c >= Meteor.settings.public.level.five.plannedICE.c &&\n    plannedICE.e >= Meteor.settings.public.level.five.plannedICE.e) {\n    level = 5;\n  } else if (earnedICE.i >= Meteor.settings.public.level.four.earnedICE.i &&\n    earnedICE.c >= Meteor.settings.public.level.four.earnedICE.c &&\n    earnedICE.e >= Meteor.settings.public.level.four.earnedICE.e &&\n    numReviews >= Meteor.settings.public.level.four.reviews &&\n    plannedICE.i >= Meteor.settings.public.level.four.plannedICE.i &&\n    plannedICE.c >= Meteor.settings.public.level.four.plannedICE.c &&\n    plannedICE.e >= Meteor.settings.public.level.four.plannedICE.e) {\n    level = 4;\n  } else if (earnedICE.i >= Meteor.settings.public.level.three.earnedICE.i &&\n    earnedICE.c >= Meteor.settings.public.level.three.earnedICE.c &&\n    earnedICE.e >= Meteor.settings.public.level.three.earnedICE.e &&\n    numReviews >= Meteor.settings.public.level.three.reviews &&\n    plannedICE.i >= Meteor.settings.public.level.three.plannedICE.i &&\n    plannedICE.c >= Meteor.settings.public.level.three.plannedICE.c &&\n    plannedICE.e >= Meteor.settings.public.level.three.plannedICE.e) {\n    level = 3;\n  } else if (earnedICE.i >= Meteor.settings.public.level.two.earnedICE.i &&\n    earnedICE.c >= Meteor.settings.public.level.two.earnedICE.c &&\n    earnedICE.e >= Meteor.settings.public.level.two.earnedICE.e &&\n    numReviews >= Meteor.settings.public.level.two.reviews &&\n    plannedICE.i >= Meteor.settings.public.level.two.plannedICE.i &&\n    plannedICE.c >= Meteor.settings.public.level.two.plannedICE.c &&\n    plannedICE.e >= Meteor.settings.public.level.two.plannedICE.e) {\n    level = 2;\n  }\n  // console.log('defaultCalcLevel', studentID, earnedICE, plannedICE, numReviews, level);\n  return level;\n}\n\nexport function testCalcLevel(studentID) {\n  const instances = _.concat(CourseInstances.find({ studentID })\n      .fetch(),\n    OpportunityInstances.find({ studentID })\n      .fetch());\n  const earnedICE: Ice = getEarnedICE(instances);\n  const plannedICE: Ice = getProjectedICE(instances);\n  const numReviews: number = Reviews.find({ studentID, reviewType: 'course', moderated: true, visible: true })\n    .count();\n  const hasPicture: boolean = StudentProfiles.hasSetPicture(studentID);\n  // console.log('defaultCalcLevel', earnedICE, plannedICE, numReviews, hasPicture);\n  let level = 1;\n  if (earnedICE.i >= 100 &&\n    earnedICE.c >= 100 &&\n    earnedICE.e >= 100 &&\n    numReviews >= 6 &&\n    plannedICE.i >= 100 &&\n    plannedICE.c >= 100 &&\n    plannedICE.e >= 100 &&\n    hasPicture) {\n    level = 6;\n  } else if (earnedICE.i >= 80 &&\n    earnedICE.c >= 80 &&\n    earnedICE.e >= 80 &&\n    numReviews >= 1 &&\n    plannedICE.i >= 100 &&\n    plannedICE.c >= 100 &&\n    plannedICE.e >= 100 &&\n    hasPicture) {\n    level = 5;\n  } else if (earnedICE.i >= 30 &&\n    earnedICE.c >= 36 &&\n    earnedICE.e >= 30 &&\n    numReviews >= 0 &&\n    plannedICE.i >= 100 &&\n    plannedICE.c >= 100 &&\n    plannedICE.e >= 100 &&\n    hasPicture) {\n    level = 4;\n  } else if ((earnedICE.i >= 1 ||\n    earnedICE.e >= 1) &&\n    earnedICE.c >= 24 &&\n    numReviews >= 0) {\n    level = 3;\n  } else if (earnedICE.i >= 0 &&\n    earnedICE.c >= 12 &&\n    earnedICE.e >= 0 &&\n    numReviews >= 0) {\n    level = 2;\n  }\n  // console.log('defaultCalcLevel', studentID, earnedICE, plannedICE, numReviews, hasPicture, level);\n  return level;\n}\n\n/**\n * Updates the student's level.\n * @param advisor the advisors ID.\n * @param studentID the studentID.\n * @memberOf api/level\n */\nexport function updateStudentLevel(advisor, studentID) {\n  let level;\n  if (RadGrad.calcLevel) {\n    level = RadGrad.calcLevel(studentID);\n  } else {\n    level = defaultCalcLevel(studentID);\n  }\n  const profile = StudentProfiles.getProfile(studentID);\n  if (profile.level !== level) {\n    const text = `Congratulations! ${profile.firstName} you're now Level ${level}.\n         Come by to get your RadGrad sticker.`;\n    // send email notification to student. issue-199\n    const student = studentID;\n    defineMethod.call({ collectionName: 'AdvisorLogCollection', definitionData: { advisor, student, text } }, (error) => {\n      if (error) {\n        console.error('Error creating AdvisorLog.', error);\n      }\n    });\n    const feedData = {\n      feedType: Feeds.NEW_LEVEL,\n      user: profile.username,\n      level,\n    };\n    defineMethod.call({ collectionName: 'FeedCollection', definitionData: feedData });\n  }\n  StudentProfiles.setLevel(studentID, level);\n}\n\n/**\n * Updates all the students level.\n * @param advisor the advisors ID.\n * @memberOf api/level\n */\nexport function updateAllStudentLevels(advisor) {\n  StudentProfiles.find()\n    .forEach((student) => {\n      updateStudentLevel(advisor, student.userID);\n    });\n  return StudentProfiles.find()\n    .count();\n}\n\nexport const getLevelCriteriaStringMarkdown = (level: string): string => {\n  if (!_.includes(['six', 'five', 'four', 'three', 'two'], level)) {\n    throw new Meteor.Error(`${level} is not a valid level`);\n  }\n  const criteria = Meteor.settings.public.level[level];\n  let plannedICEStr = '';\n  if (criteria.plannedICE.i !== 0 || criteria.plannedICE.c !== 0 || criteria.plannedICE.e !== 0) {\n    plannedICEStr = '+ Planned ICE of';\n    if (criteria.plannedICE.i !== 0) {\n      plannedICEStr = `${plannedICEStr} **I >= ${criteria.plannedICE.i},`;\n    }\n    if (criteria.plannedICE.c !== 0) {\n      plannedICEStr = `${plannedICEStr} C >= ${criteria.plannedICE.c},`;\n    }\n    if (criteria.plannedICE.e !== 0) {\n      plannedICEStr = `${plannedICEStr} E >= ${criteria.plannedICE.e}**`;\n    }\n  }\n  let earnedICEStr = '';\n  if (criteria.earnedICE.i !== 0 || criteria.earnedICE.c !== 0 || criteria.earnedICE.e !== 0) {\n    earnedICEStr = '+ Earned ICE of';\n    if (criteria.earnedICE.i !== 0) {\n      earnedICEStr = `${earnedICEStr} **I >= ${criteria.earnedICE.i},`;\n    }\n    if (criteria.earnedICE.c !== 0 && criteria.earnedICE.e !== 0) {\n      earnedICEStr = `${earnedICEStr} C >= ${criteria.earnedICE.c},`;\n    }\n    if (criteria.earnedICE.c !== 0 && criteria.earnedICE.e === 0) {\n      earnedICEStr = `${earnedICEStr} **C >= ${criteria.earnedICE.c}**`;\n    }\n    if (criteria.earnedICE.e !== 0) {\n      earnedICEStr = `${earnedICEStr} E >= ${criteria.earnedICE.e}**`;\n    }\n  }\n  let reviewsStr = '';\n  if (criteria.reviews > 1) {\n    reviewsStr = `+ **${criteria.reviews}** reviews of courses or opportunities`;\n  } else if (criteria.reviews === 1) {\n    reviewsStr = `+ **${criteria.reviews}** review of a course or opportunity`;\n  }\n  let criteriaString = '';\n  if (plannedICEStr !== '' && earnedICEStr !== '' && reviewsStr !== '') {\n    criteriaString = `\n\n${plannedICEStr}\n    \n${earnedICEStr}\n\n${reviewsStr}`;\n  } else if (plannedICEStr !== '' && earnedICEStr !== '' && reviewsStr === '') {\n    criteriaString = `\n\n${plannedICEStr}\n\n${earnedICEStr}`;\n  } else if (plannedICEStr === '' && earnedICEStr !== '' && reviewsStr === '') {\n    criteriaString = `\n    \n${earnedICEStr}`;\n  }\n  return criteriaString;\n};\n\nexport const getLevelHintStringMarkdown = (level: string): string => {\n  let result = '';\n  switch (level) {\n    case 'six':\n      // eslint-disable-next-line max-len\n      result = `If you achieve Level 6, you are truly one of the elite ICS students, and you will have demonstrated excellent preparation for entering the workforce, or going on to Graduate School, whichever you prefer. Congratulations! \n      \nThe criteria for **Level 6** is ${getLevelCriteriaStringMarkdown(level)}.`;\n      break;\n    case 'five':\n      // eslint-disable-next-line max-len\n      result = `Level 5 students are far along in their degree program, and they've made significant progress toward 100 verified points in each of the three ICE categories. You will probably be at least a Junior before Level 5 becomes a realistic option for you. \n      \nThe criteria for **Level 5** is ${getLevelCriteriaStringMarkdown(level)}.`;\n      break;\n    case 'four':\n      // eslint-disable-next-line max-len\n      result = `ICS has a \"core curriculum\", and Level 4 students have not only finished it, but they have also thought beyond mere competency. \n      \nThe criteria for **Level 4** is ${getLevelCriteriaStringMarkdown(level)}.`;\n      break;\n    case 'three':\n      // eslint-disable-next-line max-len\n      result = `With any luck, you'll achieve Level 3 after you complete your second semester of ICS coursework, as long as your grades are good. \n      \nThe criteria for **Level 3** is ${getLevelCriteriaStringMarkdown(level)}.`;\n      break;\n    case 'two':\n      // eslint-disable-next-line max-len\n      result = `Successfully finish your first semester of ICS coursework. \n      \nThe criteria for **Level 2** is ${getLevelCriteriaStringMarkdown(level)}.`;\n      break;\n    default:\n      // eslint-disable-next-line max-len\n      result = 'You begin your RadGrad experience at Level 1, and you will receive this laptop sticker when you first sign up for RadGrad with your advisor. *\"A journey of a thousand miles begins with a single step\" -- Lao Tzu*';\n  }\n  return result;\n};\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/level/LevelProcessor.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 682,
    "kind": "function",
    "name": "defaultCalcLevel",
    "memberof": "api/level/LevelProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/level/LevelProcessor.ts~defaultCalcLevel",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/level/LevelProcessor.ts",
    "importStyle": "{defaultCalcLevel}",
    "description": "Calculates the given student's Level.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 683,
    "kind": "function",
    "name": "testCalcLevel",
    "memberof": "api/level/LevelProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/level/LevelProcessor.ts~testCalcLevel",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/level/LevelProcessor.ts",
    "importStyle": "{testCalcLevel}",
    "description": "",
    "lineNumber": 78,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 684,
    "kind": "function",
    "name": "updateStudentLevel",
    "memberof": "api/level/LevelProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/level/LevelProcessor.ts~updateStudentLevel",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/level/LevelProcessor.ts",
    "importStyle": "{updateStudentLevel}",
    "description": "Updates the student's level.",
    "lineNumber": 138,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "advisor",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 685,
    "kind": "function",
    "name": "updateAllStudentLevels",
    "memberof": "api/level/LevelProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/level/LevelProcessor.ts~updateAllStudentLevels",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/level/LevelProcessor.ts",
    "importStyle": "{updateAllStudentLevels}",
    "description": "Updates all the students level.",
    "lineNumber": 171,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "advisor",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 686,
    "kind": "function",
    "name": "getLevelCriteriaStringMarkdown",
    "memberof": "api/level/LevelProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/level/LevelProcessor.ts~getLevelCriteriaStringMarkdown",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/level/LevelProcessor.ts",
    "importStyle": "{getLevelCriteriaStringMarkdown}",
    "description": null,
    "lineNumber": 198,
    "undocument": true,
    "params": [
      {
        "name": "level",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 687,
    "kind": "function",
    "name": "getLevelHintStringMarkdown",
    "memberof": "api/level/LevelProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/level/LevelProcessor.ts~getLevelHintStringMarkdown",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/level/LevelProcessor.ts",
    "importStyle": "{getLevelHintStringMarkdown}",
    "description": null,
    "lineNumber": 263,
    "undocument": true,
    "params": [
      {
        "name": "level",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 688,
    "kind": "file",
    "name": "api/level/index.ts",
    "content": "/** @namespace api/level */\nimport './LevelProcessor';\nimport './LevelProcessor.methods';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/level/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 689,
    "kind": "file",
    "name": "api/log/AdvisorLogCollection.methods.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { ValidatedMethod } from 'meteor/mdg:validated-method';\nimport _ from 'lodash';\nimport { AdvisorLogs } from './AdvisorLogCollection';\nimport { ROLE } from '../role/Role';\nimport { IAdvisorLogUpdate } from '../../typings/radgrad';\nimport { Users } from '../user/UserCollection';\n\n/**\n * The validated method for defining AdvisorLogs.\n * @memberOf api/log\n */\nexport const advisorLogsDefineMethod = new ValidatedMethod({\n  name: 'AdvisorLogs.define',\n  validate: null,\n  run(definition) {\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to define Advisor logs.');\n    }\n    const profile = Users.getProfile(this.userId);\n    if (!_.includes([ROLE.ADMIN, ROLE.ADVISOR], profile.role)) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in as ADMIN or ADVISOR to define Advisor logs.');\n    }\n    return AdvisorLogs.define(definition);\n  },\n});\n\n/**\n * The ValidatedMethod for updating AdvisorLogs.\n * @memberOf api/log\n */\nexport const advisorLogsUpdateMethod = new ValidatedMethod({\n  name: 'AdvisorLogs.update',\n  validate: null,\n  run(update: IAdvisorLogUpdate) {\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to update AdvisorLogs.');\n    }\n    const profile = Users.getProfile(this.userId);\n    if (!_.includes([ROLE.ADMIN, ROLE.ADVISOR], profile.role)) {\n      throw new Meteor.Error('unauthorized', 'You must be an admin or advisor to update AdvisorLogs.');\n    }\n    return AdvisorLogs.update(update.id, update);\n  },\n});\n\n/**\n * The validated method for removing AdvisorLogs.\n * @memberOf api/log\n */\nexport const AdvisorLogsRemoveItMethod = new ValidatedMethod({\n  name: 'AdvisorLogs.removeIt',\n  validate: null,\n  run(removeArgs) {\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to remove AdvisorLogs.');\n    }\n    const profile = Users.getProfile(this.userId);\n    if (!_.includes([ROLE.ADMIN, ROLE.ADVISOR], profile.role)) {\n      throw new Meteor.Error('unauthorized', 'You must be an admin or advisor to remove AdvisorLogs.');\n    }\n    return AdvisorLogs.removeIt(removeArgs.id);\n  },\n});\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/log/AdvisorLogCollection.methods.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 690,
    "kind": "variable",
    "name": "advisorLogsDefineMethod",
    "memberof": "api/log/AdvisorLogCollection.methods.ts",
    "static": true,
    "longname": "api/log/AdvisorLogCollection.methods.ts~advisorLogsDefineMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/log/AdvisorLogCollection.methods.ts",
    "importStyle": "{advisorLogsDefineMethod}",
    "description": "The validated method for defining AdvisorLogs.",
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/log"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 691,
    "kind": "variable",
    "name": "advisorLogsUpdateMethod",
    "memberof": "api/log/AdvisorLogCollection.methods.ts",
    "static": true,
    "longname": "api/log/AdvisorLogCollection.methods.ts~advisorLogsUpdateMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/log/AdvisorLogCollection.methods.ts",
    "importStyle": "{advisorLogsUpdateMethod}",
    "description": "The ValidatedMethod for updating AdvisorLogs.",
    "lineNumber": 37,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/log"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 692,
    "kind": "variable",
    "name": "AdvisorLogsRemoveItMethod",
    "memberof": "api/log/AdvisorLogCollection.methods.ts",
    "static": true,
    "longname": "api/log/AdvisorLogCollection.methods.ts~AdvisorLogsRemoveItMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/log/AdvisorLogCollection.methods.ts",
    "importStyle": "{AdvisorLogsRemoveItMethod}",
    "description": "The validated method for removing AdvisorLogs.",
    "lineNumber": 63,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/log"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 693,
    "kind": "file",
    "name": "api/log/AdvisorLogCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { AdvisorLogs } from './AdvisorLogCollection';\nimport { ROLE } from '../role/Role';\nimport { Users } from '../user/UserCollection';\n// import { PublicationCollector } from 'meteor/johanbrook:publication-collector';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('AdvisorLogCollection', function testSuite() {\n    let student;\n    let advisor;\n    let text;\n\n    before(function setup() {\n      removeAllEntities();\n      student = makeSampleUser();\n      advisor = makeSampleUser(ROLE.ADVISOR);\n      text = faker.lorem.words();\n    });\n\n    after(function tearDown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(5000);\n      fc.assert(\n        fc.property(fc.lorem(24), fc.boolean(), (fcText, fcRetired) => {\n          const docID = AdvisorLogs.define({ advisor, student, text: fcText, retired: fcRetired });\n          expect(AdvisorLogs.isDefined(docID)).to.be.true;\n          const doc = AdvisorLogs.findDoc(docID);\n          expect(doc.advisorID).to.equal(advisor);\n          expect(doc.studentID).to.equal(student);\n          expect(doc.text).to.equal(fcText);\n          expect(doc.retired).to.equal(fcRetired);\n          AdvisorLogs.removeIt(docID);\n          expect(AdvisorLogs.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Can update', function test2(done) {\n      this.timeout(5000);\n      text = faker.lorem.words();\n      AdvisorLogs.define({ advisor, student, text });\n      let doc = AdvisorLogs.findOne({});\n      const docID = doc._id;\n      fc.assert(\n        fc.property(fc.lorem(24), fc.boolean(), (fcText, fcRetired) => {\n          AdvisorLogs.update(docID, { text: fcText, retired: fcRetired });\n          doc = AdvisorLogs.findDoc(docID);\n          expect(doc.text).to.equal(fcText);\n          expect(doc.retired).to.equal(fcRetired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test3() {\n      let doc = AdvisorLogs.findOne({});\n      let docID = doc._id;\n      const dumpObject = AdvisorLogs.dumpOne(docID);\n      AdvisorLogs.removeIt(docID);\n      expect(AdvisorLogs.isDefined(docID)).to.be.false;\n      docID = AdvisorLogs.restoreOne(dumpObject);\n      doc = AdvisorLogs.findDoc(docID);\n      expect(doc.text).to.equal(dumpObject.text);\n      expect(doc.retired).to.equal(dumpObject.retired);\n    });\n\n    it('Can check integrity no errors', function test4() {\n      const problems = AdvisorLogs.checkIntegrity();\n      expect(problems.length).to.equal(0);\n    });\n\n    it('Can getAdvisorDoc and getStudentDoc', function test() {\n      const docID = AdvisorLogs.define({ advisor, student, text });\n      const advisorDoc = AdvisorLogs.getAdvisorDoc(docID);\n      const a = Users.getProfile(advisor);\n      expect(advisorDoc.username).to.equal(a.username);\n      const studentDoc = AdvisorLogs.getStudentDoc(docID);\n      const s = Users.getProfile(student);\n      expect(studentDoc.username).to.equal(s.username);\n      AdvisorLogs.removeIt(docID);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/log/AdvisorLogCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 694,
    "kind": "file",
    "name": "api/log/AdvisorLogCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport moment from 'moment';\nimport SimpleSchema from 'simpl-schema';\nimport _ from 'lodash';\nimport BaseCollection from '../base/BaseCollection';\nimport { ROLE } from '../role/Role';\nimport { Users } from '../user/UserCollection';\nimport { IAdvisorLogDefine, IAdvisorLogUpdate } from '../../typings/radgrad';\n\n/**\n * Represents a log of an Advisor talking to a Student.\n * @extends api/base.BaseCollection\n * @memberOf api/log\n */\nclass AdvisorLogCollection extends BaseCollection {\n\n  /**\n   * Creates the AdvisorLog collection.\n   */\n  constructor() {\n    super('AdvisorLog', new SimpleSchema({\n      studentID: { type: SimpleSchema.RegEx.Id },\n      advisorID: { type: SimpleSchema.RegEx.Id },\n      text: { type: String },\n      createdOn: { type: Date },\n      retired: { type: Boolean, optional: true },\n    }));\n    this.defineSchema = new SimpleSchema({\n      advisor: String,\n      student: String,\n      text: String,\n    });\n    this.updateSchema = new SimpleSchema({\n      text: { type: String, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines an advisor log record.\n   * @example\n   * AdvisorLogs.define({\n   *                      advisor: 'glau',\n   *                      student: 'abi@hawaii.edu',\n   *                      text: 'Talked about changing academic plan to B.S. CS from B.A. ICS.',\n   *                      });\n   * @param advisor The advisor's username.\n   * @param student The student's username.\n   * @param text The contents of the session.\n   */\n  public define({ advisor, student, text, createdOn = moment().toDate(), retired = false }: IAdvisorLogDefine) {\n    const advisorID = Users.getID(advisor);\n    const studentID = Users.getID(student);\n    return this.collection.insert({ advisorID, studentID, text, createdOn, retired });\n  }\n\n  public update(docID: string, { text, retired }: IAdvisorLogUpdate) {\n    this.assertDefined(docID);\n    // console.log('update(%o, %o)', docID, text);\n    const updateData: IAdvisorLogUpdate = {};\n    if (text) {\n      updateData.text = text;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Removes all AdvisorLog documents referring to (the student) user.\n   * @param user The student user, either the ID or the username.\n   * @throws { Meteor.Error } If user is not an ID or username.\n   */\n  public removeUser(user: string) {\n    const studentID = Users.getID(user);\n    this.collection.remove({ studentID });\n  }\n\n  /**\n   * Returns the Advisor associated with the log instance.\n   * @param instanceID the instance ID.\n   * @returns {Object}\n   */\n  public getAdvisorDoc(instanceID: string) {\n    this.assertDefined(instanceID);\n    const instance = this.findDoc(instanceID);\n    return Users.getProfile(instance.advisorID);\n  }\n\n  /**\n   * Returns the Student associated with the log instance.\n   * @param instanceID the instance ID.\n   * @returns {Object}\n   */\n  public getStudentDoc(instanceID: string) {\n    this.assertDefined(instanceID);\n    const instance = this.findDoc(instanceID);\n    return Users.getProfile(instance.studentID);\n  }\n\n  /**\n   * Depending on the logged in user publish only their AdvisorLogs. If\n   * the user is in the Role.ADMIN or Role.ADVISOR then publish all AdvisorLogs.\n   */\n  public publish() {\n    if (Meteor.isServer) {\n      const instance = this;\n      // eslint-disable-next-line meteor/audit-argument-checks\n      Meteor.publish(this.collectionName, function publish(studentID) {\n        if (_.isNil(this.userId)) { // https://github.com/meteor/meteor/issues/9619\n          return this.ready();\n        }\n        if (_.isNil(studentID)) {\n          return this.ready();\n        }\n        const profile = Users.getProfile(this.userId);\n        if (profile.role === ROLE.ADMIN) {\n          return instance.collection.find();\n        }\n        if (profile.role === ROLE.ADVISOR) {\n          return instance.collection.find({ retired: { $not: { $eq: true } } });\n        }\n        return instance.collection.find({ studentID, retired: { $not: { $eq: true } } });\n      });\n    }\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks studentID, advisorID.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (!Users.isDefined(doc.studentID)) {\n        problems.push(`Bad studentID: ${doc.studentID}`);\n      }\n      if (!Users.isDefined(doc.advisorID)) {\n        problems.push(`Bad advisorID: ${doc.advisorID}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the Log docID in a format acceptable to define().\n   * @param docID The docID of a Log.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IAdvisorLogDefine {\n    const doc = this.findDoc(docID);\n    const student = Users.getProfile(doc.studentID).username;\n    const advisor = Users.getProfile(doc.advisorID).username;\n    const text = doc.text;\n    const createdOn = doc.createdOn;\n    const retired = doc.retired;\n    return { student, advisor, text, createdOn, retired };\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @type {api/log.AdvisorLogCollection}\n * @memberOf api/log\n */\nexport const AdvisorLogs = new AdvisorLogCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/log/AdvisorLogCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 695,
    "kind": "variable",
    "name": "AdvisorLogs",
    "memberof": "api/log/AdvisorLogCollection.ts",
    "static": true,
    "longname": "api/log/AdvisorLogCollection.ts~AdvisorLogs",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/log/AdvisorLogCollection.ts",
    "importStyle": "{AdvisorLogs}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 183,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/log"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/log.AdvisorLogCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 696,
    "kind": "class",
    "name": "AdvisorLogCollection",
    "memberof": "api/log/AdvisorLogCollection.ts",
    "static": true,
    "longname": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/log/AdvisorLogCollection.ts",
    "importStyle": null,
    "description": "Represents a log of an Advisor talking to a Student.",
    "lineNumber": 15,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 697,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection#constructor",
    "access": "public",
    "description": "Creates the AdvisorLog collection.",
    "lineNumber": 18
  },
  {
    "__docId__": 698,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection",
    "static": false,
    "longname": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 699,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection",
    "static": false,
    "longname": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 700,
    "kind": "method",
    "name": "define",
    "memberof": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection#define",
    "access": "public",
    "description": "Defines an advisor log record.",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "IAdvisorLogDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 701,
    "kind": "method",
    "name": "update",
    "memberof": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection#update",
    "access": "public",
    "description": "",
    "lineNumber": 57,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IAdvisorLogUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 702,
    "kind": "method",
    "name": "removeUser",
    "memberof": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection#removeUser",
    "access": "public",
    "description": "Removes all AdvisorLog documents referring to (the student) user.",
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 703,
    "kind": "method",
    "name": "getAdvisorDoc",
    "memberof": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection#getAdvisorDoc",
    "access": "public",
    "description": "Returns the Advisor associated with the log instance.",
    "lineNumber": 85,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 704,
    "kind": "method",
    "name": "getStudentDoc",
    "memberof": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection#getStudentDoc",
    "access": "public",
    "description": "Returns the Student associated with the log instance.",
    "lineNumber": 96,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 705,
    "kind": "method",
    "name": "publish",
    "memberof": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection#publish",
    "access": "public",
    "description": "Depending on the logged in user publish only their AdvisorLogs. If\nthe user is in the Role.ADMIN or Role.ADVISOR then publish all AdvisorLogs.",
    "lineNumber": 106,
    "params": [],
    "return": null
  },
  {
    "__docId__": 706,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks studentID, advisorID.",
    "lineNumber": 135,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 707,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/log/AdvisorLogCollection.ts~AdvisorLogCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the Log docID in a format acceptable to define().",
    "lineNumber": 153,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IAdvisorLogDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 708,
    "kind": "file",
    "name": "api/log/index.ts",
    "content": "/** @namespace api/log */\nimport './AdvisorLogCollection';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/log/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 709,
    "kind": "file",
    "name": "api/mentor/MentorAnswerCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport 'mocha';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { MentorAnswers } from './MentorAnswerCollection';\nimport { MentorQuestions } from './MentorQuestionCollection';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { ROLE } from '../role/Role';\nimport { makeSampleMentorQuestion } from './SampleMentorQuestionAndAnswer';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('MentorAnswerCollection', function testSuite() {\n    // Define course data.\n    const questionSlug = 'hiring-expectations';\n    let text = 'Test answer.';\n\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function tearDown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(20000);\n      fc.assert(\n        fc.property(fc.lorem(10), fc.boolean(), (fcText, fcRetired) => {\n          const mentor = makeSampleUser(ROLE.MENTOR);\n          const question = makeSampleMentorQuestion();\n          const docID = MentorAnswers.define({ question, mentor, text: fcText, retired: fcRetired });\n          expect(MentorAnswers.isDefined(docID)).to.be.true;\n          const doc = MentorAnswers.findDoc(docID);\n          expect(doc.questionID).to.equal(question);\n          expect(doc.mentorID).to.equal(mentor);\n          expect(doc.text).to.equal(fcText);\n          expect(doc.retired).to.equal(fcRetired);\n          MentorAnswers.removeIt(docID);\n          expect(MentorAnswers.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Can update', function test2(done) {\n      this.timeout(5000);\n      text = faker.lorem.words();\n      const mentor = makeSampleUser(ROLE.MENTOR);\n      const question = makeSampleMentorQuestion();\n      const docID = MentorAnswers.define({ question, mentor, text });\n      let doc = MentorAnswers.findDoc(docID);\n      fc.assert(\n        fc.property(fc.lorem(24), fc.boolean(), (fcText, fcRetired) => {\n          MentorAnswers.update(docID, { text: fcText, retired: fcRetired });\n          doc = MentorAnswers.findDoc(docID);\n          expect(doc.text).to.equal(fcText);\n          expect(doc.retired).to.equal(fcRetired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test3() {\n      let doc = MentorAnswers.findOne({});\n      let docID = doc._id;\n      const dumpObject = MentorAnswers.dumpOne(docID);\n      MentorAnswers.removeIt(docID);\n      expect(MentorAnswers.isDefined(docID)).to.be.false;\n      docID = MentorAnswers.restoreOne(dumpObject);\n      doc = MentorAnswers.findDoc(docID);\n      expect(doc.retired).to.equal(dumpObject.retired);\n      expect(doc.text).to.equal(dumpObject.text);\n    });\n\n    it('Can check integrity no errors', function test4() {\n      const problems = MentorAnswers.checkIntegrity();\n      expect(problems.length).to.equal(0);\n    });\n\n    it('Can removeQuestion and removeUser', function test() {\n      // Define mentor and the question.\n      const mentor1 = makeSampleUser(ROLE.MENTOR);\n      const mentor2 = makeSampleUser(ROLE.MENTOR);\n      const student = makeSampleUser(ROLE.STUDENT);\n      MentorQuestions.define({ question: 'Sample Question', slug: `${questionSlug}-1`, student });\n      MentorQuestions.define({ question: 'Sample Question2', slug: `${questionSlug}-2`, student });\n      const answer11ID = MentorAnswers.define({ question: `${questionSlug}-1`, mentor: mentor1, text });\n      const answer21ID = MentorAnswers.define({ question: `${questionSlug}-1`, mentor: mentor2, text });\n      const answer12ID = MentorAnswers.define({ question: `${questionSlug}-2`, mentor: mentor1, text });\n      const answer22ID = MentorAnswers.define({ question: `${questionSlug}-2`, mentor: mentor2, text });\n      expect(MentorAnswers.isDefined(answer11ID)).to.be.true;\n      expect(MentorAnswers.isDefined(answer21ID)).to.be.true;\n      expect(MentorAnswers.isDefined(answer12ID)).to.be.true;\n      expect(MentorAnswers.isDefined(answer22ID)).to.be.true;\n      MentorAnswers.removeQuestion(`${questionSlug}-1`);\n      expect(MentorAnswers.isDefined(answer11ID)).to.be.false;\n      expect(MentorAnswers.isDefined(answer21ID)).to.be.false;\n      MentorAnswers.removeUser(mentor2);\n      expect(MentorAnswers.isDefined(answer12ID)).to.be.true;\n      expect(MentorAnswers.isDefined(answer22ID)).to.be.false;\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/mentor/MentorAnswerCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 710,
    "kind": "file",
    "name": "api/mentor/MentorAnswerCollection.ts",
    "content": "import SimpleSchema from 'simpl-schema';\nimport _ from 'lodash';\nimport BaseCollection from '../base/BaseCollection';\nimport { MentorQuestions } from './MentorQuestionCollection';\nimport { ROLE } from '../role/Role';\nimport { Users } from '../user/UserCollection';\nimport { IMentorAnswerDefine, IMentorAnswerUpdate } from '../../typings/radgrad';\n\n/**\n * Represents a mentor answer.\n * @extends api/base.BaseCollection\n * @memberOf api/mentor\n */\nclass MentorAnswerCollection extends BaseCollection {\n  /**\n   * Creates the Mentor Answer collection.\n   */\n  constructor() {\n    super('MentorAnswer', new SimpleSchema({\n      questionID: { type: SimpleSchema.RegEx.Id },\n      mentorID: { type: SimpleSchema.RegEx.Id },\n      text: { type: String },\n      retired: { type: Boolean, optional: true },\n    }));\n    this.defineSchema = new SimpleSchema({\n      question: String,\n      mentor: String,\n      text: String,\n      retired: { type: Boolean, optional: true },\n    });\n    this.updateSchema = new SimpleSchema({\n      text: { type: String, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines the mentor answer for a given question.\n   * @example\n   * MentorAnswers.define({ question: 'data-science-career-prep',\n   *                        mentor: 'rbrewer',\n   *                        text: 'Understanding the incredible amount of data that humankind is constantly producing is one of the fundamental challenges facing society. The best way to learn is to pick a topic that interests you, find a public source of data in that area, and start actually looking at the data. What patterns can you see? Start asking questions, and figure out how to answer them from the data. Quick plug: Tableau is great for exploring data graphically, and answering questions about data. It's free for students (http://www.tableau.com/academic/students), and Tableau Public (https://public.tableau.com/s/) is a great place to find interesting public data sets and visual analytics based on the data.',\n   *                        });\n   * @param question The question (slug or ID).\n   * @param mentor The mentor who answered the question (slug or ID).\n   * @param text The answer itself.\n   * @return { String } The docID of the answer.\n   * @throws { Meteor.Error } If question or mentor is undefined.\n   */\n  public define({ question, mentor, text, retired = false }: IMentorAnswerDefine) {\n    const questionID = MentorQuestions.getID(question);\n    const mentorID = Users.getID(mentor);\n    Users.assertInRole(mentorID, ROLE.MENTOR);\n    return this.collection.insert({ questionID, mentorID, text, retired });\n  }\n\n  /**\n   * Updates the mentor answer.\n   * @param docID the docID of the mentor answer.\n   * @param text the updated text.\n   */\n  public update(docID: string, { text, retired }: IMentorAnswerUpdate) {\n    this.assertDefined(docID);\n    const updateData: IMentorAnswerUpdate = {};\n    if (text) {\n      updateData.text = text;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the mentor answer.\n   * @param docID the ID of the answer.\n   */\n  public removeIt(docID: string) {\n    this.assertDefined(docID);\n    // OK, clear to delete.\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Removes all the MentorAnswers to the given MentorQuestion.\n   * @param question the question's ID or slug.\n   */\n  public removeQuestion(question: string) {\n    const questionID = MentorQuestions.getID(question);\n    this.collection.remove({ questionID });\n  }\n\n  /**\n   * Removes all the MentorAnswers associated with the given user.\n   * @param user the user's ID or username.\n   */\n  public removeUser(user: string) {\n    const mentorID = Users.getID(user);\n    this.collection.remove({ mentorID });\n  }\n\n  /**\n   * Returns the MentorAnswer document associated with question and mentor.\n   * @param question The question (slug or ID)\n   * @param mentor The mentor (slug or ID)\n   * @return { Object } Returns the document or null if not found.\n   * @throws { Meteor.Error } If question or mentor does not exist.\n   */\n  public findMentorAnswerDoc(question: string, mentor: string) {\n    const questionID = MentorQuestions.getID(question);\n    const mentorID = Users.getID(mentor);\n    return this.collection.findOne({ questionID, mentorID });\n  }\n\n  /**\n   * Returns true if there exists a MentorAnswer for the question and mentor.\n   * @param question The question (slug or ID)\n   * @param mentor The mentor (slug or ID)\n   * @return { Object } True if the MentorAnswer exists.\n   * @throws { Meteor.Error } If question or mentor does not exist.\n   */\n  public isMentorAnswer(question: string, mentor: string) {\n    return !!this.findMentorAnswerDoc(question, mentor);\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\n   * Mentor.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.MENTOR]);\n  }\n\n  /**\n   * Returns the text for the given questionID.\n   * @param questionID the id of the question.\n   */\n  public getAnswers(questionID: string) {\n    return this.collection.find({ questionID });\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks questionID, mentorID\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (!MentorQuestions.isDefined(doc.questionID)) {\n        problems.push(`Bad questionID: ${doc.questionID}`);\n      }\n      if (!Users.isDefined(doc.mentorID)) {\n        problems.push(`Bad mentorID: ${doc.mentorID}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the MentorAnswer docID in a format acceptable to define().\n   * @param docID The docID of a MentorQuestion.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IMentorAnswerDefine {\n    const doc = this.findDoc(docID);\n    const question = MentorQuestions.findSlugByID(doc.questionID);\n    const mentor = Users.getProfile(doc.mentorID).username;\n    const text = doc.text;\n    const retired = doc.retired;\n    return { question, mentor, text, retired };\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @type {api/mentor.MentorAnswerCollection}\n * @memberOf api/mentor\n */\nexport const MentorAnswers = new MentorAnswerCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/mentor/MentorAnswerCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 711,
    "kind": "variable",
    "name": "MentorAnswers",
    "memberof": "api/mentor/MentorAnswerCollection.ts",
    "static": true,
    "longname": "api/mentor/MentorAnswerCollection.ts~MentorAnswers",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/mentor/MentorAnswerCollection.ts",
    "importStyle": "{MentorAnswers}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 203,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/mentor"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/mentor.MentorAnswerCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 712,
    "kind": "class",
    "name": "MentorAnswerCollection",
    "memberof": "api/mentor/MentorAnswerCollection.ts",
    "static": true,
    "longname": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/mentor/MentorAnswerCollection.ts",
    "importStyle": null,
    "description": "Represents a mentor answer.",
    "lineNumber": 14,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 713,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection#constructor",
    "access": "public",
    "description": "Creates the Mentor Answer collection.",
    "lineNumber": 17
  },
  {
    "__docId__": 714,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection",
    "static": false,
    "longname": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 715,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection",
    "static": false,
    "longname": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 716,
    "kind": "method",
    "name": "define",
    "memberof": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection#define",
    "access": "public",
    "description": "Defines the mentor answer for a given question.",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "IMentorAnswerDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 717,
    "kind": "method",
    "name": "update",
    "memberof": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection#update",
    "access": "public",
    "description": "Updates the mentor answer.",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IMentorAnswerUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 718,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection#removeIt",
    "access": "public",
    "description": "Remove the mentor answer.",
    "lineNumber": 78,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 719,
    "kind": "method",
    "name": "removeQuestion",
    "memberof": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection#removeQuestion",
    "access": "public",
    "description": "Removes all the MentorAnswers to the given MentorQuestion.",
    "lineNumber": 88,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "question",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 720,
    "kind": "method",
    "name": "removeUser",
    "memberof": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection#removeUser",
    "access": "public",
    "description": "Removes all the MentorAnswers associated with the given user.",
    "lineNumber": 97,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 721,
    "kind": "method",
    "name": "findMentorAnswerDoc",
    "memberof": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection#findMentorAnswerDoc",
    "access": "public",
    "description": "Returns the MentorAnswer document associated with question and mentor.",
    "lineNumber": 109,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "question",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "mentor",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 722,
    "kind": "method",
    "name": "isMentorAnswer",
    "memberof": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection#isMentorAnswer",
    "access": "public",
    "description": "Returns true if there exists a MentorAnswer for the question and mentor.",
    "lineNumber": 122,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "question",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "mentor",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 723,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\nMentor.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 724,
    "kind": "method",
    "name": "getAnswers",
    "memberof": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection#getAnswers",
    "access": "public",
    "description": "Returns the text for the given questionID.",
    "lineNumber": 141,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "questionID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 725,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks questionID, mentorID",
    "lineNumber": 151,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 726,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorAnswerCollection.ts~MentorAnswerCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the MentorAnswer docID in a format acceptable to define().",
    "lineNumber": 169,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IMentorAnswerDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 727,
    "kind": "file",
    "name": "api/mentor/MentorQuestionAndAnswerCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { MentorAnswers } from './MentorAnswerCollection';\nimport { MentorQuestions } from './MentorQuestionCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('MentorQuestionAndAnswerCollection Meteor Methods ', function test() {\n    // this.timeout(10000);\n    const questionCollectionName = MentorQuestions.getCollectionName();\n    const questionDefinition = {\n      question: 'question',\n      slug: 'test-question',\n      student: 'abi@hawaii.edu',\n    };\n    const answerCollectionName = MentorAnswers.getCollectionName();\n    const answerDefinition = {\n      question: 'test-question',\n      mentor: 'rbrewer@gmail.com',\n      text: 'mentor-answer',\n    };\n\n    before(function (done) {\n      this.timeout(5000);\n      defineTestFixturesMethod.call(['minimal', 'abi.student', 'rbrewer.mentor'], done);\n    });\n\n    it('Define Method (Question)', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      const questionID = await defineMethod.callPromise({\n        collectionName: questionCollectionName,\n        definitionData: questionDefinition,\n      });\n      expect(MentorQuestions.isDefined(questionID)).to.be.true;\n    });\n\n    it('Define Method (Answer)', async function () {\n      const answerID = await defineMethod.callPromise({\n        collectionName: answerCollectionName,\n        definitionData: answerDefinition,\n      });\n      expect(MentorAnswers.isDefined(answerID)).to.be.true;\n    });\n\n    it('Question Update Method', async function () {\n      const id = MentorQuestions.findIdBySlug(questionDefinition.slug);\n      const question = 'updated CareerGoal name';\n      const student = 'abi@hawaii.edu';\n      const moderated = true;\n      const visible = false;\n      const moderatorComments = 'comments';\n      await updateMethod.callPromise({\n        collectionName: questionCollectionName,\n        updateData: { id, question, student, moderated, visible, moderatorComments },\n      });\n      const doc = MentorQuestions.findDoc(id);\n      expect(doc.question).to.equal(question);\n    });\n\n    it('Answer Update Method', async function () {\n      const questionID = MentorQuestions.findIdBySlug(questionDefinition.slug);\n      const id = MentorAnswers.findDoc({ questionID })._id;\n      const text = 'updated answer text';\n      await updateMethod.callPromise({ collectionName: answerCollectionName, updateData: { id, text } });\n      const doc = MentorAnswers.findDoc(id);\n      expect(doc.text).to.equal(text);\n    });\n\n    it('Question & Answer Remove Methods', async function () {\n      const questionID = MentorQuestions.findIdBySlug(questionDefinition.slug);\n      const answerID = MentorAnswers.findDoc({ questionID })._id;\n      await removeItMethod.callPromise({ collectionName: answerCollectionName, instance: answerID });\n      expect(MentorAnswers.isDefined(answerID)).to.be.false;\n      await removeItMethod.callPromise({ collectionName: questionCollectionName, instance: questionID });\n      expect(MentorQuestions.isDefined(questionID)).to.be.false;\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/mentor/MentorQuestionAndAnswerCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 728,
    "kind": "file",
    "name": "api/mentor/MentorQuestionCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport 'mocha';\nimport moment from 'moment';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { MentorQuestions } from './MentorQuestionCollection';\nimport { makeSampleUser } from '../user/SampleUsers';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('MentorQuestionCollection', function testSuite() {\n    let question: string;\n    let slug: string;\n    let student: string;\n\n    before(function setup() {\n      removeAllEntities();\n      question = 'Test question.';\n      slug = 'test-mentor-question';\n      student = makeSampleUser();\n    });\n\n    after(function tearDown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(5000);\n      fc.assert(\n        fc.property(fc.lorem(12), fc.lorem(1), fc.boolean(), (fcQuestion, fcSlug, fcRetired) => {\n          student = makeSampleUser();\n          const docID = MentorQuestions.define({ question: fcQuestion, slug: fcSlug, student });\n          expect(MentorQuestions.isDefined(docID)).to.be.true;\n          const doc = MentorQuestions.findDoc(docID);\n          expect(doc.question).to.equal(fcQuestion);\n          expect(doc.studentID).to.equal(student);\n          MentorQuestions.removeIt(docID);\n          expect(MentorQuestions.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Can update', function test2(done) {\n      this.timeout(5000);\n      question = faker.lorem.paragraph();\n      slug = `${student}-question-${moment().format('YYYY-MM-DD-HH-mm-ss-SSSSS')}`;\n      const docID = MentorQuestions.define({ question, slug, student });\n      let doc = MentorQuestions.findDoc(docID);\n      fc.assert(\n        fc.property(fc.lorem(12), fc.boolean(), (fcQuestion, fcRetired) => {\n          MentorQuestions.update(docID, { question: fcQuestion, retired: fcRetired });\n          doc = MentorQuestions.findDoc(docID);\n          expect(doc.question).to.equal(fcQuestion);\n          expect(doc.retired).to.equal(fcRetired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test3() {\n      let doc = MentorQuestions.findOne({});\n      let docID = doc._id;\n      const dumpObject = MentorQuestions.dumpOne(docID);\n      MentorQuestions.removeIt(docID);\n      expect(MentorQuestions.isDefined(docID)).to.be.false;\n      docID = MentorQuestions.restoreOne(dumpObject);\n      doc = MentorQuestions.findDoc(docID);\n      expect(doc.question).to.equal(dumpObject.question);\n      expect(doc.retired).to.equal(dumpObject.retired);\n    });\n\n    it('Can check integrity no errors', function test4() {\n      const problems = MentorQuestions.checkIntegrity();\n      expect(problems.length).to.equal(0);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/mentor/MentorQuestionCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 729,
    "kind": "file",
    "name": "api/mentor/MentorQuestionCollection.ts",
    "content": "import SimpleSchema from 'simpl-schema';\nimport _ from 'lodash';\nimport { MentorAnswers } from './MentorAnswerCollection';\nimport { ROLE } from '../role/Role';\nimport { Slugs } from '../slug/SlugCollection';\nimport { Users } from '../user/UserCollection';\nimport BaseSlugCollection from '../base/BaseSlugCollection';\nimport { IMentorQuestionDefine, IMentorQuestionUpdate } from '../../typings/radgrad';\n\n/**\n * Represents a mentor answer.\n * @extends api/base.BaseSlugCollection\n * @memberOf api/mentor\n */\nclass MentorQuestionCollection extends BaseSlugCollection {\n  /**\n   * Creates the Mentor Question collection.\n   */\n  constructor() {\n    super('MentorQuestion', new SimpleSchema({\n      question: { type: String },\n      slugID: { type: SimpleSchema.RegEx.Id, optional: true },\n      studentID: { type: SimpleSchema.RegEx.Id },\n      moderated: { type: Boolean },\n      visible: { type: Boolean },\n      moderatorComments: { type: String, optional: true },\n      retired: { type: Boolean, optional: true },\n    }));\n    this.defineSchema = new SimpleSchema({\n      question: String,\n      slug: String,\n      student: String,\n      moderated: { type: Boolean, optional: true },\n      visible: { type: Boolean, optional: true },\n      moderatorComments: { type: String, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n    this.updateSchema = new SimpleSchema({\n      question: { type: String, optional: true },\n      student: { type: String, optional: true },\n      moderated: { type: Boolean, optional: true },\n      visible: { type: Boolean, optional: true },\n      moderatorComments: { type: String, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines a new MentorSpace question.\n   * @param question the question.\n   * @param slug A unique identifier for this question.\n   * @param student The student that asked this question.\n   * @param moderated If the question is moderated. Defaults to false.\n   * @param visible If the question is visible. Defaults to false.\n   * @param moderatorComments any comments from the moderator.\n   * @return { String } the docID of this question.\n   */\n  public define({ question, slug, student, moderated = false, visible = false, moderatorComments = '', retired = false }: IMentorQuestionDefine) {\n    const studentID = Users.getID(student);\n    const slugID = Slugs.define({ name: slug, entityName: this.getType() });\n    const docID = this.collection.insert({ question, slugID, studentID, moderated, visible, moderatorComments, retired });\n    Slugs.updateEntityID(slugID, docID);\n    return docID;\n  }\n\n  /**\n   * Updates the moderator question.\n   * @param instance the id or slug (required).\n   * @param question the question (optional).\n   * @param student the student's id or username (optional).\n   * @param moderated boolean (optional).\n   * @param visible boolean (optional).\n   * @param moderatorComments string (optional).\n   */\n  public update(instance: string, { question, student, moderated, visible, moderatorComments, retired }: IMentorQuestionUpdate) {\n    const docID = this.getID(instance);\n    const updateData: { question?: string; studentID?: string; moderated?: boolean; visible?: boolean; moderatorComments?: string; retired?: boolean; } = {};\n    if (question) {\n      updateData.question = question;\n    }\n    if (student) {\n      updateData.studentID = Users.getID(student);\n    }\n    if (_.isBoolean(moderated)) {\n      updateData.moderated = moderated;\n    }\n    if (_.isBoolean(visible)) {\n      updateData.visible = visible;\n    }\n    if (moderatorComments) {\n      updateData.moderatorComments = moderatorComments;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the course instance.\n   * @param docID The docID of the course instance.\n   */\n  public removeIt(docID: string) {\n    this.assertDefined(docID);\n    // remove the Answers associated with this question\n    MentorAnswers.removeQuestion(docID);\n    // OK, clear to delete.\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\n   * Student.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.STUDENT]);\n  }\n\n  public getQuestions() {\n    return this.collection.find({}).fetch().reverse();\n  }\n\n  /**\n   * Checks to see that slugID and studentID are defined.\n   * @returns {Array} An array of error message(s) if either are not defined.\n   */\n  public checkIntegrity(): string[] {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (doc.slugID) {\n        if (!Slugs.isDefined(doc.slugID)) {\n          problems.push(`Bad slugID: ${doc.slugID}`);\n        }\n      }\n      if (!Users.isDefined(doc.studentID)) {\n        problems.push(`Bad studentID: ${doc.studentID}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the MentorQuestion docID in a format acceptable to define().\n   * @param docID The docID of a MentorQuestion.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IMentorQuestionDefine {\n    const doc = this.findDoc(docID);\n    const question = doc.question;\n    let slug;\n    if (doc.slugID) {\n      slug = Slugs.getNameFromID(doc.slugID);\n    }\n    const student = Users.getProfile(doc.studentID).username;\n    const moderated = doc.moderated;\n    const visible = doc.visible;\n    const moderatorComments = doc.moderatorComments;\n    const retired = doc.retired;\n    return { question, slug, student, moderated, visible, moderatorComments, retired };\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @type {api/mentor.MentorQuestionCollection}\n * @memberOf api/mentor\n */\nexport const MentorQuestions = new MentorQuestionCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/mentor/MentorQuestionCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 730,
    "kind": "variable",
    "name": "MentorQuestions",
    "memberof": "api/mentor/MentorQuestionCollection.ts",
    "static": true,
    "longname": "api/mentor/MentorQuestionCollection.ts~MentorQuestions",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/mentor/MentorQuestionCollection.ts",
    "importStyle": "{MentorQuestions}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 181,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/mentor"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/mentor.MentorQuestionCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 731,
    "kind": "class",
    "name": "MentorQuestionCollection",
    "memberof": "api/mentor/MentorQuestionCollection.ts",
    "static": true,
    "longname": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/mentor/MentorQuestionCollection.ts",
    "importStyle": null,
    "description": "Represents a mentor answer.",
    "lineNumber": 15,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseSlugCollection.js~BaseSlugCollection"
    ]
  },
  {
    "__docId__": 732,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection#constructor",
    "access": "public",
    "description": "Creates the Mentor Question collection.",
    "lineNumber": 18
  },
  {
    "__docId__": 733,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection",
    "static": false,
    "longname": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 734,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection",
    "static": false,
    "longname": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 735,
    "kind": "method",
    "name": "define",
    "memberof": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection#define",
    "access": "public",
    "description": "Defines a new MentorSpace question.",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "IMentorQuestionDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 736,
    "kind": "method",
    "name": "update",
    "memberof": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection#update",
    "access": "public",
    "description": "Updates the moderator question.",
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IMentorQuestionUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 737,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection#removeIt",
    "access": "public",
    "description": "Remove the course instance.",
    "lineNumber": 103,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 738,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\nStudent.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 118,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 739,
    "kind": "method",
    "name": "getQuestions",
    "memberof": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection#getQuestions",
    "access": "public",
    "description": "",
    "lineNumber": 122,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 740,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection#checkIntegrity",
    "access": "public",
    "description": "Checks to see that slugID and studentID are defined.",
    "lineNumber": 130,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 741,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/mentor/MentorQuestionCollection.ts~MentorQuestionCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the MentorQuestion docID in a format acceptable to define().",
    "lineNumber": 150,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IMentorQuestionDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 742,
    "kind": "file",
    "name": "api/mentor/SampleMentorQuestionAndAnswer.ts",
    "content": "import moment from 'moment';\nimport faker from 'faker';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { MentorQuestions } from './MentorQuestionCollection';\nimport { ROLE } from '../role/Role';\nimport { MentorAnswers } from './MentorAnswerCollection';\n\nexport const makeSampleMentorQuestion = () => {\n  const question = faker.lorem.paragraph();\n  const student = makeSampleUser();\n  const slug = `${student}-question-${moment().format('YYYY-MM-DD-HH-mm-ss-SSSSS')}`;\n  return MentorQuestions.define({ question, student, slug });\n};\n\nexport const makeSampleMentorAnswer = () => {\n  const mentor = makeSampleUser(ROLE.MENTOR);\n  const text = faker.lorem.paragraph();\n  const question = makeSampleMentorQuestion();\n  return MentorAnswers.define({ question, mentor, text });\n};\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/mentor/SampleMentorQuestionAndAnswer.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 743,
    "kind": "function",
    "name": "makeSampleMentorQuestion",
    "memberof": "api/mentor/SampleMentorQuestionAndAnswer.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/mentor/SampleMentorQuestionAndAnswer.ts~makeSampleMentorQuestion",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/mentor/SampleMentorQuestionAndAnswer.ts",
    "importStyle": "{makeSampleMentorQuestion}",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 744,
    "kind": "function",
    "name": "makeSampleMentorAnswer",
    "memberof": "api/mentor/SampleMentorQuestionAndAnswer.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/mentor/SampleMentorQuestionAndAnswer.ts~makeSampleMentorAnswer",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/mentor/SampleMentorQuestionAndAnswer.ts",
    "importStyle": "{makeSampleMentorAnswer}",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 745,
    "kind": "file",
    "name": "api/mentor/index.ts",
    "content": "/** @namespace api/mentor */\nimport './MentorAnswerCollection';\nimport './MentorQuestionCollection';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/mentor/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 746,
    "kind": "file",
    "name": "api/opportunity/OpportunityCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { Opportunities } from './OpportunityCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('OpportunityCollection Meteor Methods ', function test() {\n    const collectionName = Opportunities.getCollectionName();\n    const definitionData = {\n      name: 'name',\n      slug: 'opportunity-slug-example',\n      description: 'description',\n      opportunityType: 'club',\n      sponsor: 'radgrad@hawaii.edu',\n      ice: { i: 5, c: 5, e: 5 },\n      interests: ['algorithms'],\n      academicTerms: ['Spring-2017'],\n    };\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal', 'opportunities'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      await defineMethod.callPromise({ collectionName, definitionData });\n    });\n\n    it('Update Method', async function () {\n      const id = Opportunities.findIdBySlug(definitionData.slug);\n      const description = 'updated description';\n      await updateMethod.callPromise({ collectionName, updateData: { id, description } });\n    });\n\n    it('Remove Method', async function () {\n      await removeItMethod.callPromise({ collectionName, instance: definitionData.slug });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/opportunity/OpportunityCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 747,
    "kind": "file",
    "name": "api/opportunity/OpportunityCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport { ROLE } from '../role/Role';\nimport { Opportunities } from './OpportunityCollection';\nimport { makeSampleInterestArray } from '../interest/SampleInterests';\nimport { makeSampleOpportunity, makeSampleOpportunityType } from './SampleOpportunities';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { makeSampleAcademicTermArray } from '../academic-term/SampleAcademicTerms';\nimport { makeSampleIce } from '../ice/SampleIce';\nimport { Slugs } from '../slug/SlugCollection';\nimport { IOpportunity, IOpportunityType } from '../../typings/radgrad';\nimport { OpportunityTypes } from './OpportunityTypeCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('OpportunityCollection', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(15000);\n      fc.assert(\n        fc.property(fc.lorem(2), fc.lorem(1), fc.lorem(10), (name, slug, description) => {\n          const sponsor = makeSampleUser(ROLE.FACULTY);\n          const interests = makeSampleInterestArray(3);\n          const opportunityType = makeSampleOpportunityType();\n          const academicTerms = makeSampleAcademicTermArray();\n          const ice = makeSampleIce();\n          const docID = Opportunities.define({\n            name,\n            slug,\n            description,\n            sponsor,\n            academicTerms,\n            interests,\n            opportunityType,\n            ice,\n          });\n          expect(Opportunities.isDefined(docID)).to.be.true;\n          const doc = Opportunities.findDoc(docID);\n          expect(doc.name).to.equal(name);\n          expect(doc.description).to.equal(description);\n          expect(Slugs.getNameFromID(doc.slugID)).to.equal(slug);\n          expect(doc.ice.i).to.equal(ice.i);\n          expect(doc.ice.c).to.equal(ice.c);\n          expect(doc.ice.e).to.equal(ice.e);\n          Opportunities.removeIt(docID);\n          expect(Opportunities.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Can define duplicates', function test2(done) {\n      const name = faker.lorem.words();\n      const slug = faker.lorem.word();\n      const ice = makeSampleIce();\n      const description = faker.lorem.paragraph();\n      const opportunityType = makeSampleOpportunityType();\n      const sponsor = makeSampleUser(ROLE.FACULTY);\n      const interests = makeSampleInterestArray(2);\n      const academicTerms = makeSampleAcademicTermArray();\n      const docID1 = Opportunities.define({\n        name,\n        slug,\n        description,\n        opportunityType,\n        ice,\n        sponsor,\n        academicTerms,\n        interests,\n      });\n      const docID2 = Opportunities.define({\n        name,\n        slug,\n        description,\n        opportunityType,\n        ice,\n        sponsor,\n        academicTerms,\n        interests,\n      });\n      expect(Opportunities.isDefined(slug)).to.be.true;\n      expect(Opportunities.isDefined(docID1)).to.be.true;\n      expect(Opportunities.isDefined(docID2)).to.be.true;\n      expect(docID1).to.equal(docID2);\n      Opportunities.removeIt(docID1);\n      expect(Opportunities.isDefined(slug)).to.be.false;\n      expect(Opportunities.isDefined(docID1)).to.be.false;\n      expect(Opportunities.isDefined(docID2)).to.be.false;\n      done();\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(10000);\n      const name = faker.lorem.words();\n      const slug = faker.lorem.word();\n      let ice = makeSampleIce();\n      const description = faker.lorem.paragraph();\n      let opportunityType = makeSampleOpportunityType();\n      let sponsor = makeSampleUser(ROLE.FACULTY);\n      let interests = makeSampleInterestArray(2);\n      let academicTerms = makeSampleAcademicTermArray();\n      const docID = Opportunities.define({\n        name,\n        slug,\n        description,\n        opportunityType,\n        ice,\n        sponsor,\n        academicTerms,\n        interests,\n      });\n      let doc = Opportunities.findDoc(docID);\n      fc.assert(\n        fc.property(fc.lorem(2), fc.lorem(10), fc.boolean(), (fcName, fcDescription, retired) => {\n          ice = makeSampleIce();\n          opportunityType = makeSampleOpportunityType();\n          sponsor = makeSampleUser(ROLE.FACULTY);\n          interests = makeSampleInterestArray(2);\n          academicTerms = makeSampleAcademicTermArray();\n          Opportunities.update(docID, {\n            name: fcName,\n            description: fcDescription,\n            academicTerms,\n            ice,\n            interests,\n            sponsor,\n            opportunityType,\n            retired,\n          });\n          doc = Opportunities.findDoc(docID);\n          expect(doc.name).to.equal(fcName);\n          expect(doc.description).to.equal(fcDescription);\n          expect(doc.ice.i).to.equal(ice.i);\n          expect(doc.ice.c).to.equal(ice.c);\n          expect(doc.ice.e).to.equal(ice.e);\n          expect(doc.retired).to.equal(retired);\n        }),\n      );\n      Opportunities.removeIt(docID);\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      const sponsor = makeSampleUser(ROLE.FACULTY);\n      let docID = makeSampleOpportunity(sponsor);\n      const origOpp: IOpportunity = Opportunities.findDoc(docID);\n      const dumpObject = Opportunities.dumpOne(docID);\n      Opportunities.removeIt(docID);\n      expect(Opportunities.isDefined(docID)).to.be.false;\n      docID = Opportunities.restoreOne(dumpObject);\n      const restored: IOpportunity = Opportunities.findDoc(docID);\n      expect(origOpp.name).to.equal(restored.name);\n      // expect(origOpp.slugID).to.equal(restored.slugID);\n      expect(origOpp.description).to.equal(restored.description);\n      expect(origOpp.retired).to.equal(restored.retired);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const problems = Opportunities.checkIntegrity();\n      expect(problems.length).to.equal(0);\n    });\n\n    it('Can getOpportunityTypeDoc and hasInterest', function test6() {\n      const name = faker.lorem.words();\n      const slug = faker.lorem.word();\n      const ice = makeSampleIce();\n      const description = faker.lorem.paragraph();\n      const opportunityType = makeSampleOpportunityType();\n      const sponsor = makeSampleUser(ROLE.FACULTY);\n      const interests = makeSampleInterestArray(2);\n      const academicTerms = makeSampleAcademicTermArray();\n      const docID = Opportunities.define({\n        name,\n        slug,\n        description,\n        opportunityType,\n        ice,\n        sponsor,\n        academicTerms,\n        interests,\n      });\n      const oppTypeDocOrig: IOpportunityType = OpportunityTypes.findDoc(opportunityType);\n      const oppTypeDoc: IOpportunityType = Opportunities.getOpportunityTypeDoc(docID);\n      expect(oppTypeDocOrig.name).to.equal(oppTypeDoc.name);\n      expect(oppTypeDocOrig.description).to.equal(oppTypeDoc.description);\n      expect(oppTypeDocOrig.retired).to.equal(oppTypeDoc.retired);\n      expect(Opportunities.hasInterest(docID, interests[0])).to.be.true;\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/opportunity/OpportunityCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 748,
    "kind": "file",
    "name": "api/opportunity/OpportunityCollection.ts",
    "content": "import SimpleSchema from 'simpl-schema';\nimport { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport { Slugs } from '../slug/SlugCollection';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { Teasers } from '../teaser/TeaserCollection';\nimport { Interests } from '../interest/InterestCollection';\nimport { ROLE } from '../role/Role';\nimport { Users } from '../user/UserCollection';\nimport { OpportunityTypes } from './OpportunityTypeCollection';\nimport { OpportunityInstances } from './OpportunityInstanceCollection';\nimport { Feeds } from '../feed/FeedCollection';\nimport BaseSlugCollection from '../base/BaseSlugCollection';\nimport { assertICE, iceSchema } from '../ice/IceProcessor';\nimport { IOpportunityDefine, IOpportunityUpdate, IOpportunityUpdateData } from '../../typings/radgrad';\n\n/**\n * Represents an Opportunity, such as \"LiveWire Internship\".\n * To represent an Opportunity taken by a specific student in a specific academicTerm, use OpportunityInstance.\n * @extends api/base.BaseSlugCollection\n * @memberOf api/opportunity\n */\nclass OpportunityCollection extends BaseSlugCollection {\n\n  /**\n   * Creates the Opportunity collection.\n   */\n  constructor() {\n    super('Opportunity', new SimpleSchema({\n      name: { type: String },\n      slugID: { type: String },\n      description: { type: String },\n      opportunityTypeID: { type: SimpleSchema.RegEx.Id },\n      sponsorID: { type: SimpleSchema.RegEx.Id },\n      interestIDs: [SimpleSchema.RegEx.Id],\n      termIDs: [SimpleSchema.RegEx.Id],\n      // Optional data\n      eventDate: { type: Date, optional: true },\n      ice: { type: iceSchema, optional: true },\n      retired: { type: Boolean, optional: true },\n    }));\n    this.defineSchema = new SimpleSchema({\n      name: String,\n      slug: String,\n      description: String,\n      opportunityType: String,\n      sponsor: String,\n      terms: Array,\n      'terms.$': String,\n      eventDate: { type: Date, optional: true },\n      ice: { type: iceSchema, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n    this.updateSchema = new SimpleSchema({\n      name: { type: String, optional: true },\n      description: { type: String, optional: true },\n      opportunityType: { type: String, optional: true },\n      sponsor: { type: String, optional: true },\n      terms: { type: Array, optional: true },\n      'terms.$': String,\n      eventDate: { type: Date, optional: true },\n      ice: { type: iceSchema, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines a new Opportunity.\n   * @example\n   * Opportunities.define({ name: 'ATT Hackathon',\n   *                        slug: 'att-hackathon',\n   *                        description: 'Programming challenge at Sacred Hearts Academy, $10,000 prize',\n   *                        opportunityType: 'event',\n   *                        sponsor: 'philipjohnson',\n   *                        ice: { i: 10, c: 0, e: 10},\n   *                        interests: ['software-engineering'],\n   *                        academicTerms: ['Fall-2016', 'Spring-2016', 'Summer-2106'],\n   *                      });\n   * @param { Object } description Object with keys name, slug, description, opportunityType, sponsor, interests,\n   * @param name the name of the opportunity.\n   * @param slug must not be previously defined.\n   * @param description the description of the opportunity. Can be markdown.\n   * @param opportunityType must be defined slug.\n   * @param interests must be a (possibly empty) array of interest slugs or IDs.\n   * @param academicTerms must be a (possibly empty) array of academicTerm slugs or IDs.\n   * @param sponsor must be a User with role 'FACULTY', 'ADVISOR', or 'ADMIN'.\n   * @param ice must be a valid ICE object.\n   * @param eventDate optional date.\n   * @param retired optional, true if the opportunity is retired.\n   * @throws {Meteor.Error} If the definition includes a defined slug or undefined interest, sponsor, opportunityType,\n   * or startActive or endActive are not valid.\n   * @returns The newly created docID.\n   */\n  public define({ name, slug, description, opportunityType, sponsor, interests, academicTerms, ice, eventDate = null, retired = false }: IOpportunityDefine) {\n    // Get instances, or throw error\n\n    const opportunityTypeID = OpportunityTypes.getID(opportunityType);\n    const sponsorID = Users.getID(sponsor);\n    Users.assertInRole(sponsorID, [ROLE.FACULTY, ROLE.ADVISOR, ROLE.ADMIN]);\n    assertICE(ice);\n    const interestIDs = Interests.getIDs(interests);\n    // check if slug is defined\n    if (Slugs.isSlugForEntity(slug, this.getType())) {\n      // console.log(`${slug} is already defined for ${this.getType()}`);\n      return Slugs.getEntityID(slug, this.getType());\n    }\n    const slugID = Slugs.define({ name: slug, entityName: this.getType() });\n    const termIDs = AcademicTerms.getIDs(academicTerms);\n    let opportunityID;\n    if (eventDate !== null) {\n      // Define the new Opportunity and its Slug.\n      opportunityID = this.collection.insert({\n        name, slugID, description, opportunityTypeID, sponsorID,\n        interestIDs, termIDs, ice, eventDate, retired });\n    } else {\n      opportunityID = this.collection.insert({\n        name, slugID, description, opportunityTypeID, sponsorID,\n        interestIDs, termIDs, ice, retired });\n    }\n    Slugs.updateEntityID(slugID, opportunityID);\n\n    // Return the id to the newly created Opportunity.\n    return opportunityID;\n  }\n\n  /**\n   * Update an Opportunity.\n   * @param instance The docID or slug associated with this opportunity.\n   * @param name optional.\n   * @param description optional.\n   * @param opportunityType docID or slug (optional.)\n   * @param sponsor user in role admin, advisor, or faculty. optional.\n   * @param interests optional.\n   * @param academicTerms optional\n   * @param eventDate a Date. (optional)\n   * @param ice An ICE object (optional).\n   * @param retired boolean (optional).\n   */\n  public update(instance: string, { name, description, opportunityType, sponsor, interests, academicTerms, eventDate, ice, retired }: IOpportunityUpdate) {\n    const docID = this.getID(instance);\n    const updateData: IOpportunityUpdateData = {};\n    if (name) {\n      updateData.name = name;\n    }\n    if (description) {\n      updateData.description = description;\n    }\n    if (opportunityType) {\n      updateData.opportunityTypeID = OpportunityTypes.getID(opportunityType);\n    }\n    if (sponsor) {\n      const sponsorID = Users.getID(sponsor);\n      Users.assertInRole(sponsorID, [ROLE.FACULTY, ROLE.ADVISOR, ROLE.ADMIN]);\n      updateData.sponsorID = sponsorID;\n    }\n    if (interests) {\n      updateData.interestIDs = Interests.getIDs(interests);\n    }\n    if (academicTerms) {\n      updateData.termIDs = AcademicTerms.getIDs(academicTerms);\n    }\n    if (eventDate) {\n      updateData.eventDate = eventDate;\n    }\n    if (ice) {\n      assertICE(ice);\n      updateData.ice = ice;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the Course.\n   * @param instance The docID or slug of the entity to be removed.\n   * @throws { Meteor.Error } If docID is not a Course, or if this course has any associated course instances.\n   */\n  public removeIt(instance: string) {\n    const docID = this.getID(instance);\n    // Check that this opportunity is not referenced by any Opportunity Instance.\n    OpportunityInstances.find().map((opportunityInstance) => {\n      if (opportunityInstance.opportunityID === docID) {\n        throw new Meteor.Error(`Opportunity ${instance} referenced by a opportunity instance ${opportunityInstance}.`);\n      }\n      return true;\n    });\n    // Check that this opportunity is not referenced by any Teaser.\n    Teasers.find().map((teaser) => {\n      if (Teasers.hasTarget(teaser, docID)) {\n        throw new Meteor.Error(`Opportunity ${instance} referenced by a teaser ${teaser}.`);\n      }\n      return true;\n    });\n    // OK to delete. First remove any Feeds that reference this opportunity.\n    Feeds.find({ opportunityID: docID }).map((feed) => Feeds.removeIt(feed._id));\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Asserts that userId is logged in as an Admin, Faculty, or Advisor.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not in the allowed roles.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.FACULTY]);\n  }\n\n  /**\n   * Returns the OpportunityType associated with the Opportunity with the given instanceID.\n   * @param instanceID The id of the Opportunity.\n   * @returns {Object} The associated Opportunity.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  public getOpportunityTypeDoc(instanceID: string) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return OpportunityTypes.findDoc(instance.opportunityTypeID);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks slugID, opportunityTypeID, sponsorID, interestIDs, termIDs\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (!Slugs.isDefined(doc.slugID)) {\n        problems.push(`Bad slugID: ${doc.slugID}`);\n      }\n      if (!OpportunityTypes.isDefined(doc.opportunityTypeID)) {\n        problems.push(`Bad opportunityTypeID: ${doc.opportunityTypeID}`);\n      }\n      if (!Users.isDefined(doc.sponsorID)) {\n        problems.push(`Bad sponsorID: ${doc.sponsorID}`);\n      }\n      _.forEach(doc.interestIDs, (interestID) => {\n        if (!Interests.isDefined(interestID)) {\n          problems.push(`Bad interestID: ${interestID}`);\n        }\n      });\n      _.forEach(doc.termIDs, (termID) => {\n        if (!AcademicTerms.isDefined(termID)) {\n          problems.push(`Bad termID: ${termID}`);\n        }\n      });\n    });\n    return problems;\n  }\n\n  /**\n   * Returns true if Opportunity has the specified interest.\n   * @param opportunity The opportunity(docID or slug)\n   * @param interest The Interest (docID or slug).\n   * @returns {boolean} True if the opportunity has the associated Interest.\n   * @throws { Meteor.Error } If opportunity is not a opportunity or interest is not a Interest.\n   */\n  public hasInterest(opportunity: string, interest: string) {\n    const interestID = Interests.getID(interest);\n    const doc = this.findDoc(opportunity);\n    return _.includes(doc.interestIDs, interestID);\n  }\n\n  /**\n   * Returns an object representing the Opportunity docID in a format acceptable to define().\n   * @param docID The docID of an Opportunity.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IOpportunityDefine {\n    const doc = this.findDoc(docID);\n    const name = doc.name;\n    const slug = Slugs.getNameFromID(doc.slugID);\n    const opportunityType = OpportunityTypes.findSlugByID(doc.opportunityTypeID);\n    const sponsor = Users.getProfile(doc.sponsorID).username;\n    const description = doc.description;\n    const ice = doc.ice;\n    const interests = _.map(doc.interestIDs, (interestID) => Interests.findSlugByID(interestID));\n    const academicTerms = _.map(doc.termIDs, (termID) => AcademicTerms.findSlugByID(termID));\n    const eventDate = doc.eventDate;\n    const retired = doc.retired;\n    return { name, slug, description, opportunityType, sponsor, ice, interests, academicTerms, eventDate, retired };\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @type {api/opportunity.OpportunityCollection}\n * @memberOf api/opportunity\n */\nexport const Opportunities = new OpportunityCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/opportunity/OpportunityCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 749,
    "kind": "variable",
    "name": "Opportunities",
    "memberof": "api/opportunity/OpportunityCollection.ts",
    "static": true,
    "longname": "api/opportunity/OpportunityCollection.ts~Opportunities",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/OpportunityCollection.ts",
    "importStyle": "{Opportunities}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 280,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/opportunity"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/opportunity.OpportunityCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 750,
    "kind": "class",
    "name": "OpportunityCollection",
    "memberof": "api/opportunity/OpportunityCollection.ts",
    "static": true,
    "longname": "api/opportunity/OpportunityCollection.ts~OpportunityCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/OpportunityCollection.ts",
    "importStyle": null,
    "description": "Represents an Opportunity, such as \"LiveWire Internship\".\nTo represent an Opportunity taken by a specific student in a specific academicTerm, use OpportunityInstance.",
    "lineNumber": 23,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseSlugCollection.js~BaseSlugCollection"
    ]
  },
  {
    "__docId__": 751,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/opportunity/OpportunityCollection.ts~OpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityCollection.ts~OpportunityCollection#constructor",
    "access": "public",
    "description": "Creates the Opportunity collection.",
    "lineNumber": 26
  },
  {
    "__docId__": 752,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/opportunity/OpportunityCollection.ts~OpportunityCollection",
    "static": false,
    "longname": "api/opportunity/OpportunityCollection.ts~OpportunityCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 753,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/opportunity/OpportunityCollection.ts~OpportunityCollection",
    "static": false,
    "longname": "api/opportunity/OpportunityCollection.ts~OpportunityCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 754,
    "kind": "method",
    "name": "define",
    "memberof": "api/opportunity/OpportunityCollection.ts~OpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityCollection.ts~OpportunityCollection#define",
    "access": "public",
    "description": "Defines a new Opportunity.",
    "lineNumber": 94,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOpportunityDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 755,
    "kind": "method",
    "name": "update",
    "memberof": "api/opportunity/OpportunityCollection.ts~OpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityCollection.ts~OpportunityCollection#update",
    "access": "public",
    "description": "Update an Opportunity.",
    "lineNumber": 139,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IOpportunityUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 756,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/opportunity/OpportunityCollection.ts~OpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityCollection.ts~OpportunityCollection#removeIt",
    "access": "public",
    "description": "Remove the Course.",
    "lineNumber": 180,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 757,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/opportunity/OpportunityCollection.ts~OpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityCollection.ts~OpportunityCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Asserts that userId is logged in as an Admin, Faculty, or Advisor.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 207,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 758,
    "kind": "method",
    "name": "getOpportunityTypeDoc",
    "memberof": "api/opportunity/OpportunityCollection.ts~OpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityCollection.ts~OpportunityCollection#getOpportunityTypeDoc",
    "access": "public",
    "description": "Returns the OpportunityType associated with the Opportunity with the given instanceID.",
    "lineNumber": 217,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 759,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/opportunity/OpportunityCollection.ts~OpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityCollection.ts~OpportunityCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks slugID, opportunityTypeID, sponsorID, interestIDs, termIDs",
    "lineNumber": 229,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 760,
    "kind": "method",
    "name": "hasInterest",
    "memberof": "api/opportunity/OpportunityCollection.ts~OpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityCollection.ts~OpportunityCollection#hasInterest",
    "access": "public",
    "description": "Returns true if Opportunity has the specified interest.",
    "lineNumber": 262,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opportunity",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "interest",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 761,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/opportunity/OpportunityCollection.ts~OpportunityCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityCollection.ts~OpportunityCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the Opportunity docID in a format acceptable to define().",
    "lineNumber": 273,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IOpportunityDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 762,
    "kind": "file",
    "name": "api/opportunity/OpportunityInstanceCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { OpportunityInstances } from './OpportunityInstanceCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('OpportunityInstanceCollection Meteor Methods ', function test() {\n    const collectionName = OpportunityInstances.getCollectionName();\n    const academicTerm = 'Spring-2017';\n    const student = 'abi@hawaii.edu';\n    const opportunity = 'acm-manoa';\n    const verified = true;\n    const definitionData = { academicTerm, opportunity, student, verified };\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal', 'abi.student', 'opportunities'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      await defineMethod.callPromise({ collectionName, definitionData });\n    });\n\n    it('Update Method', async function () {\n      const id = OpportunityInstances.findOpportunityInstanceDoc(academicTerm, opportunity, student)._id;\n      await updateMethod.callPromise({ collectionName, updateData: { id, verified: false } });\n    });\n\n    it('Remove Method', async function () {\n      const instance = OpportunityInstances.findOpportunityInstanceDoc(academicTerm, opportunity, student)._id;\n      await removeItMethod.callPromise({ collectionName, instance });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/opportunity/OpportunityInstanceCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 763,
    "kind": "file",
    "name": "api/opportunity/OpportunityInstanceCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport 'mocha';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { ROLE } from '../role/Role';\nimport { OpportunityInstances } from './OpportunityInstanceCollection';\nimport { makeSampleOpportunity } from './SampleOpportunities';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { VerificationRequests } from '../verification/VerificationRequestCollection';\nimport { makeSampleAcademicTerm } from '../academic-term/SampleAcademicTerms';\nimport { makeSampleIce } from '../ice/SampleIce';\nimport { IAcademicTerm, IOpportunity, IOpportunityInstance } from '../../typings/radgrad';\nimport { Users } from '../user/UserCollection';\nimport { Opportunities } from './OpportunityCollection';\nimport { Slugs } from '../slug/SlugCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('OpportunityInstanceCollection', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(5000);\n      const academicTerm = makeSampleAcademicTerm();\n      const sponsor = makeSampleUser(ROLE.FACULTY);\n      const opportunity = makeSampleOpportunity(sponsor);\n      const student = makeSampleUser();\n      fc.assert(\n        fc.property(fc.boolean(), fc.boolean(), (verified, retired) => {\n          const docID = OpportunityInstances.define({ opportunity, academicTerm, student, sponsor, verified, retired });\n          const vrID = VerificationRequests.define({ student, opportunityInstance: docID });\n          expect(OpportunityInstances.isDefined(docID)).to.be.true;\n          expect(VerificationRequests.isDefined(vrID)).to.be.true;\n          const doc = OpportunityInstances.findDoc(docID);\n          expect(doc.retired).to.equal(retired);\n          expect(doc.verified).to.equal(verified);\n          OpportunityInstances.removeIt(docID);\n          expect(OpportunityInstances.isDefined(docID)).to.be.false;\n          expect(VerificationRequests.isDefined(vrID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicates', function test2() {\n      const academicTerm = makeSampleAcademicTerm();\n      const sponsor = makeSampleUser(ROLE.FACULTY);\n      const opportunity = makeSampleOpportunity(sponsor);\n      const student = makeSampleUser();\n      const verified = false;\n      const docID1 = OpportunityInstances.define({ opportunity, academicTerm, student, sponsor, verified });\n      const docID2 = OpportunityInstances.define({ opportunity, academicTerm, student, sponsor, verified });\n      expect(OpportunityInstances.isDefined(docID1)).to.be.true;\n      expect(OpportunityInstances.isDefined(docID2)).to.be.true;\n      expect(docID1).to.equal(docID2);\n      OpportunityInstances.removeIt(docID1);\n      expect(OpportunityInstances.isDefined(docID1)).to.be.false;\n      expect(OpportunityInstances.isDefined(docID2)).to.be.false;\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      let academicTerm = makeSampleAcademicTerm();\n      const sponsor = makeSampleUser(ROLE.FACULTY);\n      const opportunity = makeSampleOpportunity(sponsor);\n      const student = makeSampleUser();\n      const verified = false;\n      const docID = OpportunityInstances.define({ opportunity, academicTerm, student, sponsor, verified });\n      let doc: IOpportunityInstance = OpportunityInstances.findDoc(docID);\n      fc.assert(\n        fc.property(fc.boolean(), fc.boolean(), (fcVerified, retired) => {\n          const ice = makeSampleIce();\n          academicTerm = makeSampleAcademicTerm();\n          OpportunityInstances.update(docID, { ice, termID: academicTerm, verified: fcVerified, retired });\n          doc = OpportunityInstances.findDoc(docID);\n          expect(doc.ice.i).to.equal(ice.i);\n          expect(doc.ice.c).to.equal(ice.c);\n          expect(doc.ice.e).to.equal(ice.e);\n          expect(doc.verified).to.equal(fcVerified);\n          expect(doc.retired).to.equal(retired);\n          expect(doc.termID).to.equal(academicTerm);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      const oi: IOpportunityInstance = OpportunityInstances.findOne({});\n      let docID = oi._id;\n      const dumpObject = OpportunityInstances.dumpOne(docID);\n      OpportunityInstances.removeIt(docID);\n      expect(OpportunityInstances.isDefined(docID)).to.be.false;\n      docID = OpportunityInstances.restoreOne(dumpObject);\n      const restored = OpportunityInstances.findDoc(docID);\n      expect(OpportunityInstances.isDefined(docID)).to.be.true;\n      expect(oi.studentID).to.equal(restored.studentID);\n      expect(oi.termID).to.equal(restored.termID);\n      expect(oi.verified).to.equal(restored.verified);\n      expect(oi.retired).to.equal(restored.retired);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const problems = OpportunityInstances.checkIntegrity();\n      const oi: IOpportunityInstance = OpportunityInstances.findOne({});\n\n      if (oi.verified) {\n        expect(problems.length).to.equal(1);\n      } else {\n        expect(problems.length).to.equal(0);\n      }\n    });\n\n    it('Can getOpportunityDoc, getOpportunitySlug, getAcademicTermDoc, getStudentDoc', function test6() {\n      const oi: IOpportunityInstance = OpportunityInstances.findOne({});\n      const docID = oi._id;\n      const opportunity: IOpportunity = Opportunities.findDoc(oi.opportunityID);\n      /* getOpportunityDoc */\n      const oDoc = OpportunityInstances.getOpportunityDoc(docID);\n\n      expect(opportunity.name).to.equal(oDoc.name);\n      expect(opportunity.description).to.equal(oDoc.description);\n      expect(opportunity.ice.i).to.equal(oDoc.ice.i);\n      expect(opportunity.ice.c).to.equal(oDoc.ice.c);\n      expect(opportunity.ice.e).to.equal(oDoc.ice.e);\n\n      /* getOpportunitySlug */\n      const opportunitySlug = Slugs.getNameFromID(opportunity.slugID);\n\n      expect(OpportunityInstances.getOpportunitySlug(docID)).to.equal(opportunitySlug);\n\n      /* getAcademicTermDoc */\n      const academicTerm: IAcademicTerm = AcademicTerms.findDoc(oi.termID);\n      const aDoc: IAcademicTerm = OpportunityInstances.getAcademicTermDoc(docID);\n\n      expect(academicTerm.year).to.equal(aDoc.year);\n      expect(academicTerm.term).to.equal(aDoc.term);\n      expect(academicTerm.termNumber).to.equal(aDoc.termNumber);\n\n      /* getStudentDoc */\n      const student = Users.getProfile(oi.studentID);\n      const sDoc = OpportunityInstances.getStudentDoc(docID);\n\n      expect(student.username).to.equal(sDoc.username);\n      expect(student.firstName).to.equal(sDoc.firstName);\n      expect(student.lastName).to.equal(sDoc.lastName);\n    });\n\n    it('Can removeUser', function test7() {\n      const oi: IOpportunityInstance = OpportunityInstances.findOne({});\n      const docID = oi._id;\n      const studentID = oi.studentID;\n      OpportunityInstances.removeUser(studentID);\n\n      expect(OpportunityInstances.find({ studentID }).count()).to.equal(0);\n      expect(OpportunityInstances.isDefined(docID)).to.be.false;\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/opportunity/OpportunityInstanceCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 764,
    "kind": "file",
    "name": "api/opportunity/OpportunityInstanceCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport SimpleSchema from 'simpl-schema';\nimport { ReactiveAggregate } from 'meteor/jcbernack:reactive-aggregate';\nimport { Opportunities } from './OpportunityCollection';\nimport { ROLE } from '../role/Role';\nimport { AcademicYearInstances } from '../degree-plan/AcademicYearInstanceCollection';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { Users } from '../user/UserCollection';\nimport { VerificationRequests } from '../verification/VerificationRequestCollection';\nimport BaseCollection from '../base/BaseCollection';\nimport { IOpportunityInstance, IOpportunityInstanceDefine, IOpportunityInstanceUpdate } from '../../typings/radgrad';\nimport { iceSchema } from '../ice/IceProcessor';\n\n/**\n * OpportunityInstances indicate that a student wants to take advantage of an Opportunity in a specific academic term.\n * @extends api/base.BaseCollection\n * @memberOf api/opportunity\n */\nclass OpportunityInstanceCollection extends BaseCollection {\n  public publicationNames: {\n    scoreboard: string;\n    verification: string;\n  };\n\n  /**\n   * Creates the OpportunityInstance collection.\n   */\n  constructor() {\n    super('OpportunityInstance', new SimpleSchema({\n      termID: { type: SimpleSchema.RegEx.Id },\n      opportunityID: { type: SimpleSchema.RegEx.Id },\n      verified: { type: Boolean },\n      studentID: { type: SimpleSchema.RegEx.Id },\n      sponsorID: { type: SimpleSchema.RegEx.Id },\n      ice: { type: iceSchema, optional: true },\n      retired: { type: Boolean, optional: true },\n    }));\n    this.publicationNames = {\n      scoreboard: `${this.collectionName}.Scoreboard`,\n      verification: `${this.collectionName}.Verification`,\n    };\n    if (Meteor.isServer) {\n      this.collection.rawCollection().createIndex({ _id: 1, studentID: 1, termID: 1 });\n    }\n    this.defineSchema = new SimpleSchema({\n      academicTerm: String,\n      opportunity: String,\n      sponsor: String,\n      verified: { type: Boolean, optional: true },\n      student: String,\n      retired: { type: Boolean, optional: true },\n    });\n    this.updateSchema = new SimpleSchema({\n      termID: { type: String, optional: true },\n      verified: { type: Boolean, optional: true },\n      ice: { type: iceSchema, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines a new OpportunityInstance.\n   * @example\n   * OpportunityInstances.define({ academicTerm: 'Fall-2015',\n   *                               opportunity: 'hack2015',\n   *                               verified: false,\n   *                               student: 'joesmith',\n   *                              sponsor: 'johnson' });\n   * @param { Object } description AcademicTerm, opportunity, and student must be slugs or IDs. Verified defaults to false.\n   * Sponsor defaults to the opportunity sponsor.\n   * Note that only one opportunity instance can be defined for a given academicTerm, opportunity, and student.\n   * @throws {Meteor.Error} If academicTerm, opportunity, or student cannot be resolved, or if verified is not a boolean.\n   * @returns The newly created docID.\n   */\n\n  public define({ academicTerm, opportunity, sponsor, verified = false, student, retired = false }: IOpportunityInstanceDefine) {\n    // Validate academicTerm, opportunity, verified, and studentID\n    const termID = AcademicTerms.getID(academicTerm);\n    const academicTermDoc = AcademicTerms.findDoc(termID);\n    const studentID = Users.getID(student);\n    const studentProfile = Users.getProfile(studentID);\n    const opportunityID = Opportunities.getID(opportunity);\n    const op = Opportunities.findDoc(opportunityID);\n    let sponsorID;\n    if (_.isUndefined(sponsor)) {\n      sponsorID = op.sponsorID;\n    } else {\n      sponsorID = Users.getID(sponsor);\n    }\n    if (academicTermDoc.term === AcademicTerms.SPRING || academicTermDoc.term === AcademicTerms.SUMMER || academicTermDoc.term === AcademicTerms.WINTER) {\n      AcademicYearInstances.define({ year: academicTermDoc.year - 1, student: studentProfile.username });\n    } else {\n      AcademicYearInstances.define({ year: academicTermDoc.year, student: studentProfile.username });\n    }\n    if ((typeof verified) !== 'boolean') {\n      throw new Meteor.Error(`${verified} is not a boolean.`);\n    }\n    if (this.isOpportunityInstance(academicTerm, opportunity, student)) {\n      return this.findOpportunityInstanceDoc(academicTerm, opportunity, student)._id;\n    }\n    const ice = Opportunities.findDoc(opportunityID).ice;\n    // Define and return the new OpportunityInstance\n    // console.log(termID, opportunityID, verified, studentID, sponsorID, ice, retired);\n    const opportunityInstanceID = this.collection.insert({\n      termID,\n      opportunityID,\n      verified,\n      studentID,\n      sponsorID,\n      ice,\n      retired,\n    });\n    return opportunityInstanceID;\n  }\n\n  /**\n   * Update the opportunity instance. Only verified and ICE fields can be updated.\n   * @param docID The course instance docID (required).\n   * @param termID the termID for the course instance optional.\n   * @param verified boolean optional.\n   * @param ice an object with fields i, c, e (optional)\n   */\n  public update(docID: string, { termID, verified, ice, retired }: IOpportunityInstanceUpdate) {\n    this.assertDefined(docID);\n    const updateData: IOpportunityInstanceUpdate = {};\n    if (termID) {\n      updateData.termID = termID;\n    }\n    if (_.isBoolean(verified)) {\n      updateData.verified = verified;\n    }\n    if (ice) {\n      updateData.ice = ice;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the opportunity instance.\n   * @param docID The docID of the opportunity instance.\n   */\n  public removeIt(docID: string) {\n    this.assertDefined(docID);\n    // find any VerificationRequests associated with docID and remove them.\n    const requests = VerificationRequests.find({ opportunityInstanceID: docID })\n      .fetch();\n    _.forEach(requests, (vr) => {\n      VerificationRequests.removeIt(vr._id);\n    });\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Removes all OpportunityInstance documents referring to user.\n   * @param user The user, either the ID or the username.\n   * @throws { Meteor.Error } If user is not an ID or username.\n   */\n  public removeUser(user: string) {\n    const studentID = Users.getID(user);\n    this.collection.remove({ studentID });\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\n   * Student.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.STUDENT]);\n  }\n\n  /**\n   * Returns the opportunityInstance document associated with academicTerm, opportunity, and student.\n   * @param academicTerm The academicTerm (slug or ID).\n   * @param opportunity The opportunity (slug or ID).\n   * @param student The student (slug or ID)\n   * @returns { Object } Returns the document or null if not found.\n   * @throws { Meteor.Error } If academicTerm, opportunity, or student does not exist.\n   */\n  public findOpportunityInstanceDoc(academicTerm: string, opportunity: string, student: string) {\n    const termID = AcademicTerms.getID(academicTerm);\n    const studentID = Users.getID(student);\n    const opportunityID = Opportunities.getID(opportunity);\n    return this.collection.findOne({ termID, studentID, opportunityID });\n  }\n\n  /**\n   * Returns true if there exists an OpportunityInstance for the given academicTerm, opportunity, and student.\n   * @param academicTerm The academicTerm (slug or ID).\n   * @param opportunity The opportunity (slug or ID).\n   * @param student The student (slug or ID).\n   * @returns True if the opportunity instance exists.\n   * @throws { Meteor.Error } If academicTerm, opportunity, or student does not exist.\n   */\n  public isOpportunityInstance(academicTerm: string, opportunity: string, student: string) {\n    return !!this.findOpportunityInstanceDoc(academicTerm, opportunity, student);\n  }\n\n  /**\n   * Returns the Opportunity associated with the OpportunityInstance with the given instanceID.\n   * @param instanceID The id of the OpportunityInstance.\n   * @returns {Object} The associated Opportunity.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  public getOpportunityDoc(instanceID: string) {\n    this.assertDefined(instanceID);\n    const instance: IOpportunityInstance = this.collection.findOne({ _id: instanceID });\n    return Opportunities.findDoc(instance.opportunityID);\n  }\n\n  /**\n   * Returns the Opportunity slug for the instance's corresponding Opportunity.\n   * @param instanceID The OpportunityInstance ID.\n   * @return {string} The opportunity slug.\n   */\n  public getOpportunitySlug(instanceID: string) {\n    this.assertDefined(instanceID);\n    const instance: IOpportunityInstance = this.collection.findOne({ _id: instanceID });\n    return Opportunities.findSlugByID(instance.opportunityID);\n  }\n\n  /**\n   * Returns the AcademicTerm associated with the OpportunityInstance with the given instanceID.\n   * @param instanceID The id of the OpportunityInstance.\n   * @returns {Object} The associated AcademicTerm.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  public getAcademicTermDoc(instanceID: string) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return AcademicTerms.findDoc(instance.termID);\n  }\n\n  /**\n   * Returns the Student profile associated with the OpportunityInstance with the given instanceID.\n   * @param instanceID The id of the OpportunityInstance.\n   * @returns {Object} The associated Student profile.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  public getStudentDoc(instanceID: string) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Users.getProfile(instance.studentID);\n  }\n\n  /**\n   * Depending on the logged in user publish only their OpportunityInstances. If\n   * the user is in the Role.ADMIN then publish all OpportunityInstances.\n   */\n  public publish() {\n    if (Meteor.isServer) {\n      const instance = this;\n      Meteor.publish(this.collectionName, function filterStudent(studentID) { // eslint-disable-line meteor/audit-argument-checks\n        if (_.isNil(studentID)) {\n          return this.ready();\n        }\n        const profile = Users.getProfile(studentID);\n        if (profile.role === ROLE.ADMIN || Meteor.isAppTest) {\n          return instance.collection.find();\n        }\n        return instance.collection.find({ studentID, retired: { $not: { $eq: true } } });\n      });\n      Meteor.publish(this.publicationNames.scoreboard, function publishOpportunityScoreboard() {\n        ReactiveAggregate(this, instance.collection, [\n          {\n            $addFields: { opportunityTerm: { $concat: ['$opportunityID', ' ', '$termID'] } },\n          },\n          {\n            $group: {\n              _id: '$opportunityTerm',\n              count: { $sum: 1 },\n            },\n          },\n          { $project: { count: 1, termID: 1, opportunityID: 1 } },\n        ], { clientCollection: 'OpportunityScoreboard' });\n      });\n      // eslint-disable-next-line\n      Meteor.publish(this.publicationNames.verification, function publishVerificationOpportunities(studentIDs: string[]) {\n        if (Meteor.isAppTest) {\n          return instance.collection.find();\n        }\n        return instance.collection.find({ studentID: { $in: studentIDs } });\n      });\n    }\n  }\n\n  /**\n   * Gets the publication names.\n   * @returns {{student: string; perStudentAndAcademicTerm: string; publicStudent: string; publicSlugStudent: string; studentID: string}}\n   */\n  public getPublicationNames() {\n    return this.publicationNames;\n  }\n\n  /**\n   * @returns {String} This opportunity instance, formatted as a string.\n   * @param opportunityInstanceID The opportunity instance ID.\n   * @throws {Meteor.Error} If not a valid ID.\n   */\n  public toString(opportunityInstanceID: string) {\n    this.assertDefined(opportunityInstanceID);\n    const opportunityInstanceDoc = this.findDoc(opportunityInstanceID);\n    const academicTerm = AcademicTerms.toString(opportunityInstanceDoc.termID);\n    const opportunityName = Opportunities.findDoc(opportunityInstanceDoc.opportunityID).name;\n    return `[OI ${academicTerm} ${opportunityName}]`;\n  }\n\n  /**\n   * Updates the OpportunityInstance's AcademicTerm.\n   * @param opportunityInstanceID The opportunity instance ID.\n   * @param termID The academicTerm id.\n   * @throws {Meteor.Error} If not a valid ID.\n   */\n  public updateAcademicTerm(opportunityInstanceID: string, termID: string) {\n    this.assertDefined(opportunityInstanceID);\n    AcademicTerms.assertAcademicTerm(termID);\n    this.collection.update({ _id: opportunityInstanceID }, { $set: { termID } });\n  }\n\n  /**\n   * Updates the verified field.\n   * @param opportunityInstanceID The opportunity instance ID.\n   * @param verified The new value of verified.\n   * @throws {Meteor.Error} If not a valid ID.\n   */\n  public updateVerified(opportunityInstanceID: string, verified: boolean) {\n    this.assertDefined(opportunityInstanceID);\n    this.collection.update({ _id: opportunityInstanceID }, { $set: { verified } });\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks termID, opportunityID, studentID\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (!AcademicTerms.isDefined(doc.termID)) {\n        problems.push(`Bad termID: ${doc.termID}`);\n      }\n      if (!Opportunities.isDefined(doc.opportunityID)) {\n        problems.push(`Bad opportunityID: ${doc.opportunityID}`);\n      }\n      if (!Users.isDefined(doc.studentID)) {\n        problems.push(`Bad studentID: ${doc.studentID}`);\n      }\n      if (!Users.isDefined(doc.sponsorID)) {\n        problems.push(`Bad sponsorID: ${doc.sponsorID}`);\n      }\n      if (doc.verified && VerificationRequests.find({ opportunityInstanceID: doc._id }).fetch().length === 0) {\n        const studentDoc = this.getStudentDoc(doc._id);\n        const opportunityDoc = this.getOpportunityDoc(doc._id);\n        const termDoc = this.getAcademicTermDoc(doc._id);\n        problems.push(`No Verification Request for verified Opportunity Instance: ${opportunityDoc.name}-${studentDoc.username}-${AcademicTerms.toString(termDoc._id, false)}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the OpportunityInstance docID in a format acceptable to define().\n   * @param docID The docID of an OpportunityInstance.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IOpportunityInstanceDefine {\n    const doc = this.findDoc(docID);\n    const academicTerm = AcademicTerms.findSlugByID(doc.termID);\n    const opportunity = Opportunities.findSlugByID(doc.opportunityID);\n    const verified = doc.verified;\n    const student = Users.getProfile(doc.studentID).username;\n    const sponsor = Users.getProfile(doc.sponsorID).username;\n    const retired = doc.retired;\n    return { academicTerm, opportunity, verified, student, sponsor, retired };\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @type {api/opportunity.OpportunityInstanceCollection}\n * @memberOf api/opportunity\n */\nexport const OpportunityInstances = new OpportunityInstanceCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/opportunity/OpportunityInstanceCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 765,
    "kind": "variable",
    "name": "OpportunityInstances",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts",
    "static": true,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstances",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/OpportunityInstanceCollection.ts",
    "importStyle": "{OpportunityInstances}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 418,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/opportunity"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/opportunity.OpportunityInstanceCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 766,
    "kind": "class",
    "name": "OpportunityInstanceCollection",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts",
    "static": true,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/OpportunityInstanceCollection.ts",
    "importStyle": null,
    "description": "OpportunityInstances indicate that a student wants to take advantage of an Opportunity in a specific academic term.",
    "lineNumber": 20,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 767,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#constructor",
    "access": "public",
    "description": "Creates the OpportunityInstance collection.",
    "lineNumber": 23
  },
  {
    "__docId__": 768,
    "kind": "member",
    "name": "publicationNames",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#publicationNames",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "{\"scoreboard\": *, \"verification\": *}"
      ]
    }
  },
  {
    "__docId__": 769,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 770,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 771,
    "kind": "method",
    "name": "define",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#define",
    "access": "public",
    "description": "Defines a new OpportunityInstance.",
    "lineNumber": 77,
    "params": [
      {
        "nullable": null,
        "types": [
          "IOpportunityInstanceDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 772,
    "kind": "method",
    "name": "update",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#update",
    "access": "public",
    "description": "Update the opportunity instance. Only verified and ICE fields can be updated.",
    "lineNumber": 124,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IOpportunityInstanceUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 773,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#removeIt",
    "access": "public",
    "description": "Remove the opportunity instance.",
    "lineNumber": 146,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 774,
    "kind": "method",
    "name": "removeUser",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#removeUser",
    "access": "public",
    "description": "Removes all OpportunityInstance documents referring to user.",
    "lineNumber": 162,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 775,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\nStudent.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 174,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 776,
    "kind": "method",
    "name": "findOpportunityInstanceDoc",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#findOpportunityInstanceDoc",
    "access": "public",
    "description": "Returns the opportunityInstance document associated with academicTerm, opportunity, and student.",
    "lineNumber": 186,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "academicTerm",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opportunity",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "student",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 777,
    "kind": "method",
    "name": "isOpportunityInstance",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#isOpportunityInstance",
    "access": "public",
    "description": "Returns true if there exists an OpportunityInstance for the given academicTerm, opportunity, and student.",
    "lineNumber": 201,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "academicTerm",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opportunity",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "student",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 778,
    "kind": "method",
    "name": "getOpportunityDoc",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#getOpportunityDoc",
    "access": "public",
    "description": "Returns the Opportunity associated with the OpportunityInstance with the given instanceID.",
    "lineNumber": 211,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 779,
    "kind": "method",
    "name": "getOpportunitySlug",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#getOpportunitySlug",
    "access": "public",
    "description": "Returns the Opportunity slug for the instance's corresponding Opportunity.",
    "lineNumber": 222,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 780,
    "kind": "method",
    "name": "getAcademicTermDoc",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#getAcademicTermDoc",
    "access": "public",
    "description": "Returns the AcademicTerm associated with the OpportunityInstance with the given instanceID.",
    "lineNumber": 234,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 781,
    "kind": "method",
    "name": "getStudentDoc",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#getStudentDoc",
    "access": "public",
    "description": "Returns the Student profile associated with the OpportunityInstance with the given instanceID.",
    "lineNumber": 246,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 782,
    "kind": "method",
    "name": "publish",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#publish",
    "access": "public",
    "description": "Depending on the logged in user publish only their OpportunityInstances. If\nthe user is in the Role.ADMIN then publish all OpportunityInstances.",
    "lineNumber": 256,
    "params": [],
    "return": null
  },
  {
    "__docId__": 783,
    "kind": "method",
    "name": "getPublicationNames",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#getPublicationNames",
    "access": "public",
    "description": "Gets the publication names.",
    "lineNumber": 297,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 784,
    "kind": "method",
    "name": "toString",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#toString",
    "access": "public",
    "description": "",
    "lineNumber": 324,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{String} This opportunity instance, formatted as a string."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "opportunityInstanceID",
        "description": "The opportunity instance ID."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": "This opportunity instance, formatted as a string."
    },
    "throws": [
      {
        "types": [
          "Meteor.Error"
        ],
        "description": "If not a valid ID."
      }
    ]
  },
  {
    "__docId__": 785,
    "kind": "method",
    "name": "updateAcademicTerm",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#updateAcademicTerm",
    "access": "public",
    "description": "Updates the OpportunityInstance's AcademicTerm.",
    "lineNumber": 320,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opportunityInstanceID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "termID",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 786,
    "kind": "method",
    "name": "updateVerified",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#updateVerified",
    "access": "public",
    "description": "Updates the verified field.",
    "lineNumber": 332,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opportunityInstanceID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "verified",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 787,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks termID, opportunityID, studentID",
    "lineNumber": 343,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 788,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityInstanceCollection.ts~OpportunityInstanceCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the OpportunityInstance docID in a format acceptable to define().",
    "lineNumber": 373,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IOpportunityInstanceDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 789,
    "kind": "file",
    "name": "api/opportunity/OpportunityTypeCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport 'mocha';\nimport { OpportunityTypes } from './OpportunityTypeCollection';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { IOpportunityType } from '../../typings/radgrad';\nimport { Slugs } from '../slug/SlugCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('OpportunityTypeCollection', function testSuite() {\n    let name = 'InternshipOpportunity';\n    let slug = 'internship-slug';\n    let description = 'Work in a real-world setting for a semester or summer.';\n\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(5000);\n      fc.assert(\n        fc.property(fc.lorem(3), fc.lorem(1), fc.lorem(24), fc.boolean(), (fcName, fcSlug, fcDescription, fcRetired) => {\n          const docID = OpportunityTypes.define({\n            name: fcName,\n            slug: fcSlug,\n            description: fcDescription,\n            retired: fcRetired,\n          });\n          expect(OpportunityTypes.isDefined(docID)).to.be.true;\n          const doc: IOpportunityType = OpportunityTypes.findDoc(docID);\n          expect(doc.name).to.equal(fcName);\n          expect(doc.description).to.equal(fcDescription);\n          expect(Slugs.getNameFromID(doc.slugID)).to.equal(fcSlug);\n          expect(doc.retired).to.equal(fcRetired);\n          OpportunityTypes.removeIt(docID);\n          expect(OpportunityTypes.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicates', function test2() {\n      name = faker.lorem.words();\n      slug = faker.lorem.word();\n      description = faker.lorem.paragraph();\n      const docID = OpportunityTypes.define({\n        name,\n        slug,\n        description,\n      });\n      expect(OpportunityTypes.isDefined(docID)).to.be.true;\n      expect(() => OpportunityTypes.define({\n        name,\n        slug,\n        description,\n      })).to.throw(Error);\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      let doc = OpportunityTypes.findOne({});\n      const docID = doc._id;\n      fc.assert(\n        fc.property(fc.lorem(4), fc.lorem(24), fc.boolean(), (fcName, fcDescription, fcRetired) => {\n          OpportunityTypes.update(docID, {\n            name: fcName,\n            description: fcDescription,\n            retired: fcRetired,\n          });\n          doc = OpportunityTypes.findDoc(docID);\n          expect(doc.name).to.equal(fcName);\n          expect(doc.description).to.equal(fcDescription);\n          expect(doc.retired).to.equal(fcRetired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      const doc = OpportunityTypes.findOne({});\n      let docID = doc._id;\n      const dumpObject = OpportunityTypes.dumpOne(docID);\n      OpportunityTypes.removeIt(docID);\n      expect(OpportunityTypes.isDefined(docID)).to.be.false;\n      docID = OpportunityTypes.restoreOne(dumpObject);\n      const restored = OpportunityTypes.findDoc(docID);\n      expect(doc.name).to.equal(restored.name);\n      expect(doc.description).to.equal(restored.description);\n      expect(doc.retired).to.equal(restored.retired);\n      expect(Slugs.getNameFromID(restored.slugID)).to.equal(dumpObject.slug);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const problems = OpportunityTypes.checkIntegrity();\n      expect(problems.length).to.equal(0);\n    });\n\n    it('Can findDocBySlug', function test() {\n      name = faker.lorem.words();\n      slug = faker.lorem.word();\n      description = faker.lorem.paragraph();\n      OpportunityTypes.define({ name, slug, description });\n      const doc = OpportunityTypes.findDocBySlug(slug);\n      expect(doc).to.be.an('object');\n      OpportunityTypes.removeIt(slug);\n      expect(function foo() {\n        OpportunityTypes.findDocBySlug('notASlug');\n      }).to.throw(Error);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/opportunity/OpportunityTypeCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 790,
    "kind": "file",
    "name": "api/opportunity/OpportunityTypeCollection.ts",
    "content": "import _ from 'lodash';\nimport BaseTypeCollection from '../base/BaseTypeCollection';\nimport { ITypeDefine, ITypeUpdate } from '../../typings/radgrad';\n\n/**\n * OpportunityTypes help organize Opportunities into logically related groupings such as \"Internships\", \"Clubs\", etc.\n * @extends api/base.BaseTypeCollection\n * @memberOf api/opportunity\n */\nclass OpportunityTypeCollection extends BaseTypeCollection {\n\n  /**\n   * Creates the OpportunityType collection.\n   */\n  constructor() {\n    super('OpportunityType');\n  }\n\n  /**\n   * Defines a new OpportunityType with its name, slug, and description.\n   * @example\n   * OpportunityTypes.define({ name: 'Research', slug: 'research', description: 'A research project.' });\n   * @param { Object } description Object with keys name, slug, and description.\n   * Slug must be globally unique and previously undefined.\n   * @throws { Meteor.Error } If the slug already exists.\n   * @returns The newly created docID.\n   */\n  public define({ name, slug, description, retired = false }: ITypeDefine) {\n    return super.define({ name, slug, description, retired });\n  }\n\n  /**\n   * Update an OpportunityType.\n   * @param docID the docID to be updated.\n   * @param name the new name (optional).\n   * @param description the new description (optional).\n   * @throws { Meteor.Error } If docID is not defined.\n   */\n  public update(docID, { name, description, retired }: ITypeUpdate) {\n    this.assertDefined(docID);\n    const updateData: ITypeUpdate = {};\n    if (!_.isNil(name)) {\n      updateData.name = name;\n    }\n    if (!_.isNil(description)) {\n      updateData.description = description;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @type {api/opportunity.OpportunityTypeCollection}\n * @memberOf api/opportunity\n */\nexport const OpportunityTypes = new OpportunityTypeCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/opportunity/OpportunityTypeCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 791,
    "kind": "variable",
    "name": "OpportunityTypes",
    "memberof": "api/opportunity/OpportunityTypeCollection.ts",
    "static": true,
    "longname": "api/opportunity/OpportunityTypeCollection.ts~OpportunityTypes",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/OpportunityTypeCollection.ts",
    "importStyle": "{OpportunityTypes}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 57,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/opportunity"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/opportunity.OpportunityTypeCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 792,
    "kind": "class",
    "name": "OpportunityTypeCollection",
    "memberof": "api/opportunity/OpportunityTypeCollection.ts",
    "static": true,
    "longname": "api/opportunity/OpportunityTypeCollection.ts~OpportunityTypeCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/OpportunityTypeCollection.ts",
    "importStyle": null,
    "description": "OpportunityTypes help organize Opportunities into logically related groupings such as \"Internships\", \"Clubs\", etc.",
    "lineNumber": 10,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseTypeCollection.js~BaseTypeCollection"
    ]
  },
  {
    "__docId__": 793,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/opportunity/OpportunityTypeCollection.ts~OpportunityTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityTypeCollection.ts~OpportunityTypeCollection#constructor",
    "access": "public",
    "description": "Creates the OpportunityType collection.",
    "lineNumber": 13
  },
  {
    "__docId__": 794,
    "kind": "method",
    "name": "define",
    "memberof": "api/opportunity/OpportunityTypeCollection.ts~OpportunityTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityTypeCollection.ts~OpportunityTypeCollection#define",
    "access": "public",
    "description": "Defines a new OpportunityType with its name, slug, and description.",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "ITypeDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 795,
    "kind": "method",
    "name": "update",
    "memberof": "api/opportunity/OpportunityTypeCollection.ts~OpportunityTypeCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/opportunity/OpportunityTypeCollection.ts~OpportunityTypeCollection#update",
    "access": "public",
    "description": "Update an OpportunityType.",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ITypeUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 796,
    "kind": "file",
    "name": "api/opportunity/OpportunityUtilities.ts",
    "content": "import _ from 'lodash';\nimport { Opportunities } from './OpportunityCollection';\nimport { OpportunityInstances } from './OpportunityInstanceCollection';\nimport PreferredChoice from '../degree-plan/PreferredChoice';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { Users } from '../user/UserCollection';\nimport { VerificationRequests } from '../verification/VerificationRequestCollection';\nimport { getStudentsCurrentAcademicTermNumber } from '../degree-plan/AcademicYearUtilities';\nimport { profileGetInterestIDs } from '../../ui/components/shared/data-model-helper-functions';\n\n/**\n * Returns a random int between min and max.\n * @param min the minimum value for the random number.\n * @param max the maximum value for the random number.\n * @return {*}\n * @memberOf api/opportunity\n */\nexport function getRandomInt(min, max) {\n  min = Math.ceil(min); // eslint-disable-line no-param-reassign\n  max = Math.floor(max); // eslint-disable-line no-param-reassign\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n\n/**\n * Removes the planned Opportunities for the given studentID.\n * @param studentID\n * @memberOf api/opportunity\n */\nexport function clearPlannedOpportunityInstances(studentID: string) {\n  const courses = OpportunityInstances.find({ studentID, verified: false }).fetch();\n  _.forEach(courses, (oi) => {\n    const requests = VerificationRequests.find({ studentID, opportunityInstanceID: oi._id }).fetch();\n    if (requests.length === 0) {\n      OpportunityInstances.removeIt(oi);\n    }\n  });\n}\n\nexport function calculateOpportunityCompatibility(opportunityID: string, studentID: string) {\n  const course = Opportunities.findDoc(opportunityID);\n  const profile = Users.getProfile(studentID);\n  const studentInterests = profileGetInterestIDs(profile);\n  const intersection = _.intersection(course.interestIDs, studentInterests);\n  return intersection.length;\n}\n\nexport function academicTermOpportunities(academicTerm, academicTermNumber) {\n  const id = academicTerm._id;\n  const opps = Opportunities.find().fetch();\n  const academicTermOpps = _.filter(opps, (opportunity) => _.indexOf(opportunity.termIDs, id) !== -1);\n  if (academicTermNumber < 3) { // AY 1.\n    return _.filter(academicTermOpps, (opportunity) => {\n      const type = Opportunities.getOpportunityTypeDoc(opportunity._id);\n      return type.name === 'Club';\n    });\n  }\n  if (academicTermNumber < 6) {\n    return _.filter(academicTermOpps, (opportunity) => {\n      const type = Opportunities.getOpportunityTypeDoc(opportunity._id);\n      return type.name === 'Event' || type.name === 'Club';\n    });\n  }\n  return academicTermOpps;\n}\n\nexport function getStudentAcademicTermOpportunityChoices(academicTerm: string, academicTermNumber: number, studentID: string) {\n  const opportunities = academicTermOpportunities(academicTerm, academicTermNumber);\n  const oppInstances = OpportunityInstances.find({ studentID }).fetch();\n  const filtered = _.filter(opportunities, (opp) => {\n    let taken = true;\n    _.forEach(oppInstances, (oi) => {\n      if (oi.opportunityID === opp._id) {\n        taken = false;\n      }\n    });\n    return taken;\n  });\n  return filtered;\n}\n\nexport function chooseStudentAcademicTermOpportunity(academicTerm: string, academicTermNumber: number, studentID: string) {\n  const choices = getStudentAcademicTermOpportunityChoices(academicTerm, academicTermNumber, studentID);\n  const profile = Users.getProfile(studentID);\n  const interestIDs = profileGetInterestIDs(profile);\n  const preferred = new PreferredChoice(choices, interestIDs);\n  const best = preferred.getBestChoices();\n  if (best) {\n    return best[getRandomInt(0, best.length)];\n  }\n  return null;\n}\n\nexport function getStudentCurrentAcademicTermOpportunityChoices(studentID: string) {\n  const currentAcademicTerm = AcademicTerms.getCurrentAcademicTermDoc();\n  const academicTermNum = getStudentsCurrentAcademicTermNumber(studentID);\n  return getStudentAcademicTermOpportunityChoices(currentAcademicTerm, academicTermNum, studentID);\n}\n\nexport function getRecommendedCurrentAcademicTermOpportunityChoices(studentID) {\n  const choices = getStudentCurrentAcademicTermOpportunityChoices(studentID);\n  const profile = Users.getProfile(studentID);\n  const interestIDs = profileGetInterestIDs(profile);\n  const preferred = new PreferredChoice(choices, interestIDs);\n  const best = preferred.getBestChoices();\n  return best;\n}\n\nexport function chooseCurrentAcademicTermOpportunity(studentID: string) {\n  const best = getRecommendedCurrentAcademicTermOpportunityChoices(studentID);\n  if (best) {\n    return best[getRandomInt(0, best.length)];\n  }\n  return null;\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/opportunity/OpportunityUtilities.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 797,
    "kind": "function",
    "name": "getRandomInt",
    "memberof": "api/opportunity/OpportunityUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/opportunity/OpportunityUtilities.ts~getRandomInt",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/OpportunityUtilities.ts",
    "importStyle": "{getRandomInt}",
    "description": "Returns a random int between min and max.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "min",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "max",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 798,
    "kind": "function",
    "name": "clearPlannedOpportunityInstances",
    "memberof": "api/opportunity/OpportunityUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/opportunity/OpportunityUtilities.ts~clearPlannedOpportunityInstances",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/OpportunityUtilities.ts",
    "importStyle": "{clearPlannedOpportunityInstances}",
    "description": "Removes the planned Opportunities for the given studentID.",
    "lineNumber": 29,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 799,
    "kind": "function",
    "name": "calculateOpportunityCompatibility",
    "memberof": "api/opportunity/OpportunityUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/opportunity/OpportunityUtilities.ts~calculateOpportunityCompatibility",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/OpportunityUtilities.ts",
    "importStyle": "{calculateOpportunityCompatibility}",
    "description": "",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opportunityID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 800,
    "kind": "function",
    "name": "academicTermOpportunities",
    "memberof": "api/opportunity/OpportunityUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/opportunity/OpportunityUtilities.ts~academicTermOpportunities",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/OpportunityUtilities.ts",
    "importStyle": "{academicTermOpportunities}",
    "description": "",
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "academicTerm",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "academicTermNumber",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 801,
    "kind": "function",
    "name": "getStudentAcademicTermOpportunityChoices",
    "memberof": "api/opportunity/OpportunityUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/opportunity/OpportunityUtilities.ts~getStudentAcademicTermOpportunityChoices",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/OpportunityUtilities.ts",
    "importStyle": "{getStudentAcademicTermOpportunityChoices}",
    "description": "",
    "lineNumber": 66,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "academicTerm",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "academicTermNumber",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 802,
    "kind": "function",
    "name": "chooseStudentAcademicTermOpportunity",
    "memberof": "api/opportunity/OpportunityUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/opportunity/OpportunityUtilities.ts~chooseStudentAcademicTermOpportunity",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/OpportunityUtilities.ts",
    "importStyle": "{chooseStudentAcademicTermOpportunity}",
    "description": "",
    "lineNumber": 81,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "academicTerm",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "academicTermNumber",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 803,
    "kind": "function",
    "name": "getStudentCurrentAcademicTermOpportunityChoices",
    "memberof": "api/opportunity/OpportunityUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/opportunity/OpportunityUtilities.ts~getStudentCurrentAcademicTermOpportunityChoices",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/OpportunityUtilities.ts",
    "importStyle": "{getStudentCurrentAcademicTermOpportunityChoices}",
    "description": "",
    "lineNumber": 93,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 804,
    "kind": "function",
    "name": "getRecommendedCurrentAcademicTermOpportunityChoices",
    "memberof": "api/opportunity/OpportunityUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/opportunity/OpportunityUtilities.ts~getRecommendedCurrentAcademicTermOpportunityChoices",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/OpportunityUtilities.ts",
    "importStyle": "{getRecommendedCurrentAcademicTermOpportunityChoices}",
    "description": "",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 805,
    "kind": "function",
    "name": "chooseCurrentAcademicTermOpportunity",
    "memberof": "api/opportunity/OpportunityUtilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/opportunity/OpportunityUtilities.ts~chooseCurrentAcademicTermOpportunity",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/OpportunityUtilities.ts",
    "importStyle": "{chooseCurrentAcademicTermOpportunity}",
    "description": "",
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "studentID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 806,
    "kind": "file",
    "name": "api/opportunity/SampleOpportunities.ts",
    "content": "import faker from 'faker';\nimport moment from 'moment';\nimport { OpportunityTypes } from './OpportunityTypeCollection';\nimport { Opportunities } from './OpportunityCollection';\nimport { OpportunityInstances } from './OpportunityInstanceCollection';\nimport { makeSampleInterestArray } from '../interest/SampleInterests';\nimport slugify, { Slugs } from '../slug/SlugCollection';\nimport { makeSampleAcademicTermArray } from '../academic-term/SampleAcademicTerms';\nimport { makeSampleIce } from '../ice/SampleIce';\n\n/**\n * Creates an OpportunityType with a unique slug and returns its docID.\n * @returns { String } The docID of the newly generated OpportunityType.\n * @memberOf api/opportunity\n */\nexport function makeSampleOpportunityType() {\n  const name = faker.lorem.words();\n  const slug = slugify(`opportunity-type-${name}-${moment().format('YYYY-MM-DD-HH-mm-ss-SSSSS')}`);\n  const description = faker.lorem.paragraph();\n  return OpportunityTypes.define({ name, slug, description });\n}\n\n/**\n * Creates an Opportunity with a unique slug and returns its docID.\n * @param sponsor The slug for the user (with Role.FACULTY) to be the sponsor for this opportunity.\n * Also creates a new OpportunityType.\n * @returns { String } The docID for the newly generated Opportunity.\n * @memberOf api/opportunity\n */\nexport function makeSampleOpportunity(sponsor) {\n  const name = faker.lorem.words();\n  const slug = slugify(`opportunity-${name}-${moment().format('YYYY-MM-DD-HH-mm-ss-SSSSS')}`);\n  const description = faker.lorem.paragraph();\n  const opportunityType = makeSampleOpportunityType();\n  const interests = makeSampleInterestArray(2);\n  const academicTerms = makeSampleAcademicTermArray();\n  const ice = makeSampleIce();\n  return Opportunities.define({ name, slug, description, opportunityType, sponsor, interests, academicTerms, ice });\n}\n\n/**\n * Creates an array of defined opportunity slugs.\n * @param sponsor the sponsor of the opportunity.\n * @param num the number of opportunities to define. Defaults to 1.\n * @return An array of defined opportunity slugs.\n */\nexport function makeSampleOpportunitySlugArray(sponsor, num = 1) {\n  const retVal = [];\n  for (let i = 0; i < num; i++) {\n    retVal.push(Slugs.getNameFromID(Opportunities.findDoc(makeSampleOpportunity(sponsor)).slugID));\n  }\n  return retVal;\n}\n\n/**\n * Creates an OpportunityInstance with a unique slug and returns its docID.\n * @param student The slug for the user (with ROLE.STUDENT) who is taking advantage of this opportunity.\n * @param sponsor The slug for the user (with ROLE.FACULTY) who is sponsoring the opportunity.\n * Implicitly creates an Opportunity and an OpportunityType.\n * @memberOf api/opportunity\n */\nexport function makeSampleOpportunityInstance(student: string, sponsor: string) {\n  const opportunity: string = makeSampleOpportunity(sponsor);\n  const academicTerm = Opportunities.findDoc(opportunity).termIDs[0];\n  const verified: boolean = false;\n  return OpportunityInstances.define({ academicTerm, opportunity, sponsor, verified, student });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/opportunity/SampleOpportunities.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 807,
    "kind": "function",
    "name": "makeSampleOpportunityType",
    "memberof": "api/opportunity/SampleOpportunities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/opportunity/SampleOpportunities.ts~makeSampleOpportunityType",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/SampleOpportunities.ts",
    "importStyle": "{makeSampleOpportunityType}",
    "description": "Creates an OpportunityType with a unique slug and returns its docID.",
    "lineNumber": 16,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 808,
    "kind": "function",
    "name": "makeSampleOpportunity",
    "memberof": "api/opportunity/SampleOpportunities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/opportunity/SampleOpportunities.ts~makeSampleOpportunity",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/SampleOpportunities.ts",
    "importStyle": "{makeSampleOpportunity}",
    "description": "Creates an Opportunity with a unique slug and returns its docID.",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "sponsor",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 809,
    "kind": "function",
    "name": "makeSampleOpportunitySlugArray",
    "memberof": "api/opportunity/SampleOpportunities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/opportunity/SampleOpportunities.ts~makeSampleOpportunitySlugArray",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/SampleOpportunities.ts",
    "importStyle": "{makeSampleOpportunitySlugArray}",
    "description": "Creates an array of defined opportunity slugs.",
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "sponsor",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "num",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 810,
    "kind": "function",
    "name": "makeSampleOpportunityInstance",
    "memberof": "api/opportunity/SampleOpportunities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/opportunity/SampleOpportunities.ts~makeSampleOpportunityInstance",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/opportunity/SampleOpportunities.ts",
    "importStyle": "{makeSampleOpportunityInstance}",
    "description": "Creates an OpportunityInstance with a unique slug and returns its docID.",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "student",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "sponsor",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 811,
    "kind": "file",
    "name": "api/opportunity/index.ts",
    "content": "/** @namespace api/opportunity */\nimport './OpportunityCollection';\nimport './OpportunityInstanceCollection';\nimport './OpportunityTypeCollection';\nimport './OpportunityUtilities';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/opportunity/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 812,
    "kind": "file",
    "name": "api/page-tracking/PageInterestCollection.methods.app-test.ts",
    "content": "// import { Meteor } from 'meteor/meteor';\n// import { defineTestFixturesMethod, withLoggedInUser, withRadGradSubscriptions } from '../test/test-utilities';\n//\n// /* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n// /* eslint-env mocha */\n//\n// if (Meteor.isClient) {\n//   describe('PageInterestCollection Meteor Methods ', function test() {\n//     before(function (done) {\n//       defineTestFixturesMethod.call(['minimal', 'abi.student'], done);\n//     });\n//\n//     it('Define Method', async function () {\n//       await withLoggedInUser();\n//       await withRadGradSubscriptions();\n//     });\n//\n//     it('Remove Method', async function () {\n//\n//     });\n//   });\n// }\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/page-tracking/PageInterestCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 813,
    "kind": "file",
    "name": "api/page-tracking/PageInterestCollection.methods.ts",
    "content": "import { ValidatedMethod } from 'meteor/mdg:validated-method';\nimport { CallPromiseMixin } from 'meteor/didericis:callpromise-mixin';\nimport { PageInterests } from './PageInterestCollection';\nimport { IPageInterest } from '../../typings/radgrad';\n\n/**\n * The validated method for defining PageInterests.\n * @memberOf api/page-tracking\n */\nexport const pageInterestDefineMethod = new ValidatedMethod({\n  name: 'PageInterest.define',\n  validate: null,\n  mixins: [CallPromiseMixin],\n  run(definitionData: IPageInterest) {\n    PageInterests.assertValidRoleForMethod(this.userId);\n    return PageInterests.define(definitionData);\n  },\n});\n\n/**\n * The validated method for removing PageInterests\n * @memberOf api/analytic\n */\nexport const pageInterestRemoveUserMethod = new ValidatedMethod({\n  name: 'PageInterest.removeUser',\n  validate: null,\n  mixins: [CallPromiseMixin],\n  run(username) {\n    PageInterests.assertAdminRoleForMethod(this.userId);\n    return PageInterests.removeUser(username);\n  },\n});\n\n/**\n * The validated method for finding PageInterests.\n * @memberOf api/page-tracking\n */\nexport const pageInterestAdminFindMethod = new ValidatedMethod({\n  name: 'PageInterest.find',\n  validate: null,\n  mixins: [CallPromiseMixin],\n  run({ selector, options }) {\n    PageInterests.assertAdminRoleForMethod(this.userId);\n    const results = PageInterests.find(selector, options);\n    return results.fetch();\n  },\n});\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/page-tracking/PageInterestCollection.methods.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 814,
    "kind": "variable",
    "name": "pageInterestDefineMethod",
    "memberof": "api/page-tracking/PageInterestCollection.methods.ts",
    "static": true,
    "longname": "api/page-tracking/PageInterestCollection.methods.ts~pageInterestDefineMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/page-tracking/PageInterestCollection.methods.ts",
    "importStyle": "{pageInterestDefineMethod}",
    "description": "The validated method for defining PageInterests.",
    "lineNumber": 8,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/page-tracking"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 815,
    "kind": "variable",
    "name": "pageInterestRemoveUserMethod",
    "memberof": "api/page-tracking/PageInterestCollection.methods.ts",
    "static": true,
    "longname": "api/page-tracking/PageInterestCollection.methods.ts~pageInterestRemoveUserMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/page-tracking/PageInterestCollection.methods.ts",
    "importStyle": "{pageInterestRemoveUserMethod}",
    "description": "The validated method for removing PageInterests",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/analytic"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 816,
    "kind": "variable",
    "name": "pageInterestAdminFindMethod",
    "memberof": "api/page-tracking/PageInterestCollection.methods.ts",
    "static": true,
    "longname": "api/page-tracking/PageInterestCollection.methods.ts~pageInterestAdminFindMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/page-tracking/PageInterestCollection.methods.ts",
    "importStyle": "{pageInterestAdminFindMethod}",
    "description": "The validated method for finding PageInterests.",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/page-tracking"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 817,
    "kind": "file",
    "name": "api/page-tracking/PageInterestCollection.test.ts",
    "content": "import { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport 'mocha';\nimport { PageInterests } from './PageInterestCollection';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { Users } from '../user/UserCollection';\nimport {\n  IPageInterest,\n  IPageInterestDefine,\n} from '../../typings/radgrad';\nimport { makeSamplePageInterest } from './SamplePageInterests';\n\n/* eslint @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('PageInterestCollection', function testSuite() {\n    let username;\n\n    before(function setup() {\n      removeAllEntities();\n      const userID = makeSampleUser();\n      username = Users.getProfile(userID).username;\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(5000);\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(1), (fcCategory, fcName) => {\n          const docID = PageInterests.define({ username, category: fcCategory, name: fcName });\n\n          expect(PageInterests.isDefined(docID)).to.be.true;\n          PageInterests.removeIt(docID);\n          expect(PageInterests.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicates', function test2() {\n      const category = faker.lorem.word();\n      const name = faker.lorem.slug();\n      const docID1 = PageInterests.define({ username, category, name });\n      const docID1Object: IPageInterest = PageInterests.findOne({ _id: docID1 });\n      const docID1Timestamp: Date = docID1Object.timestamp;\n      const docID2 = PageInterests.define({ username, category, name, timestamp: docID1Timestamp });\n\n      expect(docID1).to.equal(docID2);\n      expect(PageInterests.isDefined(docID1)).to.be.true;\n      PageInterests.removeIt(docID2);\n      expect(PageInterests.isDefined(docID1)).to.be.false;\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test3() {\n      let docID = makeSamplePageInterest();\n      const original: IPageInterest = PageInterests.findDoc(docID);\n      const dumpObject: IPageInterestDefine = PageInterests.dumpOne(docID);\n      PageInterests.removeIt(docID);\n      expect(PageInterests.isDefined(docID)).to.be.false;\n      docID = PageInterests.restoreOne(dumpObject);\n      expect(PageInterests.isDefined(docID)).to.be.true;\n      const restored: IPageInterest = PageInterests.findDoc(docID);\n\n      expect(original.username).to.deep.equal(restored.username);\n      expect(original.category).to.deep.equal(restored.category);\n      expect(original.name).to.deep.equal(restored.name);\n      expect(original.timestamp).to.deep.equal(restored.timestamp);\n      expect(original.retired).to.deep.equal(restored.retired);\n\n    });\n\n    it('Can checkIntegrity no errors', function test4() {\n      const problems = PageInterests.checkIntegrity();\n\n      // When we call makeSamplePageInterest, we don't create the random slugs (category and name) that it generates\n      expect(problems.length).to.equal(2);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/page-tracking/PageInterestCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 818,
    "kind": "file",
    "name": "api/page-tracking/PageInterestCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport moment from 'moment';\nimport _ from 'lodash';\nimport SimpleSchema from 'simpl-schema';\nimport BaseCollection from '../base/BaseCollection';\nimport { ROLE } from '../role/Role';\nimport { IPageInterest, IPageInterestDefine } from '../../typings/radgrad';\nimport { Users } from '../user/UserCollection';\nimport { PageInterestsCategoryTypes } from './PageInterestsCategoryTypes';\nimport { Slugs } from '../slug/SlugCollection';\n\n/**\n * Represents a student's interest view for a specific topic category page\n * The different topic categories that a page could be are Career Goal, Course, Interest, and Opportunity\n * Definition of a student's interest view when they visit a page\n * 1. When they Favorite that page and don't unfavorite it before leaving the page\n * 2. They play the Teaser video at that page or open it as an external link\n * 3. They click an external link in the DESCRIPTION of that page\n *    - Profile Pictures and the interests tags do not count\n * 4. They spend a minimum of 5 seconds viewing that page\n *    - They have to be \"focused\" on that page in the browser sense\n * @extends api/base.BaseCollection\n * @memberOf api/analytic\n */\nclass PageInterestCollection extends BaseCollection {\n\n  /**\n   * Creates the PageInterestCollection\n   */\n  constructor() {\n    super('PageInterest', new SimpleSchema({\n      username: String,\n      category: String,\n      name: String,\n      timestamp: Date,\n      retired: { type: Boolean, optional: true },\n    }));\n    if (Meteor.isServer) {\n      this.collection.rawCollection().createIndex({ timestamp: -1 });\n    }\n  }\n\n  /**\n   * Defines a snapshot of a page's student interest views\n   * @param termID The ID of the academic term that this snapshot represents\n   * @param category The topic category that this snapshot represents\n   * @param name The name that the page represents\n   * @param timestamp Timestamp of when this snapshot was recorded\n   * @param retired boolean optional defaults to false.\n   */\n  public define({ username, category, name, timestamp = moment().toDate(), retired = false }: IPageInterestDefine): string {\n    // Duplicates are not allowed\n    // 1) Documents with the same values for all its fields\n    let doc: IPageInterest;\n    doc = this.collection.findOne({ username, category, name, timestamp, retired });\n    if (doc) {\n      return doc._id;\n    }\n    // 2) Documents with the same values for all its fields except timestamp\n    // PageInterests only publishes PageInterests within the past 24 hours for the purpose of not defining more than 1\n    // PageInterest for an item within that 24 hour period.\n    doc = this.collection.findOne({ username, category, name, retired });\n    if (doc) {\n      return doc._id;\n    }\n    return this.collection.insert({ username, category, name, timestamp, retired });\n  }\n\n  /**\n   * Removes all page interest documents from referenced user.\n   * @param username The username of user to be removed.\n   * @throws { Meteor.Error } If user is not an ID or username.\n   */\n  public removeUser(username: string) {\n    this.collection.remove({ username });\n  }\n\n  /**\n   * Asserts that the userID belongs to an admin role when running the find and removeUser method within this class.\n   * @param userId The userId of the logged in user.\n   */\n  public assertAdminRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN]);\n  }\n\n  /**\n   * Asserts that the userID belongs to a valid role when running the define method within this class.\n   * @param userId The userId of the logged in user.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.STUDENT]);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks username, category, and name\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity(): string[] {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (!Users.isDefined(doc.username)) {\n        problems.push(`Bad user: ${doc.username}`);\n      }\n      const categories = Object.values(PageInterestsCategoryTypes);\n      if (categories.indexOf(doc.category) < 0) {\n        problems.push(`Bad category: ${doc.category}`);\n      }\n      if (!Slugs.isDefined(doc.name)) {\n        problems.push(`Bad slug: ${doc.name}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the PageInterest docID in a format acceptable to define().\n   * @param docID The docID of a PageInterest\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IPageInterestDefine {\n    const doc: IPageInterest = this.findDoc(docID);\n    const username = doc.username;\n    const category = doc.category;\n    const name = doc.name;\n    const timestamp = doc.timestamp;\n    const retired = doc.retired;\n    return { username, category, name, timestamp, retired };\n  }\n\n  /**\n   * Publish an empty cursor to PageInterests. Since method calls are used to find interactions,\n   * we do not need to publish any records, but would still like this to be on the list of collections\n   * for integrity check, etc.\n   */\n  public publish() {\n    if (Meteor.isServer) {\n      // Meteor.publish(this.collectionName, () => this.collection.find({}, { limit: 0 }));\n      const instance = this;\n      // eslint-disable-next-line meteor/audit-argument-checks\n      Meteor.publish(this.collectionName, function filterStudentID(studentID) {\n        if (_.isNil(studentID)) {\n          return this.ready();\n        }\n        const profile = Users.getProfile(studentID);\n        if (_.includes([ROLE.STUDENT], profile.role)) {\n          const username = profile.username;\n\n          // Only expose PageInterests for the past 24 hours\n          const yesterday = moment().subtract(24, 'hours').toDate();\n          return instance.collection.find({ username, timestamp: { $gte: yesterday } });\n        }\n        // Don't publish any documents\n        return instance.collection.find({}, { skip: instance.collection.find({}).count() });\n      });\n    }\n  }\n}\n\nexport const PageInterests = new PageInterestCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/page-tracking/PageInterestCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 819,
    "kind": "variable",
    "name": "PageInterests",
    "memberof": "api/page-tracking/PageInterestCollection.ts",
    "static": true,
    "longname": "api/page-tracking/PageInterestCollection.ts~PageInterests",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/page-tracking/PageInterestCollection.ts",
    "importStyle": "{PageInterests}",
    "description": null,
    "lineNumber": 173,
    "undocument": true,
    "type": {
      "types": [
        "api/page-tracking/PageInterestCollection.ts~PageInterestCollection"
      ]
    }
  },
  {
    "__docId__": 820,
    "kind": "class",
    "name": "PageInterestCollection",
    "memberof": "api/page-tracking/PageInterestCollection.ts",
    "static": true,
    "longname": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/page-tracking/PageInterestCollection.ts",
    "importStyle": null,
    "description": "Represents a student's interest view for a specific topic category page\nThe different topic categories that a page could be are Career Goal, Course, Interest, and Opportunity\nDefinition of a student's interest view when they visit a page\n1. When they Favorite that page and don't unfavorite it before leaving the page\n2. They play the Teaser video at that page or open it as an external link\n3. They click an external link in the DESCRIPTION of that page\n- Profile Pictures and the interests tags do not count\n4. They spend a minimum of 5 seconds viewing that page\n- They have to be \"focused\" on that page in the browser sense",
    "lineNumber": 25,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 821,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection#constructor",
    "access": "public",
    "description": "Creates the PageInterestCollection",
    "lineNumber": 28
  },
  {
    "__docId__": 822,
    "kind": "method",
    "name": "define",
    "memberof": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection#define",
    "access": "public",
    "description": "Defines a snapshot of a page's student interest views",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "IPageInterestDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 823,
    "kind": "method",
    "name": "removeUser",
    "memberof": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection#removeUser",
    "access": "public",
    "description": "Removes all page interest documents from referenced user.",
    "lineNumber": 74,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 824,
    "kind": "method",
    "name": "assertAdminRoleForMethod",
    "memberof": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection#assertAdminRoleForMethod",
    "access": "public",
    "description": "Asserts that the userID belongs to an admin role when running the find and removeUser method within this class.",
    "lineNumber": 82,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 825,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Asserts that the userID belongs to a valid role when running the define method within this class.",
    "lineNumber": 90,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 826,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks username, category, and name",
    "lineNumber": 100,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 827,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the PageInterest docID in a format acceptable to define().",
    "lineNumber": 122,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IPageInterestDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 828,
    "kind": "method",
    "name": "publish",
    "memberof": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/page-tracking/PageInterestCollection.ts~PageInterestCollection#publish",
    "access": "public",
    "description": "Publish an empty cursor to PageInterests. Since method calls are used to find interactions,\nwe do not need to publish any records, but would still like this to be on the list of collections\nfor integrity check, etc.",
    "lineNumber": 137,
    "params": [],
    "return": null
  },
  {
    "__docId__": 829,
    "kind": "file",
    "name": "api/page-tracking/PageInterestsCategoryTypes.ts",
    "content": "export enum PageInterestsCategoryTypes {\n  CAREERGOAL = 'career-goal',\n  COURSE = 'course',\n  INTEREST = 'interest',\n  OPPORTUNITY = 'opportunity',\n}\n\nexport type IPageInterestsCategoryTypes = PageInterestsCategoryTypes.CAREERGOAL | PageInterestsCategoryTypes.COURSE | PageInterestsCategoryTypes.INTEREST | PageInterestsCategoryTypes.OPPORTUNITY;\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/page-tracking/PageInterestsCategoryTypes.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 830,
    "kind": "file",
    "name": "api/page-tracking/PageInterestsDailySnapshotCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport moment from 'moment';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { PageInterestsDailySnapshots } from './PageInterestsDailySnapshotCollection';\nimport {\n  makeSamplePageInterestInfoArray,\n  makeSamplePageInterestsDailySnapshot,\n} from './SamplePageInterestsDailySnapshots';\nimport {\n  IPageInterestInfo,\n  IPageInterestsDailySnapshot,\n  IPageInterestsDailySnapshotDefine,\n} from '../../typings/radgrad';\n\n/* eslint @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('PageInterestsDailySnapshotCollection', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(5000);\n      fc.assert(\n        fc.property(fc.nat(100), fc.nat(100), fc.nat(100), fc.nat(100), (careerGoalsNum, coursesNum, interestsNum, opportunitiesNum) => {\n          const careerGoals: IPageInterestInfo[] = makeSamplePageInterestInfoArray(careerGoalsNum);\n          const courses: IPageInterestInfo[] = makeSamplePageInterestInfoArray(coursesNum);\n          const interests: IPageInterestInfo[] = makeSamplePageInterestInfoArray(interestsNum);\n          const opportunities: IPageInterestInfo[] = makeSamplePageInterestInfoArray(opportunitiesNum);\n          const docID = PageInterestsDailySnapshots.define({ careerGoals, courses, interests, opportunities });\n          const docObject: IPageInterestsDailySnapshot = PageInterestsDailySnapshots.findOne({ _id: docID });\n\n          expect(docObject.timestamp).to.be.below(new Date());\n          expect(PageInterestsDailySnapshots.isDefined(docID)).to.be.true;\n          PageInterestsDailySnapshots.removeIt(docID);\n          expect(PageInterestsDailySnapshots.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicate snapshots with the same value for all its fields', function test2() {\n      const numItems = 5;\n      const careerGoals: IPageInterestInfo[] = makeSamplePageInterestInfoArray(numItems);\n      const courses: IPageInterestInfo[] = makeSamplePageInterestInfoArray(numItems);\n      const interests: IPageInterestInfo[] = makeSamplePageInterestInfoArray(numItems);\n      const opportunities: IPageInterestInfo[] = makeSamplePageInterestInfoArray(numItems);\n      const docID1 = PageInterestsDailySnapshots.define({ careerGoals, courses, interests, opportunities });\n      const docID1Object: IPageInterestsDailySnapshot = PageInterestsDailySnapshots.findOne({ _id: docID1 });\n      const docID2 = PageInterestsDailySnapshots.define({\n        careerGoals,\n        courses,\n        interests,\n        opportunities,\n        timestamp: docID1Object.timestamp,\n      });\n\n      expect(docID1).to.equal(docID2);\n      expect(PageInterestsDailySnapshots.isDefined(docID1)).to.be.true;\n      PageInterestsDailySnapshots.removeIt(docID2);\n      expect(PageInterestsDailySnapshots.isDefined(docID1)).to.be.false;\n    });\n\n    it('Cannot define duplicate snapshots with the same values for all its fields created the same day', function test3() {\n      const numItems = 5;\n      const careerGoals: IPageInterestInfo[] = makeSamplePageInterestInfoArray(numItems);\n      const courses: IPageInterestInfo[] = makeSamplePageInterestInfoArray(numItems);\n      const interests: IPageInterestInfo[] = makeSamplePageInterestInfoArray(numItems);\n      const opportunities: IPageInterestInfo[] = makeSamplePageInterestInfoArray(numItems);\n      const docID1 = PageInterestsDailySnapshots.define({\n        careerGoals,\n        courses,\n        interests,\n        opportunities,\n        timestamp: moment('2020-06-16T00:00').toDate(),\n      });\n      const docID2 = PageInterestsDailySnapshots.define({\n        careerGoals,\n        courses,\n        interests,\n        opportunities,\n        timestamp: moment('2020-06-16T01:00').toDate(),\n      });\n\n      expect(docID1).to.equal(docID2);\n      expect(PageInterestsDailySnapshots.isDefined(docID1)).to.be.true;\n      PageInterestsDailySnapshots.removeIt(docID2);\n      expect(PageInterestsDailySnapshots.isDefined(docID1)).to.be.false;\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      let docID = makeSamplePageInterestsDailySnapshot();\n      const original: IPageInterestsDailySnapshot = PageInterestsDailySnapshots.findDoc(docID);\n      const dumpObject: IPageInterestsDailySnapshotDefine = PageInterestsDailySnapshots.dumpOne(docID);\n      PageInterestsDailySnapshots.removeIt(docID);\n      expect(PageInterestsDailySnapshots.isDefined(docID)).to.be.false;\n\n      docID = PageInterestsDailySnapshots.restoreOne(dumpObject);\n      expect(PageInterestsDailySnapshots.isDefined(docID)).to.be.true;\n\n      const restored: IPageInterestsDailySnapshot = PageInterestsDailySnapshots.findDoc(docID);\n      expect(original.careerGoals).to.deep.equal(restored.careerGoals);\n      expect(original.courses).to.deep.equal(restored.courses);\n      expect(original.interests).to.deep.equal(restored.interests);\n      expect(original.opportunities).to.deep.equal(restored.opportunities);\n      expect(original.timestamp).to.deep.equal(restored.timestamp);\n      expect(original.retired).to.deep.equal(restored.retired);\n\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const pageInterestsDailySnapshot: IPageInterestsDailySnapshot = PageInterestsDailySnapshots.findOne({});\n      const errors = PageInterestsDailySnapshots.checkIntegrity();\n      const { careerGoals, courses, interests, opportunities } = pageInterestsDailySnapshot;\n      const numSlugs = careerGoals.length + courses.length + interests.length + opportunities.length;\n\n      // When we call makeSamplePageInterestsDailySnapshot we don't create the random slugs that it generates\n      expect(errors.length).to.equal(numSlugs);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/page-tracking/PageInterestsDailySnapshotCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 831,
    "kind": "file",
    "name": "api/page-tracking/PageInterestsDailySnapshotCollection.ts",
    "content": "import SimpleSchema from 'simpl-schema';\nimport moment from 'moment';\nimport BaseCollection from '../base/BaseCollection';\nimport { IPageInterestsDailySnapshot, IPageInterestsDailySnapshotDefine } from '../../typings/radgrad';\nimport { Slugs } from '../slug/SlugCollection';\n\n/**\n * Represents a snapshot of the aggregated student interest views for the different categories for a particular day\n *  * The different topic categories that are tracked an counted towards student interest views are Career Goal, Course, Interest, and Opportunity\n * See PageInteressCollection to see the definition of a page interest view.\n * This collection is populated automatically on the server-side.\n * @extends api/base.BaseCollection\n * @memberOf @api/page-tracking\n */\nclass PageInterestsDailySnapshotCollection extends BaseCollection {\n\n  /**\n   * Creates the PageInterestsDailySnapshot collection.\n   */\n  constructor() {\n    super('PageInterestsDailySnapshot', new SimpleSchema({\n      careerGoals: Array,\n      'careerGoals.$': Object,\n      'careerGoals.$.name': String,\n      'careerGoals.$.views': { type: SimpleSchema.Integer, min: 0 },\n      courses: Array,\n      'courses.$': Object,\n      'courses.$.name': String,\n      'courses.$.views': { type: SimpleSchema.Integer, min: 0 },\n      interests: Array,\n      'interests.$': Object,\n      'interests.$.name': String,\n      'interests.$.views': { type: SimpleSchema.Integer, min: 0 },\n      opportunities: Array,\n      'opportunities.$': Object,\n      'opportunities.$.name': String,\n      'opportunities.$.views': { type: SimpleSchema.Integer, min: 0 },\n      timestamp: Date,\n      retired: { type: Boolean, optional: true },\n    }));\n  }\n\n  /**\n   * Gets the correct timestamp date that the daily snapshot represents\n   * The cron job that autopopulates this collection runs at 00:00:00 (morning of next day)\n   * Since a daily snapshot represents the page interest views for the day BEFORE, we need to subtract one day from\n   * .toDate() when the define() method is called.\n   * i.e.,\n   *  A cron job runs at June 18,2020 00:00:00 AM\n   *  Therefore, the timestamp for the daily snapshot that it creates should represent the page interest views that\n   *  were defined between June 17,2020 00:00:00 AM and June 17,2020 23:59:59 PM\n   *  Thus, the timestamp of the daily snapshot created on June 18,2020 00:00:00 AM should be June 17, 2020 23:59:59 PM\n   * @returns {Date}\n   */\n  private getDateOffset = moment().subtract(1, 'day').endOf('day').toDate();\n\n  /**\n   * Defines a snapshot of the aggregated student interest views for the different categories for the particular timestamp.\n   * This should never be called manually as it is handled by a cron job.\n   * @param careerGoals Array of objects that describe the name and views for all career goals\n   * @param courses Array of objects that describe the name and views for all courses\n   * @param interests Array of objects that describe the name and views for all interests\n   * @param opportunities Array of objects that describe the name and views for all opportunities\n   * @param timestamp the timestamp that represents the page interests it aggregated\n   *          by default, this is the day before .toDate(). This is because the cron job that autopopulates\n   *          this collection runs on 00:00:00 time (the day after), so we need to subtract one day\n   * @param retired boolean optional defaults to false.\n   * @returns {String} the id of the document created\n   */\n  public define({ careerGoals, courses, interests, opportunities, timestamp = this.getDateOffset, retired = false }: IPageInterestsDailySnapshotDefine): string {\n    // Duplicates are not allowed\n    // 1) Documents with the same values for all its fields\n    let doc: IPageInterestsDailySnapshot;\n    doc = this.collection.findOne({ careerGoals, courses, interests, opportunities, timestamp, retired });\n    if (doc) {\n      return doc._id;\n    }\n    // 2) Documents with the same values for all its fields within the same day that it represents\n    doc = this.collection.findOne({\n      careerGoals,\n      courses,\n      interests,\n      opportunities,\n      timestamp: {\n        $gte: moment(timestamp).startOf('day').toDate(),\n        $lte: moment(timestamp).endOf('day').toDate(),\n      },\n      retired,\n    });\n    if (doc) {\n      return doc._id;\n    }\n    return this.collection.insert({ careerGoals, courses, interests, opportunities, timestamp, retired });\n  }\n\n  /**\n   * Remove the Page Interests Daily Snapshot\n   * @param docID The docID of the Page Interests Daily Snapshot\n   */\n  public removeIt(docID: string): boolean {\n    this.assertDefined(docID);\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks each object in the careerGoals, courses, interests, and opportunities arrays.\n   * For each object, check the name if it is a valid slug and validate the views to be a positive integer.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity(): string[] {\n    const problems = [];\n    this.find({}, {}).forEach((doc: IPageInterestsDailySnapshot) => {\n      doc.careerGoals.forEach((careerGoal) => {\n        if (!Slugs.isDefined(careerGoal.name)) {\n          problems.push(`Bad careerGoal slug: ${careerGoal.name}`);\n        }\n        if (careerGoal.views < 0) {\n          problems.push(`Bad careerGoal views: ${careerGoal.views}`);\n        }\n      });\n      doc.courses.forEach((course) => {\n        if (!Slugs.isDefined(course.name)) {\n          problems.push(`Bad course slug: ${course.name}`);\n        }\n        if (course.views < 0) {\n          problems.push(`Bad course views: ${course.views}`);\n        }\n      });\n      doc.interests.forEach((interest) => {\n        if (!Slugs.isDefined(interest.name)) {\n          problems.push(`Bad interest slug: ${interest.name}`);\n        }\n        if (interest.views < 0) {\n          problems.push(`Bad interest views: ${interest.views}`);\n        }\n      });\n      doc.opportunities.forEach((opportunity) => {\n        if (!Slugs.isDefined(opportunity.name)) {\n          problems.push(`Bad opportunity slug: ${opportunity.name}`);\n        }\n        if (opportunity.views < 0) {\n          problems.push(`Bad opportunity views: ${opportunity.views}`);\n        }\n      });\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the PageInterestsDailySnapshot docID in a format acceptable to define().\n   * @param docID The docID of a PageInterestsDailySnapshot\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IPageInterestsDailySnapshotDefine {\n    const doc: IPageInterestsDailySnapshot = this.findDoc(docID);\n    const careerGoals = doc.careerGoals;\n    const courses = doc.courses;\n    const interests = doc.interests;\n    const opportunities = doc.opportunities;\n    const timestamp = doc.timestamp;\n    const retired = doc.retired;\n    return { careerGoals, courses, interests, opportunities, timestamp, retired };\n  }\n}\n\nexport const PageInterestsDailySnapshots = new PageInterestsDailySnapshotCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/page-tracking/PageInterestsDailySnapshotCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 832,
    "kind": "variable",
    "name": "PageInterestsDailySnapshots",
    "memberof": "api/page-tracking/PageInterestsDailySnapshotCollection.ts",
    "static": true,
    "longname": "api/page-tracking/PageInterestsDailySnapshotCollection.ts~PageInterestsDailySnapshots",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/page-tracking/PageInterestsDailySnapshotCollection.ts",
    "importStyle": "{PageInterestsDailySnapshots}",
    "description": null,
    "lineNumber": 173,
    "undocument": true,
    "type": {
      "types": [
        "api/page-tracking/PageInterestsDailySnapshotCollection.ts~PageInterestsDailySnapshotCollection"
      ]
    }
  },
  {
    "__docId__": 833,
    "kind": "class",
    "name": "PageInterestsDailySnapshotCollection",
    "memberof": "api/page-tracking/PageInterestsDailySnapshotCollection.ts",
    "static": true,
    "longname": "api/page-tracking/PageInterestsDailySnapshotCollection.ts~PageInterestsDailySnapshotCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/page-tracking/PageInterestsDailySnapshotCollection.ts",
    "importStyle": null,
    "description": "Represents a snapshot of the aggregated student interest views for the different categories for a particular day\nThe different topic categories that are tracked an counted towards student interest views are Career Goal, Course, Interest, and Opportunity\nSee PageInteressCollection to see the definition of a page interest view.\nThis collection is populated automatically on the server-side.",
    "lineNumber": 15,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 834,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/page-tracking/PageInterestsDailySnapshotCollection.ts~PageInterestsDailySnapshotCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/page-tracking/PageInterestsDailySnapshotCollection.ts~PageInterestsDailySnapshotCollection#constructor",
    "access": "public",
    "description": "Creates the PageInterestsDailySnapshot collection.",
    "lineNumber": 18
  },
  {
    "__docId__": 835,
    "kind": "member",
    "name": "getDateOffset",
    "memberof": "api/page-tracking/PageInterestsDailySnapshotCollection.ts~PageInterestsDailySnapshotCollection",
    "static": false,
    "longname": "api/page-tracking/PageInterestsDailySnapshotCollection.ts~PageInterestsDailySnapshotCollection#getDateOffset",
    "access": "public",
    "description": "Gets the correct timestamp date that the daily snapshot represents\nThe cron job that autopopulates this collection runs at 00:00:00 (morning of next day)\nSince a daily snapshot represents the page interest views for the day BEFORE, we need to subtract one day from\n.toDate() when the define() method is called.\ni.e.,\nA cron job runs at June 18,2020 00:00:00 AM\nTherefore, the timestamp for the daily snapshot that it creates should represent the page interest views that\nwere defined between June 17,2020 00:00:00 AM and June 17,2020 23:59:59 PM\nThus, the timestamp of the daily snapshot created on June 18,2020 00:00:00 AM should be June 17, 2020 23:59:59 PM",
    "lineNumber": 55,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 836,
    "kind": "method",
    "name": "define",
    "memberof": "api/page-tracking/PageInterestsDailySnapshotCollection.ts~PageInterestsDailySnapshotCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/page-tracking/PageInterestsDailySnapshotCollection.ts~PageInterestsDailySnapshotCollection#define",
    "access": "public",
    "description": "Defines a snapshot of the aggregated student interest views for the different categories for the particular timestamp.\nThis should never be called manually as it is handled by a cron job.",
    "lineNumber": 70,
    "params": [
      {
        "nullable": null,
        "types": [
          "IPageInterestsDailySnapshotDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 837,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/page-tracking/PageInterestsDailySnapshotCollection.ts~PageInterestsDailySnapshotCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/page-tracking/PageInterestsDailySnapshotCollection.ts~PageInterestsDailySnapshotCollection#removeIt",
    "access": "public",
    "description": "Remove the Page Interests Daily Snapshot",
    "lineNumber": 100,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 838,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/page-tracking/PageInterestsDailySnapshotCollection.ts~PageInterestsDailySnapshotCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/page-tracking/PageInterestsDailySnapshotCollection.ts~PageInterestsDailySnapshotCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks each object in the careerGoals, courses, interests, and opportunities arrays.\nFor each object, check the name if it is a valid slug and validate the views to be a positive integer.",
    "lineNumber": 112,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 839,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/page-tracking/PageInterestsDailySnapshotCollection.ts~PageInterestsDailySnapshotCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/page-tracking/PageInterestsDailySnapshotCollection.ts~PageInterestsDailySnapshotCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the PageInterestsDailySnapshot docID in a format acceptable to define().",
    "lineNumber": 156,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IPageInterestsDailySnapshotDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 840,
    "kind": "file",
    "name": "api/page-tracking/SamplePageInterests.ts",
    "content": "import faker from 'faker';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { Users } from '../user/UserCollection';\nimport { PageInterests } from './PageInterestCollection';\n\nexport const makeSamplePageInterest = (): string => {\n  const userID = makeSampleUser();\n  const username = Users.getProfile(userID).username;\n  const category = faker.lorem.word();\n  const name = faker.lorem.slug();\n  return PageInterests.define({ username, category, name });\n};\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/page-tracking/SamplePageInterests.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 841,
    "kind": "function",
    "name": "makeSamplePageInterest",
    "memberof": "api/page-tracking/SamplePageInterests.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/page-tracking/SamplePageInterests.ts~makeSamplePageInterest",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/page-tracking/SamplePageInterests.ts",
    "importStyle": "{makeSamplePageInterest}",
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 842,
    "kind": "file",
    "name": "api/page-tracking/SamplePageInterestsDailySnapshots.ts",
    "content": "import faker from 'faker';\nimport { IPageInterestInfo } from '../../typings/radgrad';\nimport { PageInterestsDailySnapshots } from './PageInterestsDailySnapshotCollection';\n\n/**\n * Creates a PageInterestInfo object of a unique slug and views\n * @param maxViews (inclusive) the maximum number of views randomly generated\n */\nconst makeSamplePageInterestInfo = (maxViews): IPageInterestInfo => {\n  const name = faker.lorem.slug();\n  const views = faker.random.number(maxViews);\n  return { name, views };\n};\n\n/**\n * Creates an array of PageInterestInfo\n * @param numItems the number of items in the array to create\n */\nexport const makeSamplePageInterestInfoArray = (numItems: number): IPageInterestInfo[] => {\n  const pageInterestInfoArray: IPageInterestInfo[] = [];\n  for (let i = 0; i < numItems; i++) {\n    const maxViews = faker.random.number(1000);\n    const pageInterestInfo = makeSamplePageInterestInfo(maxViews);\n    pageInterestInfoArray.push(pageInterestInfo);\n  }\n  return pageInterestInfoArray;\n};\n\nexport const makeSamplePageInterestsDailySnapshot = () => {\n  const numItems = 5;\n  const careerGoals: IPageInterestInfo[] = makeSamplePageInterestInfoArray(numItems);\n  const courses: IPageInterestInfo[] = makeSamplePageInterestInfoArray(numItems);\n  const interests: IPageInterestInfo[] = makeSamplePageInterestInfoArray(numItems);\n  const opportunities: IPageInterestInfo[] = makeSamplePageInterestInfoArray(numItems);\n  return PageInterestsDailySnapshots.define({ careerGoals, courses, interests, opportunities });\n};\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/page-tracking/SamplePageInterestsDailySnapshots.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 843,
    "kind": "function",
    "name": "makeSamplePageInterestInfo",
    "memberof": "api/page-tracking/SamplePageInterestsDailySnapshots.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/page-tracking/SamplePageInterestsDailySnapshots.ts~makeSamplePageInterestInfo",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/page-tracking/SamplePageInterestsDailySnapshots.ts",
    "importStyle": null,
    "description": "Creates a PageInterestInfo object of a unique slug and views",
    "lineNumber": 7,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "maxViews",
        "description": "(inclusive) the maximum number of views randomly generated"
      }
    ],
    "return": {
      "types": [
        "{\"name\": *, \"views\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 844,
    "kind": "function",
    "name": "makeSamplePageInterestInfoArray",
    "memberof": "api/page-tracking/SamplePageInterestsDailySnapshots.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/page-tracking/SamplePageInterestsDailySnapshots.ts~makeSamplePageInterestInfoArray",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/page-tracking/SamplePageInterestsDailySnapshots.ts",
    "importStyle": "{makeSamplePageInterestInfoArray}",
    "description": "Creates an array of PageInterestInfo",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "numItems",
        "description": "the number of items in the array to create"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 845,
    "kind": "function",
    "name": "makeSamplePageInterestsDailySnapshot",
    "memberof": "api/page-tracking/SamplePageInterestsDailySnapshots.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/page-tracking/SamplePageInterestsDailySnapshots.ts~makeSamplePageInterestsDailySnapshot",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/page-tracking/SamplePageInterestsDailySnapshots.ts",
    "importStyle": "{makeSamplePageInterestsDailySnapshot}",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 846,
    "kind": "file",
    "name": "api/page-tracking/index.ts",
    "content": "/** @namespace api/page-tracking */\nimport './PageInterestCollection';\nimport './PageInterestCollection.methods';\nimport './PageInterestsDailySnapshotCollection';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/page-tracking/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 847,
    "kind": "file",
    "name": "api/public-stats/PublicStatsCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { PublicStats } from './PublicStatsCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('PublicStatsCollecion', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('#careerGoalsTotal, #careerGoalsList', function test() {\n      PublicStats.careerGoalsTotal();\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/public-stats/PublicStatsCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 848,
    "kind": "file",
    "name": "api/public-stats/PublicStatsCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport _ from 'lodash';\nimport BaseCollection from '../base/BaseCollection';\nimport { AcademicPlans } from '../degree-plan/AcademicPlanCollection';\nimport { CareerGoals } from '../career/CareerGoalCollection';\nimport { Courses } from '../course/CourseCollection';\nimport { DesiredDegrees } from '../degree-plan/DesiredDegreeCollection';\nimport { Interests } from '../interest/InterestCollection';\nimport { MentorProfiles } from '../user/MentorProfileCollection';\nimport { FacultyProfiles } from '../user/FacultyProfileCollection';\nimport { Opportunities } from '../opportunity/OpportunityCollection';\nimport { OpportunityTypes } from '../opportunity/OpportunityTypeCollection';\nimport { Reviews } from '../review/ReviewCollection';\nimport { Users } from '../user/UserCollection';\nimport { Slugs } from '../slug/SlugCollection';\nimport { StudentProfiles } from '../user/StudentProfileCollection';\n\n/**\n * PublicStats holds statistics about RadGrad that can be accessed without logging in.\n * These are referenced in the landing page and the guided tour.\n * Basically, the collection is a set of documents with two fields: key and value.\n * The field this.stats holds a list of strings which define the set of legal keys.\n * Each of these strings is also the name of a method in this class which is responsible for calculating the value\n * associated with the key and then upserting the key-value pair into the collection.\n *\n * See startup/server/initialize-db.js for the code that starts a cron job that updates this collection when the\n * system starts up and once a day thereafter.\n *\n * @extends api/base.BaseCollection\n * @memberOf api/public-stats\n */\nclass PublicStatsCollection extends BaseCollection {\n  private readonly stats: any[];\n  public academicPlansTotalKey: string;\n  public coursesTotalKey: string;\n  public careerGoalsTotalKey: string;\n  public careerGoalsListKey: string;\n  public desiredDegreesTotalKey: string;\n  public desiredDegreesListKey: string;\n  public interestsTotalKey: string;\n  public interestsListKey: string;\n  public opportunitiesTotalKey: string;\n  public opportunitiesProjectsTotalKey: string;\n  public opportunitiesProjectsListKey: string;\n  public usersTotalKey: string;\n  public usersStudentsTotalKey: string;\n  public usersFacultyTotalKey: string;\n  public usersMentorsTotalKey: string;\n  public usersMentorsProfessionsListKey: string;\n  public usersMentorsLocationsKey: string;\n  public courseReviewsTotalKey: string;\n  public courseReviewsCoursesKey: string;\n  public levelOneTotalKey: string;\n  public levelTwoTotalKey: string;\n  public levelThreeTotalKey: string;\n  public levelFourTotalKey: string;\n  public levelFiveTotalKey: string;\n  public levelSixTotalKey: string;\n  public firstAcademicPlanKey: string;\n  public firstCareerGoalKey: string;\n  public firstInterestKey: string;\n  public firstOpportunityKey: string;\n  public firstDegreeKey: string;\n  /**\n   * Creates the PublicStats collection.\n   */\n  constructor() {\n    super('PublicStats', new SimpleSchema({\n      key: { type: String },\n      value: { type: String },\n    }));\n    this.stats = [];\n    this.academicPlansTotalKey = 'academicPlansTotal';\n    this.stats.push(this.academicPlansTotalKey);\n    this.coursesTotalKey = 'coursesTotal';\n    this.stats.push(this.coursesTotalKey);\n    this.careerGoalsTotalKey = 'careerGoalsTotal';\n    this.stats.push(this.careerGoalsTotalKey);\n    this.careerGoalsListKey = 'careerGoalsList';\n    this.stats.push(this.careerGoalsListKey);\n    this.desiredDegreesTotalKey = 'desiredDegreesTotal';\n    this.stats.push(this.desiredDegreesTotalKey);\n    this.desiredDegreesListKey = 'desiredDegreesList';\n    this.stats.push(this.desiredDegreesListKey);\n    this.interestsTotalKey = 'interestsTotal';\n    this.stats.push(this.interestsTotalKey);\n    this.interestsListKey = 'interestsList';\n    this.stats.push(this.interestsListKey);\n    this.opportunitiesTotalKey = 'opportunitiesTotal';\n    this.stats.push(this.opportunitiesTotalKey);\n    this.opportunitiesProjectsTotalKey = 'opportunitiesProjectsTotal';\n    this.stats.push(this.opportunitiesProjectsTotalKey);\n    this.opportunitiesProjectsListKey = 'opportunitiesProjectsList';\n    this.stats.push(this.opportunitiesProjectsListKey);\n    this.usersTotalKey = 'usersTotal';\n    this.stats.push(this.usersTotalKey);\n    this.usersStudentsTotalKey = 'usersStudentsTotal';\n    this.stats.push(this.usersStudentsTotalKey);\n    this.usersFacultyTotalKey = 'usersFacultyTotal';\n    this.stats.push(this.usersFacultyTotalKey);\n    this.usersMentorsTotalKey = 'usersMentorsTotal';\n    this.stats.push(this.usersMentorsTotalKey);\n    this.usersMentorsProfessionsListKey = 'usersMentorsProfessionsList';\n    this.stats.push(this.usersMentorsProfessionsListKey);\n    this.usersMentorsLocationsKey = 'usersMentorsLocations';\n    this.stats.push(this.usersMentorsLocationsKey);\n    this.courseReviewsTotalKey = 'courseReviewsTotal';\n    this.stats.push(this.courseReviewsTotalKey);\n    this.courseReviewsCoursesKey = 'courseReviewsCourses';\n    this.stats.push(this.courseReviewsCoursesKey);\n    this.levelOneTotalKey = 'levelOneTotal';\n    this.stats.push(this.levelOneTotalKey);\n    this.levelTwoTotalKey = 'levelTwoTotal';\n    this.stats.push(this.levelTwoTotalKey);\n    this.levelThreeTotalKey = 'levelThreeTotal';\n    this.stats.push(this.levelThreeTotalKey);\n    this.levelFourTotalKey = 'levelFourTotal';\n    this.stats.push(this.levelFourTotalKey);\n    this.levelFiveTotalKey = 'levelFiveTotal';\n    this.stats.push(this.levelFiveTotalKey);\n    this.levelSixTotalKey = 'levelSixTotal';\n    this.stats.push(this.levelSixTotalKey);\n    this.firstAcademicPlanKey = 'firstAcademicPlan';\n    this.stats.push(this.firstAcademicPlanKey);\n    this.firstCareerGoalKey = 'firstCareerGoal';\n    this.stats.push(this.firstCareerGoalKey);\n    this.firstInterestKey = 'firstInterest';\n    this.stats.push(this.firstInterestKey);\n    this.firstOpportunityKey = 'firstOpportunity';\n    this.stats.push(this.firstOpportunityKey);\n    this.firstDegreeKey = 'firstDegree';\n    this.stats.push(this.firstDegreeKey);\n  }\n\n  public academicPlansTotal() {\n    const count: number = AcademicPlans.find().count();\n    this.collection.upsert({ key: this.academicPlansTotalKey }, { $set: { value: `${count}` } });\n  }\n\n  public careerGoalsTotal() {\n    const count = CareerGoals.find().count();\n    this.collection.upsert({ key: this.careerGoalsTotalKey }, { $set: { value: `${count}` } });\n  }\n\n  public coursesTotal() {\n    const count = Courses.findNonRetired().length;\n    this.collection.upsert({ key: this.coursesTotalKey }, { $set: { value: `${count}` } });\n  }\n\n  public careerGoalsList() {\n    const goals = CareerGoals.findNonRetired();\n    const names = _.map(goals, 'name');\n    this.collection.upsert({ key: this.careerGoalsListKey }, { $set: { value: names.join(', ') } });\n  }\n\n  public desiredDegreesTotal() {\n    const count = DesiredDegrees.countNonRetired();\n    this.collection.upsert({ key: this.desiredDegreesTotalKey }, { $set: { value: `${count}` } });\n  }\n\n  public desiredDegreesList() {\n    const degrees = DesiredDegrees.findNonRetired();\n    const names = _.map(degrees, 'name');\n    this.collection.upsert({ key: this.desiredDegreesListKey }, { $set: { value: names.join(', ') } });\n  }\n\n  public interestsTotal() {\n    const numInterests = Interests.countNonRetired();\n    this.collection.upsert({ key: this.interestsTotalKey }, { $set: { value: `${numInterests}` } });\n  }\n\n  public interestsList() {\n    const interests = Interests.findNonRetired();\n    const names = _.map(interests, 'name');\n    this.collection.upsert({ key: this.interestsListKey }, { $set: { value: names.join(', ') } });\n  }\n\n  public opportunitiesTotal() {\n    const numOpps = Opportunities.countNonRetired();\n    this.collection.upsert({ key: this.opportunitiesTotalKey }, { $set: { value: `${numOpps}` } });\n  }\n\n  public opportunitiesProjectsTotal() {\n    const projectType = OpportunityTypes.findDoc({ name: 'Project' });\n    const numProjects = Opportunities.findNonRetired({ opportunityTypeID: projectType._id }).length;\n    this.collection.upsert({ key: this.opportunitiesProjectsTotalKey }, { $set: { value: `${numProjects}` } });\n  }\n\n  public opportunitiesProjectsList() {\n    const projectType = OpportunityTypes.findDoc({ name: 'Project' });\n    const projects = Opportunities.findNonRetired({ opportunityTypeID: projectType._id });\n    const names = _.map(projects, 'name');\n    this.collection.upsert({ key: this.opportunitiesProjectsListKey }, { $set: { value: names.join(', ') } });\n  }\n\n  public upsertLevelTotal(level, key) {\n    const numUsers = StudentProfiles.find({ level }).count();\n    this.collection.upsert({ key }, { $set: { value: `${numUsers}` } });\n  }\n\n  public levelOneTotal() {\n    this.upsertLevelTotal(1, this.levelOneTotalKey);\n  }\n\n  public levelTwoTotal() {\n    this.upsertLevelTotal(2, this.levelTwoTotalKey);\n  }\n\n  public levelThreeTotal() {\n    this.upsertLevelTotal(3, this.levelThreeTotalKey);\n  }\n\n  public levelFourTotal() {\n    this.upsertLevelTotal(4, this.levelFourTotalKey);\n  }\n\n  public levelFiveTotal() {\n    this.upsertLevelTotal(5, this.levelFiveTotalKey);\n  }\n\n  public levelSixTotal() {\n    this.upsertLevelTotal(6, this.levelSixTotalKey);\n  }\n\n  public usersTotal() {\n    const numUsers = Users.findProfiles({}, {}).length;\n    this.collection.upsert({ key: this.usersTotalKey }, { $set: { value: `${numUsers}` } });\n  }\n\n  public usersStudentsTotal() {\n    const numUsers = StudentProfiles.find().count();\n    this.collection.upsert({ key: this.usersStudentsTotalKey }, { $set: { value: `${numUsers}` } });\n  }\n\n  public usersFacultyTotal() {\n    const numUsers = FacultyProfiles.find().count();\n    this.collection.upsert({ key: this.usersFacultyTotalKey }, { $set: { value: `${numUsers}` } });\n  }\n\n  public usersMentorsTotal() {\n    const numUsers = MentorProfiles.find().count();\n    this.collection.upsert({ key: this.usersMentorsTotalKey }, { $set: { value: `${numUsers}` } });\n  }\n\n  public usersMentorsProfessionsList() {\n    let professions = [];\n    MentorProfiles.find().forEach((profile) => professions.push(profile.career));\n    professions = _.union(professions);\n    if (professions.length > 0) {\n      this.collection.upsert({ key: this.usersMentorsProfessionsListKey }, { $set: { value: professions.join(', ') } });\n    }\n  }\n\n  public usersMentorsLocations() {\n    let locations = [];\n    MentorProfiles.find().forEach((profile) => locations.push(profile.location));\n    locations = _.union(locations);\n    if (locations.length > 0) {\n      this.collection.upsert({ key: this.usersMentorsLocationsKey }, { $set: { value: locations.join(', ') } });\n    }\n  }\n\n  public courseReviewsTotal() {\n    const numCourseReviews = Reviews.find({ reviewType: 'course' }).count();\n    this.collection.upsert({ key: this.courseReviewsTotalKey }, { $set: { value: `${numCourseReviews}` } });\n  }\n\n  public courseReviewsCourses() {\n    const courseReviews = Reviews.findNonRetired({ reviewType: 'course' });\n    let courseNumbers = [];\n    _.forEach(courseReviews, (review) => {\n      const course = Courses.findDoc(review.revieweeID);\n      courseNumbers.push(course.num);\n    });\n    courseNumbers = _.union(courseNumbers);\n    if (courseNumbers.length > 0) {\n      this.collection.upsert({ key: this.courseReviewsCoursesKey }, { $set: { value: courseNumbers.join(', ') } });\n    }\n  }\n\n  public firstAcademicPlan() {\n    let planName = '';\n    const termNumber = AcademicPlans.getLatestAcademicTermNumber();\n    const plan = AcademicPlans.findOne({ termNumber });\n    if (plan) {\n      planName = (Slugs.findDoc(plan.slugID)).name;\n      this.collection.upsert({ key: this.firstAcademicPlanKey }, { $set: { value: planName } });\n    }\n  }\n\n  public firstCareerGoal() {\n    const careerGoals = CareerGoals.findNonRetired({}, { sort: { name: 1 } });\n    if (careerGoals.length > 0) {\n      const name = Slugs.findDoc(careerGoals[0].slugID).name;\n      this.collection.upsert({ key: this.firstCareerGoalKey }, { $set: { value: name } });\n    }\n  }\n\n  public firstInterest() {\n    const interests = Interests.findNonRetired({}, { sort: { name: 1 } });\n    if (interests.length > 0) {\n      const name = Slugs.findDoc(interests[0].slugID).name;\n      this.collection.upsert({ key: this.firstInterestKey }, { $set: { value: name } });\n    }\n  }\n\n  public firstOpportunity() {\n    const interests = Opportunities.findNonRetired({}, { sort: { name: 1 } });\n    if (interests.length > 0) {\n      const name = Slugs.findDoc(interests[0].slugID).name;\n      this.collection.upsert({ key: this.firstOpportunityKey }, { $set: { value: name } });\n    }\n  }\n\n  public firstDegree() {\n    const degrees = DesiredDegrees.findNonRetired({}, { sort: { name: 1 } });\n    if (degrees.length > 0) {\n      const name = Slugs.findDoc(degrees[0].slugID).name;\n      this.collection.upsert({ key: this.firstDegreeKey }, { $set: { value: name } });\n    }\n  }\n\n  public generateStats() {\n    if (!(Meteor.isTest || Meteor.isAppTest)) {\n      const instance = this;\n      _.forEach(this.stats, (key) => {\n        instance[key]();\n      });\n    }\n  }\n\n  /**\n   * Returns the value for the given key, or empty string if invalid key.\n   * @param {string} key\n   * @returns {string}\n   */\n  public getPublicStat(key: string): string {\n    try {\n      return this.findDoc({ key }).value;\n    } catch (e) {\n      return '';\n    }\n  }\n\n  /**\n   * Returns an empty array to indicate no integrity checking.\n   * @returns {Array} An empty array.\n   */\n  public checkIntegrity() {\n    return [];\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @type {api/public-stats.PublicStatsCollection}\n * @memberOf api/public-stats\n */\nexport const PublicStats = new PublicStatsCollection();\n\n// /**\n//  * Create a global helper called publicStats that returns the value associated with the passed key.\n//  */\n// if (Meteor.isClient) {\n//   Template.registerHelper('publicStats', (key) => {\n//     const stat = PublicStats.isDefined({ key }) && PublicStats.findDoc({ key });\n//     if (stat) {\n//       return stat.value;\n//     }\n//     return null;\n//   });\n// }\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/public-stats/PublicStatsCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 849,
    "kind": "variable",
    "name": "PublicStats",
    "memberof": "api/public-stats/PublicStatsCollection.ts",
    "static": true,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStats",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/public-stats/PublicStatsCollection.ts",
    "importStyle": "{PublicStats}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 497,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/public-stats"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/public-stats.PublicStatsCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 850,
    "kind": "class",
    "name": "PublicStatsCollection",
    "memberof": "api/public-stats/PublicStatsCollection.ts",
    "static": true,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/public-stats/PublicStatsCollection.ts",
    "importStyle": null,
    "description": "PublicStats holds statistics about RadGrad that can be accessed without logging in.\nThese are referenced in the landing page and the guided tour.\nBasically, the collection is a set of documents with two fields: key and value.\nThe field this.stats holds a list of strings which define the set of legal keys.\nEach of these strings is also the name of a method in this class which is responsible for calculating the value\nassociated with the key and then upserting the key-value pair into the collection.\n\nSee startup/server/initialize-db.js for the code that starts a cron job that updates this collection when the\nsystem starts up and once a day thereafter.",
    "lineNumber": 33,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 851,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#constructor",
    "access": "public",
    "description": "Creates the PublicStats collection.",
    "lineNumber": 36
  },
  {
    "__docId__": 852,
    "kind": "member",
    "name": "stats",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#stats",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 853,
    "kind": "member",
    "name": "academicPlansTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#academicPlansTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 854,
    "kind": "member",
    "name": "coursesTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#coursesTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 855,
    "kind": "member",
    "name": "careerGoalsTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#careerGoalsTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 856,
    "kind": "member",
    "name": "careerGoalsListKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#careerGoalsListKey",
    "access": "public",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 857,
    "kind": "member",
    "name": "desiredDegreesTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#desiredDegreesTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 858,
    "kind": "member",
    "name": "desiredDegreesListKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#desiredDegreesListKey",
    "access": "public",
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 859,
    "kind": "member",
    "name": "interestsTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#interestsTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 860,
    "kind": "member",
    "name": "interestsListKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#interestsListKey",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 861,
    "kind": "member",
    "name": "opportunitiesTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#opportunitiesTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 862,
    "kind": "member",
    "name": "opportunitiesProjectsTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#opportunitiesProjectsTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 863,
    "kind": "member",
    "name": "opportunitiesProjectsListKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#opportunitiesProjectsListKey",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 864,
    "kind": "member",
    "name": "usersTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#usersTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 865,
    "kind": "member",
    "name": "usersStudentsTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#usersStudentsTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 866,
    "kind": "member",
    "name": "usersFacultyTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#usersFacultyTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 867,
    "kind": "member",
    "name": "usersMentorsTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#usersMentorsTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 868,
    "kind": "member",
    "name": "usersMentorsProfessionsListKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#usersMentorsProfessionsListKey",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 869,
    "kind": "member",
    "name": "usersMentorsLocationsKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#usersMentorsLocationsKey",
    "access": "public",
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 870,
    "kind": "member",
    "name": "courseReviewsTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#courseReviewsTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 871,
    "kind": "member",
    "name": "courseReviewsCoursesKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#courseReviewsCoursesKey",
    "access": "public",
    "description": null,
    "lineNumber": 78,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 872,
    "kind": "member",
    "name": "levelOneTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#levelOneTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 80,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 873,
    "kind": "member",
    "name": "levelTwoTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#levelTwoTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 874,
    "kind": "member",
    "name": "levelThreeTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#levelThreeTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 875,
    "kind": "member",
    "name": "levelFourTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#levelFourTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 86,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 876,
    "kind": "member",
    "name": "levelFiveTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#levelFiveTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 877,
    "kind": "member",
    "name": "levelSixTotalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#levelSixTotalKey",
    "access": "public",
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 878,
    "kind": "member",
    "name": "firstAcademicPlanKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#firstAcademicPlanKey",
    "access": "public",
    "description": null,
    "lineNumber": 92,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 879,
    "kind": "member",
    "name": "firstCareerGoalKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#firstCareerGoalKey",
    "access": "public",
    "description": null,
    "lineNumber": 94,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 880,
    "kind": "member",
    "name": "firstInterestKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#firstInterestKey",
    "access": "public",
    "description": null,
    "lineNumber": 96,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 881,
    "kind": "member",
    "name": "firstOpportunityKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#firstOpportunityKey",
    "access": "public",
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 882,
    "kind": "member",
    "name": "firstDegreeKey",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#firstDegreeKey",
    "access": "public",
    "description": null,
    "lineNumber": 100,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 883,
    "kind": "method",
    "name": "academicPlansTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#academicPlansTotal",
    "access": "public",
    "description": "",
    "lineNumber": 136,
    "params": [],
    "return": null
  },
  {
    "__docId__": 884,
    "kind": "method",
    "name": "careerGoalsTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#careerGoalsTotal",
    "access": "public",
    "description": "",
    "lineNumber": 141,
    "params": [],
    "return": null
  },
  {
    "__docId__": 885,
    "kind": "method",
    "name": "coursesTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#coursesTotal",
    "access": "public",
    "description": "",
    "lineNumber": 146,
    "params": [],
    "return": null
  },
  {
    "__docId__": 886,
    "kind": "method",
    "name": "careerGoalsList",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#careerGoalsList",
    "access": "public",
    "description": "",
    "lineNumber": 151,
    "params": [],
    "return": null
  },
  {
    "__docId__": 887,
    "kind": "method",
    "name": "desiredDegreesTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#desiredDegreesTotal",
    "access": "public",
    "description": "",
    "lineNumber": 157,
    "params": [],
    "return": null
  },
  {
    "__docId__": 888,
    "kind": "method",
    "name": "desiredDegreesList",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#desiredDegreesList",
    "access": "public",
    "description": "",
    "lineNumber": 162,
    "params": [],
    "return": null
  },
  {
    "__docId__": 889,
    "kind": "method",
    "name": "interestsTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#interestsTotal",
    "access": "public",
    "description": "",
    "lineNumber": 168,
    "params": [],
    "return": null
  },
  {
    "__docId__": 890,
    "kind": "method",
    "name": "interestsList",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#interestsList",
    "access": "public",
    "description": "",
    "lineNumber": 173,
    "params": [],
    "return": null
  },
  {
    "__docId__": 891,
    "kind": "method",
    "name": "opportunitiesTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#opportunitiesTotal",
    "access": "public",
    "description": "",
    "lineNumber": 179,
    "params": [],
    "return": null
  },
  {
    "__docId__": 892,
    "kind": "method",
    "name": "opportunitiesProjectsTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#opportunitiesProjectsTotal",
    "access": "public",
    "description": "",
    "lineNumber": 184,
    "params": [],
    "return": null
  },
  {
    "__docId__": 893,
    "kind": "method",
    "name": "opportunitiesProjectsList",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#opportunitiesProjectsList",
    "access": "public",
    "description": "",
    "lineNumber": 190,
    "params": [],
    "return": null
  },
  {
    "__docId__": 894,
    "kind": "method",
    "name": "upsertLevelTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#upsertLevelTotal",
    "access": "public",
    "description": "",
    "lineNumber": 197,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "level",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 895,
    "kind": "method",
    "name": "levelOneTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#levelOneTotal",
    "access": "public",
    "description": "",
    "lineNumber": 202,
    "params": [],
    "return": null
  },
  {
    "__docId__": 896,
    "kind": "method",
    "name": "levelTwoTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#levelTwoTotal",
    "access": "public",
    "description": "",
    "lineNumber": 206,
    "params": [],
    "return": null
  },
  {
    "__docId__": 897,
    "kind": "method",
    "name": "levelThreeTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#levelThreeTotal",
    "access": "public",
    "description": "",
    "lineNumber": 210,
    "params": [],
    "return": null
  },
  {
    "__docId__": 898,
    "kind": "method",
    "name": "levelFourTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#levelFourTotal",
    "access": "public",
    "description": "",
    "lineNumber": 214,
    "params": [],
    "return": null
  },
  {
    "__docId__": 899,
    "kind": "method",
    "name": "levelFiveTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#levelFiveTotal",
    "access": "public",
    "description": "",
    "lineNumber": 218,
    "params": [],
    "return": null
  },
  {
    "__docId__": 900,
    "kind": "method",
    "name": "levelSixTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#levelSixTotal",
    "access": "public",
    "description": "",
    "lineNumber": 222,
    "params": [],
    "return": null
  },
  {
    "__docId__": 901,
    "kind": "method",
    "name": "usersTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#usersTotal",
    "access": "public",
    "description": "",
    "lineNumber": 226,
    "params": [],
    "return": null
  },
  {
    "__docId__": 902,
    "kind": "method",
    "name": "usersStudentsTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#usersStudentsTotal",
    "access": "public",
    "description": "",
    "lineNumber": 231,
    "params": [],
    "return": null
  },
  {
    "__docId__": 903,
    "kind": "method",
    "name": "usersFacultyTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#usersFacultyTotal",
    "access": "public",
    "description": "",
    "lineNumber": 236,
    "params": [],
    "return": null
  },
  {
    "__docId__": 904,
    "kind": "method",
    "name": "usersMentorsTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#usersMentorsTotal",
    "access": "public",
    "description": "",
    "lineNumber": 241,
    "params": [],
    "return": null
  },
  {
    "__docId__": 905,
    "kind": "method",
    "name": "usersMentorsProfessionsList",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#usersMentorsProfessionsList",
    "access": "public",
    "description": "",
    "lineNumber": 246,
    "params": [],
    "return": null
  },
  {
    "__docId__": 906,
    "kind": "method",
    "name": "usersMentorsLocations",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#usersMentorsLocations",
    "access": "public",
    "description": "",
    "lineNumber": 255,
    "params": [],
    "return": null
  },
  {
    "__docId__": 907,
    "kind": "method",
    "name": "courseReviewsTotal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#courseReviewsTotal",
    "access": "public",
    "description": "",
    "lineNumber": 264,
    "params": [],
    "return": null
  },
  {
    "__docId__": 908,
    "kind": "method",
    "name": "courseReviewsCourses",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#courseReviewsCourses",
    "access": "public",
    "description": "",
    "lineNumber": 269,
    "params": [],
    "return": null
  },
  {
    "__docId__": 909,
    "kind": "method",
    "name": "firstAcademicPlan",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#firstAcademicPlan",
    "access": "public",
    "description": "",
    "lineNumber": 282,
    "params": [],
    "return": null
  },
  {
    "__docId__": 910,
    "kind": "method",
    "name": "firstCareerGoal",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#firstCareerGoal",
    "access": "public",
    "description": "",
    "lineNumber": 292,
    "params": [],
    "return": null
  },
  {
    "__docId__": 911,
    "kind": "method",
    "name": "firstInterest",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#firstInterest",
    "access": "public",
    "description": "",
    "lineNumber": 300,
    "params": [],
    "return": null
  },
  {
    "__docId__": 912,
    "kind": "method",
    "name": "firstOpportunity",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#firstOpportunity",
    "access": "public",
    "description": "",
    "lineNumber": 308,
    "params": [],
    "return": null
  },
  {
    "__docId__": 913,
    "kind": "method",
    "name": "firstDegree",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#firstDegree",
    "access": "public",
    "description": "",
    "lineNumber": 316,
    "params": [],
    "return": null
  },
  {
    "__docId__": 914,
    "kind": "method",
    "name": "generateStats",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#generateStats",
    "access": "public",
    "description": "",
    "lineNumber": 324,
    "params": [],
    "return": null
  },
  {
    "__docId__": 915,
    "kind": "method",
    "name": "getPublicStat",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#getPublicStat",
    "access": "public",
    "description": "Returns the value for the given key, or empty string if invalid key.",
    "lineNumber": 338,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 916,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/PublicStatsCollection.ts~PublicStatsCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an empty array to indicate no integrity checking.",
    "lineNumber": 350,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 917,
    "kind": "file",
    "name": "api/public-stats/StudentParticipationCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport _ from 'lodash';\nimport BaseCollection from '../base/BaseCollection';\nimport { ROLE } from '../role/Role';\nimport { Opportunities } from '../opportunity/OpportunityCollection';\nimport { Slugs } from '../slug/SlugCollection';\nimport { Courses } from '../course/CourseCollection';\nimport { CourseInstances } from '../course/CourseInstanceCollection';\nimport { OpportunityInstances } from '../opportunity/OpportunityInstanceCollection';\nimport { IStudentParticipationDefine, IStudentParticipationUpdate } from '../../typings/radgrad';\nimport { AcademicPlans } from '../degree-plan/AcademicPlanCollection';\nimport { CareerGoals } from '../career/CareerGoalCollection';\nimport { Interests } from '../interest/InterestCollection';\nimport { StudentProfiles } from '../user/StudentProfileCollection';\nimport { FavoriteCareerGoals } from '../favorite/FavoriteCareerGoalCollection';\nimport { profileGetInterestIDs } from '../../ui/components/shared/data-model-helper-functions';\nimport { FavoriteAcademicPlans } from '../favorite/FavoriteAcademicPlanCollection';\n\nclass StudentParticipationCollection extends BaseCollection {\n  constructor() {\n    super('StudentParticipationCollection', new SimpleSchema({\n      itemID: SimpleSchema.RegEx.Id,\n      itemSlug: String,\n      itemCount: SimpleSchema.Integer,\n    }));\n    this.defineSchema = new SimpleSchema({\n      itemSlug: String,\n      itemCount: Number,\n    });\n    this.updateSchema = new SimpleSchema({\n      itemCount: { type: Number, optional: true },\n    });\n  }\n\n  /**\n   * Defines the enrollment data for the given item.\n   * @param itemSlug the slug for the Course or Opportunity\n   * @param itemCount the number of students that have the course or opportunity in their plan.\n   * @returns {any} The id of the record.\n   */\n  define({ itemSlug, itemCount }: IStudentParticipationDefine) {\n    const doc = this.collection.findOne({ itemSlug });\n    if (doc) {\n      return doc._id;\n    }\n    if (!Slugs.isDefined(itemSlug)) {\n      throw new Meteor.Error(`${itemSlug} is not a defined slug.`);\n    }\n    const slug = Slugs.findDoc(itemSlug);\n    const itemID = slug.entityID;\n    return this.collection.insert({ itemID, itemSlug, itemCount });\n  }\n\n  // TODO: should we be updating StudentParticipation everytime we add something to a collection?\n  /**\n   * Updates the enrollment data for the given item.\n   * @param docID the ID of the record.\n   * @param itemCount the new itemCount.\n   */\n  update(docID: string, { itemCount }: IStudentParticipationUpdate) {\n    this.assertDefined(docID);\n    const updateData: IStudentParticipationUpdate = {};\n    updateData.itemCount = itemCount;\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Removes the enrollment information.\n   * @param docID the ID of the record.\n   */\n  removeIt(docID) {\n    this.assertDefined(docID);\n    // OK, clear to delete.\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Only ADMINs can update the records.\n   * @param userId\n   */\n  assertValidRoleForMethod(userId) {\n    this.assertRole(userId, [ROLE.ADMIN]);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks itemID and itemSlug\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  checkIntegrity() {\n    const problems = [];\n    this.find()\n      .forEach(doc => {\n        if (!Courses.isDefined(doc.itemID) &&\n          !Opportunities.isDefined(doc.itemID) &&\n          !AcademicPlans.isDefined(doc.itemID) &&\n          !CareerGoals.isDefined(doc.itemID) &&\n          !Interests.isDefined(doc.itemID)) {\n          problems.push(`Bad itemID. ${doc.itemID} is neither a Course or Opportunity ID.`);\n        }\n        if (!Slugs.isSlugForEntity(doc.itemSlug, Courses.getType()) &&\n          !Slugs.isSlugForEntity(doc.itemSlug, Opportunities.getType()) &&\n          !Slugs.isSlugForEntity(doc.itemSlug, AcademicPlans.getType()) &&\n          !Slugs.isSlugForEntity(doc.itemSlug, CareerGoals.getType()) &&\n          !Slugs.isSlugForEntity(doc.itemSlug, Interests.getType())) {\n          problems.push(`Bad itemSlug. ${doc.itemSlug} is neither a Course or Opportunity slug.`);\n        }\n      });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the StudentParticipation docID in a format acceptable to define().\n   * @param docID The docID of a StudentParticipation item.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  dumpOne(docID: string): IStudentParticipationDefine {\n    const doc = this.findDoc(docID);\n    const itemID = doc.itemID;\n    const itemSlug = doc.itemSlug;\n    const itemCount = doc.itemCount;\n    return { itemID, itemSlug, itemCount };\n  }\n\n  upsertEnrollmentData() {\n    if (Meteor.isServer) {\n      // Courses\n      const courses = Courses.findNonRetired();\n      _.forEach(courses, (c) => {\n        const itemID = c._id;\n        const itemSlug = Slugs.getNameFromID(c.slugID);\n        const items = CourseInstances.findNonRetired({ courseID: itemID });\n        const itemCount = _.uniqBy(items, (i) => i.studentID).length;\n        this.collection.upsert({ itemSlug }, { $set: { itemID, itemSlug, itemCount } });\n      });\n      // Opportunities\n      _.forEach(Opportunities.findNonRetired(), (o) => {\n        const itemID = o._id;\n        const itemSlug = Slugs.getNameFromID(o.slugID);\n        const items = OpportunityInstances.findNonRetired({ opportunityID: itemID });\n        const itemCount = _.uniqBy(items, (i) => i.studentID).length;\n        this.collection.upsert({ itemSlug }, { $set: { itemID, itemSlug, itemCount } });\n      });\n      const students = StudentProfiles.findNonRetired({ isAlumni: false });\n      // AcademicPlans\n      const academicPlans = AcademicPlans.findNonRetired();\n      _.forEach(academicPlans, (p) => {\n        const itemID = p._id;\n        const itemSlug = Slugs.getNameFromID(p.slugID);\n        const filterd = _.filter(students, (s) => {\n          const favPlans = FavoriteAcademicPlans.findNonRetired({ studentID: s.userID });\n          const planIDs = _.map(favPlans, (fav) => fav.academicPlanID);\n          return _.includes(planIDs, itemID);\n        });\n        // console.log('students with academicplan %o = %o', itemID, filterd);\n        const itemCount = filterd.length;\n        this.collection.upsert({ itemSlug }, { $set: { itemID, itemSlug, itemCount } });\n      });\n      // CareerGoals\n      const careerGoals = CareerGoals.findNonRetired();\n      _.forEach(careerGoals, (c) => {\n        const itemID = c._id;\n        const itemSlug = Slugs.getNameFromID(c.slugID);\n        const filtered = _.filter(students, (s) => FavoriteCareerGoals.findNonRetired({ studentID: s.userID, careerGoalID: itemID }).length > 0);\n        // console.log('students with careerGoal %o = %o', itemID, filtered);\n        const itemCount = filtered.length;\n        this.collection.upsert({ itemSlug }, { $set: { itemID, itemSlug, itemCount } });\n      });\n      // Interests\n      const interests = Interests.findNonRetired();\n      _.forEach(interests, (i) => {\n        const itemID = i._id;\n        const itemSlug = Slugs.getNameFromID(i.slugID);\n        const filterd = _.filter(students, (s) => _.includes(profileGetInterestIDs(s), itemID));\n        const itemCount = filterd.length;\n        this.collection.upsert({ itemSlug }, { $set: { itemID, itemSlug, itemCount } });\n      });\n    }\n  }\n}\n\nexport const StudentParticipations = new StudentParticipationCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/public-stats/StudentParticipationCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 918,
    "kind": "variable",
    "name": "StudentParticipations",
    "memberof": "api/public-stats/StudentParticipationCollection.ts",
    "static": true,
    "longname": "api/public-stats/StudentParticipationCollection.ts~StudentParticipations",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/public-stats/StudentParticipationCollection.ts",
    "importStyle": "{StudentParticipations}",
    "description": null,
    "lineNumber": 208,
    "undocument": true,
    "type": {
      "types": [
        "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection"
      ]
    }
  },
  {
    "__docId__": 919,
    "kind": "class",
    "name": "StudentParticipationCollection",
    "memberof": "api/public-stats/StudentParticipationCollection.ts",
    "static": true,
    "longname": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/public-stats/StudentParticipationCollection.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 20,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 920,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true
  },
  {
    "__docId__": 921,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection",
    "static": false,
    "longname": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 922,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection",
    "static": false,
    "longname": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 923,
    "kind": "method",
    "name": "define",
    "memberof": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection#define",
    "access": "public",
    "description": "Defines the enrollment data for the given item.",
    "lineNumber": 42,
    "params": [
      {
        "nullable": null,
        "types": [
          "IStudentParticipationDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 924,
    "kind": "method",
    "name": "update",
    "memberof": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection#update",
    "access": "public",
    "description": "Updates the enrollment data for the given item.",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IStudentParticipationUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 925,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection#removeIt",
    "access": "public",
    "description": "Removes the enrollment information.",
    "lineNumber": 72,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 926,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Only ADMINs can update the records.",
    "lineNumber": 82,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 927,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks itemID and itemSlug",
    "lineNumber": 92,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 928,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the StudentParticipation docID in a format acceptable to define().",
    "lineNumber": 119,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IStudentParticipationDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 929,
    "kind": "method",
    "name": "upsertEnrollmentData",
    "memberof": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/public-stats/StudentParticipationCollection.ts~StudentParticipationCollection#upsertEnrollmentData",
    "access": "public",
    "description": "",
    "lineNumber": 127,
    "params": [],
    "return": null
  },
  {
    "__docId__": 930,
    "kind": "file",
    "name": "api/public-stats/index.ts",
    "content": "/** @namespace api/public-stats */\nimport './PublicStatsCollection';\nimport './StudentParticipationCollection';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/public-stats/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 931,
    "kind": "file",
    "name": "api/radgrad/RadGrad.ts",
    "content": "import _ from 'lodash';\nimport { Meteor } from 'meteor/meteor';\nimport { AcademicPlans } from '../degree-plan/AcademicPlanCollection';\nimport { AcademicYearInstances } from '../degree-plan/AcademicYearInstanceCollection';\nimport { AdvisorLogs } from '../log/AdvisorLogCollection';\nimport { AdminProfiles } from '../user/AdminProfileCollection';\nimport { AdvisorProfiles } from '../user/AdvisorProfileCollection';\nimport { CareerGoals } from '../career/CareerGoalCollection';\nimport { StudentParticipations } from '../public-stats/StudentParticipationCollection';\nimport { Courses } from '../course/CourseCollection';\nimport { CourseInstances } from '../course/CourseInstanceCollection';\nimport { DesiredDegrees } from '../degree-plan/DesiredDegreeCollection';\nimport { FacultyProfiles } from '../user/FacultyProfileCollection';\nimport { FeedbackInstances } from '../feedback/FeedbackInstanceCollection';\nimport { Feeds } from '../feed/FeedCollection';\nimport { HelpMessages } from '../help/HelpMessageCollection';\nimport { IceSnapshots } from '../analytic/IceSnapshotCollection';\nimport { Interests } from '../interest/InterestCollection';\nimport { InterestTypes } from '../interest/InterestTypeCollection';\nimport { MentorAnswers } from '../mentor/MentorAnswerCollection';\nimport { MentorQuestions } from '../mentor/MentorQuestionCollection';\nimport { MentorProfiles } from '../user/MentorProfileCollection';\nimport { Opportunities } from '../opportunity/OpportunityCollection';\nimport { OpportunityInstances } from '../opportunity/OpportunityInstanceCollection';\nimport { OpportunityTypes } from '../opportunity/OpportunityTypeCollection';\nimport { PlanChoices } from '../degree-plan/PlanChoiceCollection';\nimport { PublicStats } from '../public-stats/PublicStatsCollection';\nimport { Reviews } from '../review/ReviewCollection';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { Slugs } from '../slug/SlugCollection';\nimport { StudentProfiles } from '../user/StudentProfileCollection';\nimport { Teasers } from '../teaser/TeaserCollection';\nimport { UserInteractions } from '../analytic/UserInteractionCollection';\nimport { VerificationRequests } from '../verification/VerificationRequestCollection';\nimport { FavoriteAcademicPlans } from '../favorite/FavoriteAcademicPlanCollection';\nimport { FavoriteCareerGoals } from '../favorite/FavoriteCareerGoalCollection';\nimport { FavoriteCourses } from '../favorite/FavoriteCourseCollection';\nimport { FavoriteInterests } from '../favorite/FavoriteInterestCollection';\nimport { FavoriteOpportunities } from '../favorite/FavoriteOpportunityCollection';\nimport { PageInterestsDailySnapshots } from '../page-tracking/PageInterestsDailySnapshotCollection';\nimport { PageInterests } from '../page-tracking/PageInterestCollection';\n\n/**\n * @memberOf api/radgrad\n */\nclass RadGradClass {\n  public collections: any[];\n  public collectionLoadSequence;\n  private readonly collectionAssociation;\n  public calcLevel?: (studentID: string) => any;\n\n  constructor() {\n    /**\n     * A list of all RadGrad API collections in alphabetical order.\n     * This list is used for things like checking integrity.\n     */\n    this.collections = [\n      AcademicPlans,\n      AcademicYearInstances,\n      AdminProfiles,\n      AdvisorLogs,\n      AdvisorProfiles,\n      CareerGoals,\n      StudentParticipations,\n      Courses,\n      CourseInstances,\n      FacultyProfiles,\n      FavoriteAcademicPlans,\n      FavoriteCareerGoals,\n      FavoriteCourses,\n      FavoriteInterests,\n      FavoriteOpportunities,\n      Feeds,\n      FeedbackInstances,\n      HelpMessages,\n      DesiredDegrees,\n      IceSnapshots,\n      Interests,\n      InterestTypes,\n      MentorAnswers,\n      MentorQuestions,\n      MentorProfiles,\n      Opportunities,\n      OpportunityInstances,\n      OpportunityTypes,\n      PageInterests,\n      PageInterestsDailySnapshots,\n      PlanChoices,\n      PublicStats,\n      Reviews,\n      AcademicTerms,\n      Slugs,\n      StudentProfiles,\n      Teasers,\n      UserInteractions,\n      VerificationRequests,\n    ];\n\n    /**\n     * A list of collection class instances in the order required for them to be sequentially loaded from a file.\n     * Note that some collection class instances are implicitly initialized and so do not appear in this list.\n     * This is the list used to specify the collections for both dump and restore.\n     * For example: Slugs, AcademicYearInstances, and PublicStats.\n     * Some collections are not yet part of dump/restore.\n     */\n    this.collectionLoadSequence = [\n      AcademicTerms,\n      HelpMessages,\n      InterestTypes,\n      Interests,\n      CareerGoals,\n      DesiredDegrees,\n      AcademicPlans,\n      AdminProfiles,\n      MentorProfiles,\n      AdvisorProfiles,\n      FacultyProfiles,\n      OpportunityTypes,\n      Opportunities,\n      Courses,\n      Teasers,\n      StudentProfiles,\n      CourseInstances,\n      OpportunityInstances,\n      FeedbackInstances,\n      VerificationRequests,\n      Feeds,\n      AdvisorLogs,\n      IceSnapshots,\n      UserInteractions,\n      PageInterests,\n      PageInterestsDailySnapshots,\n      MentorQuestions,\n      MentorAnswers,\n      Reviews,\n      PlanChoices,\n      FavoriteAcademicPlans,\n      FavoriteCareerGoals,\n      FavoriteCourses,\n      FavoriteInterests,\n      FavoriteOpportunities,\n    ];\n\n    /**\n     * An object with keys equal to the collection name and values the associated collection instance.\n     */\n    this.collectionAssociation = {};\n    _.forEach(this.collections, (collection) => {\n      this.collectionAssociation[collection.getCollectionName()] = collection;\n    });\n  }\n\n  /**\n   * Return the collection class instance given its name.\n   * @param collectionName The name of the collection.\n   * @returns The collection class instance.\n   * @throws { Meteor.Error } If collectionName does not name a collection.\n   */\n  public getCollection(collectionName) {\n    const collection = this.collectionAssociation[collectionName];\n    if (!collection) {\n      throw new Meteor.Error(`Called RadGrad.getCollection with unknown collection name: ${collectionName}`);\n    }\n    return collection;\n  }\n}\n\n/**\n * Provides the singleton instance of this class.\n * @type {api/radgrad.RadGradClass}\n * @memberOf api/radgrad\n */\nexport const RadGrad = new RadGradClass();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/radgrad/RadGrad.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 932,
    "kind": "variable",
    "name": "RadGrad",
    "memberof": "api/radgrad/RadGrad.ts",
    "static": true,
    "longname": "api/radgrad/RadGrad.ts~RadGrad",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/radgrad/RadGrad.ts",
    "importStyle": "{RadGrad}",
    "description": "Provides the singleton instance of this class.",
    "lineNumber": 171,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/radgrad"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/radgrad.RadGradClass"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 933,
    "kind": "class",
    "name": "RadGradClass",
    "memberof": "api/radgrad/RadGrad.ts",
    "static": true,
    "longname": "api/radgrad/RadGrad.ts~RadGradClass",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/radgrad/RadGrad.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 51,
    "pseudoExport": true,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/radgrad"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 934,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/radgrad/RadGrad.ts~RadGradClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/radgrad/RadGrad.ts~RadGradClass#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 52,
    "undocument": true
  },
  {
    "__docId__": 935,
    "kind": "member",
    "name": "collections",
    "memberof": "api/radgrad/RadGrad.ts~RadGradClass",
    "static": false,
    "longname": "api/radgrad/RadGrad.ts~RadGradClass#collections",
    "access": "public",
    "description": "A list of all RadGrad API collections in alphabetical order.\nThis list is used for things like checking integrity.",
    "lineNumber": 57,
    "type": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 936,
    "kind": "member",
    "name": "collectionLoadSequence",
    "memberof": "api/radgrad/RadGrad.ts~RadGradClass",
    "static": false,
    "longname": "api/radgrad/RadGrad.ts~RadGradClass#collectionLoadSequence",
    "access": "public",
    "description": "A list of collection class instances in the order required for them to be sequentially loaded from a file.\nNote that some collection class instances are implicitly initialized and so do not appear in this list.\nThis is the list used to specify the collections for both dump and restore.\nFor example: Slugs, AcademicYearInstances, and PublicStats.\nSome collections are not yet part of dump/restore.",
    "lineNumber": 105,
    "type": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 937,
    "kind": "member",
    "name": "collectionAssociation",
    "memberof": "api/radgrad/RadGrad.ts~RadGradClass",
    "static": false,
    "longname": "api/radgrad/RadGrad.ts~RadGradClass#collectionAssociation",
    "access": "public",
    "description": "An object with keys equal to the collection name and values the associated collection instance.",
    "lineNumber": 145,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 938,
    "kind": "method",
    "name": "getCollection",
    "memberof": "api/radgrad/RadGrad.ts~RadGradClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/radgrad/RadGrad.ts~RadGradClass#getCollection",
    "access": "public",
    "description": "Return the collection class instance given its name.",
    "lineNumber": 159,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "collectionName",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 939,
    "kind": "file",
    "name": "api/radgrad/RadGradProperties.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport { IBaseProfile } from '../../typings/radgrad';\n\n/**\n * Properties to configure RadGrad for different institutions.\n */\nclass RadGradPropertiesClass {\n  /**\n   * Returns true if using quarters, false if using semesters.\n   * @return true if using quarters, false if using semesters.\n   */\n  public getQuarterSystem(): boolean {\n    return _.has(Meteor, 'settings.public.RadGrad.quarterSystem') ? Meteor.settings.public.RadGrad.quarterSystem : false;\n  }\n\n  public getAdminProfile(): IBaseProfile {\n    return _.has(Meteor, 'settings.public.RadGrad.adminProfile') ? Meteor.settings.public.RadGrad.adminProfile : {\n      username: 'radgrad@hawaii.edu',\n      firstName: 'RadGrad',\n      lastName: 'Admin',\n    };\n  }\n\n  /**\n   * Returns the RadGrad admin email address.\n   * @return the RadGrad admin email address.\n   */\n  public getAdminEmail(): string {\n    return _.has(Meteor, 'settings.public.RadGrad.adminProfile.username') ? Meteor.settings.public.RadGrad.adminProfile.username : 'radgrad@hawaii.edu';\n  }\n\n  /**\n   * Returns the email domain.\n   * @return the email domain.\n   */\n  public getEmailDomain(): string {\n    return _.has(Meteor, 'settings.public.RadGrad.emailDomain') ? Meteor.settings.public.RadGrad.emailDomain : 'hawaii.edu';\n  }\n\n  /**\n   * Returns the newsletter from address.\n   * @return the newsletter from address.\n   */\n  public getNewsletterFrom(): string {\n    return _.has(Meteor, 'settings.public.RadGrad.newsletterFrom') ? Meteor.settings.public.RadGrad.newsletterFrom : 'Phillip Johnson <donotreply@mail.gun.radgrad.org>';\n  }\n\n  // public getFallSemesterStartDate(): Date {\n  //\n  // }\n  //\n  // public getFallSemesterEndDate(): Date {\n  //\n  // }\n  //\n  // public getSummerSemesterStartDate(): Date {\n  //\n  // }\n  //\n  // public getSummerSemesterEndDate(): Date {\n  //\n  // }\n  //\n  // public getSpringSemesterStartDate(): Date {\n  //\n  // }\n  //\n  // public getSpringSemesterEndDate(): Date {\n  //\n  // }\n}\n\nexport const RadGradProperties = new RadGradPropertiesClass();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/radgrad/RadGradProperties.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 940,
    "kind": "variable",
    "name": "RadGradProperties",
    "memberof": "api/radgrad/RadGradProperties.ts",
    "static": true,
    "longname": "api/radgrad/RadGradProperties.ts~RadGradProperties",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/radgrad/RadGradProperties.ts",
    "importStyle": "{RadGradProperties}",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "type": {
      "types": [
        "api/radgrad/RadGradProperties.ts~RadGradPropertiesClass"
      ]
    }
  },
  {
    "__docId__": 941,
    "kind": "class",
    "name": "RadGradPropertiesClass",
    "memberof": "api/radgrad/RadGradProperties.ts",
    "static": true,
    "longname": "api/radgrad/RadGradProperties.ts~RadGradPropertiesClass",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/radgrad/RadGradProperties.ts",
    "importStyle": null,
    "description": "Properties to configure RadGrad for different institutions.",
    "lineNumber": 8,
    "pseudoExport": true,
    "interface": false
  },
  {
    "__docId__": 942,
    "kind": "method",
    "name": "getQuarterSystem",
    "memberof": "api/radgrad/RadGradProperties.ts~RadGradPropertiesClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/radgrad/RadGradProperties.ts~RadGradPropertiesClass#getQuarterSystem",
    "access": "public",
    "description": "Returns true if using quarters, false if using semesters.",
    "lineNumber": 13,
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 943,
    "kind": "method",
    "name": "getAdminProfile",
    "memberof": "api/radgrad/RadGradProperties.ts~RadGradPropertiesClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/radgrad/RadGradProperties.ts~RadGradPropertiesClass#getAdminProfile",
    "access": "public",
    "description": "",
    "lineNumber": 17,
    "return": {
      "nullable": null,
      "types": [
        "IBaseProfile"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 944,
    "kind": "method",
    "name": "getAdminEmail",
    "memberof": "api/radgrad/RadGradProperties.ts~RadGradPropertiesClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/radgrad/RadGradProperties.ts~RadGradPropertiesClass#getAdminEmail",
    "access": "public",
    "description": "Returns the RadGrad admin email address.",
    "lineNumber": 29,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 945,
    "kind": "method",
    "name": "getEmailDomain",
    "memberof": "api/radgrad/RadGradProperties.ts~RadGradPropertiesClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/radgrad/RadGradProperties.ts~RadGradPropertiesClass#getEmailDomain",
    "access": "public",
    "description": "Returns the email domain.",
    "lineNumber": 37,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 946,
    "kind": "method",
    "name": "getNewsletterFrom",
    "memberof": "api/radgrad/RadGradProperties.ts~RadGradPropertiesClass",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/radgrad/RadGradProperties.ts~RadGradPropertiesClass#getNewsletterFrom",
    "access": "public",
    "description": "Returns the newsletter from address.",
    "lineNumber": 45,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 947,
    "kind": "file",
    "name": "api/radgrad/index.ts",
    "content": "/** @namespace api/radgrad */\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/radgrad/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 948,
    "kind": "file",
    "name": "api/review/ReviewCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { Reviews } from './ReviewCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('ReviewCollection Meteor Methods ', function test() {\n    const collectionName = Reviews.getCollectionName();\n    // Note that we allow the slug to be defined by default.\n    const definitionData = {\n      student: 'abi@hawaii.edu',\n      reviewType: 'course',\n      reviewee: 'ics_111',\n      academicTerm: 'Fall-2016',\n      rating: 3,\n      comments: 'This is great!',\n    };\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal', 'abi.student'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      await defineMethod.callPromise({ collectionName, definitionData });\n    });\n\n    it('Update Method', async function () {\n      const id = Reviews.findIdBySlug('review-course-ics_111-abi@hawaii.edu');\n      const rating = 5;\n      const comments = 'new comments';\n      await updateMethod.callPromise({ collectionName, updateData: { id, rating, comments } });\n    });\n\n    it('Remove Method', async function () {\n      const id = Reviews.findIdBySlug('review-course-ics_111-abi@hawaii.edu');\n      await removeItMethod.callPromise({ collectionName, instance: id });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/review/ReviewCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 949,
    "kind": "file",
    "name": "api/review/ReviewCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport { IReview, ReviewRatings } from '../../typings/radgrad';\nimport { makeSampleAcademicTerm } from '../academic-term/SampleAcademicTerms';\nimport { makeSampleCourse } from '../course/SampleCourses';\nimport { ROLE } from '../role/Role';\nimport { Reviews } from './ReviewCollection';\nimport { makeSampleOpportunity } from '../opportunity/SampleOpportunities';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { ReviewTypes } from './ReviewTypes';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('ReviewCollection', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(25000);\n      fc.assert(\n        fc.property(fc.lorem(1), fc.boolean(), fc.integer(1, 5), fc.lorem(10), (fcSlug, cOrO, fcRating, fcComments) => {\n          let reviewType;\n          const reviewRating: ReviewRatings = fcRating as ReviewRatings;\n          let reviewee;\n          const academicTerm = makeSampleAcademicTerm();\n          const student: string = makeSampleUser();\n          if (cOrO) {\n            reviewType = ReviewTypes.COURSE;\n            reviewee = makeSampleCourse();\n          } else {\n            reviewType = ReviewTypes.OPPORTUNITY;\n            const sponsor = makeSampleUser(ROLE.FACULTY);\n            reviewee = makeSampleOpportunity(sponsor);\n          }\n          const docID = Reviews.define({\n            slug: fcSlug,\n            student,\n            reviewType,\n            reviewee,\n            academicTerm,\n            rating: reviewRating,\n            comments: fcComments,\n          });\n          expect(Reviews.isDefined(docID)).to.be.true;\n          Reviews.removeIt(docID);\n          expect(Reviews.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Can not define duplicates', function test2(done) {\n      const slug: string = faker.lorem.word();\n      const student: string = makeSampleUser();\n      const reviewType = ReviewTypes.OPPORTUNITY;\n      const faculty: string = makeSampleUser(ROLE.FACULTY);\n      const reviewee: string = makeSampleOpportunity(faculty);\n      const academicTerm = makeSampleAcademicTerm();\n      const rating: ReviewRatings = 2;\n      const comments = faker.lorem.paragraph();\n      Reviews.define({\n        slug,\n        student,\n        reviewType,\n        reviewee,\n        academicTerm,\n        rating,\n        comments,\n      });\n      expect(() => Reviews.define({\n        slug,\n        student,\n        reviewType,\n        reviewee,\n        academicTerm,\n        rating,\n        comments,\n      })).to.throw(Error);\n      done();\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      let doc = Reviews.findOne({});\n      const docID = doc._id;\n      fc.assert(\n        fc.property(fc.integer(1, 5), fc.lorem(10), fc.boolean(), fc.boolean(), fc.lorem(10), fc.boolean(), (rating, comments, moderated, visible, moderatorComments, retired) => {\n          const academicTerm = makeSampleAcademicTerm();\n          // @ts-ignore\n          Reviews.update(docID, { academicTerm, comments, moderated, visible, rating, retired, moderatorComments });\n          doc = Reviews.findDoc(docID);\n          expect(doc.comments).to.equal(comments);\n          expect(doc.moderated).to.equal(moderated);\n          expect(doc.visible).to.equal(visible);\n          expect(doc.rating).to.equal(rating);\n          expect(doc.retired).to.equal(retired);\n          expect(doc.moderatorComments).to.equal(moderatorComments);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      const origDoc = Reviews.findOne({});\n      let docID = origDoc._id;\n      const dumpObject = Reviews.dumpOne(docID);\n      Reviews.removeIt(docID);\n      expect(Reviews.isDefined(docID)).to.be.false;\n      docID = Reviews.restoreOne(dumpObject);\n      const restored: IReview = Reviews.findDoc(docID);\n      expect(restored.comments).to.equal(origDoc.comments);\n      expect(restored.reviewType).to.equal(origDoc.reviewType);\n      expect(restored.moderated).to.equal(origDoc.moderated);\n      expect(restored.visible).to.equal(origDoc.visible);\n      expect(restored.moderatorComments).to.equal(origDoc.moderatorComments);\n      expect(restored.retired).to.equal(origDoc.retired);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const problems = Reviews.checkIntegrity();\n      expect(problems.length).to.equal(0);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/review/ReviewCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 950,
    "kind": "file",
    "name": "api/review/ReviewCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport SimpleSchema from 'simpl-schema';\nimport { ROLE } from '../role/Role';\nimport { Slugs } from '../slug/SlugCollection';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { Opportunities } from '../opportunity/OpportunityCollection';\nimport { Users } from '../user/UserCollection';\nimport { Courses } from '../course/CourseCollection';\nimport BaseSlugCollection from '../base/BaseSlugCollection';\nimport { IReviewDefine, IReviewUpdate, IReviewUpdateData } from '../../typings/radgrad';\n\n/**\n * Represents a course or opportunity review by a student.\n * @extends api/base.BaseSlugCollection\n * @memberOf api/review\n */\nclass ReviewCollection extends BaseSlugCollection {\n  public COURSE: string;\n  public OPPORTUNITY: string;\n\n  /**\n   * Creates the Review collection.\n   */\n  constructor() {\n    super('Review', new SimpleSchema({\n      slugID: { type: SimpleSchema.RegEx.Id },\n      studentID: { type: SimpleSchema.RegEx.Id },\n      reviewType: { type: String },\n      revieweeID: { type: SimpleSchema.RegEx.Id },\n      termID: { type: SimpleSchema.RegEx.Id },\n      rating: { type: SimpleSchema.Integer },\n      comments: { type: String },\n      moderated: { type: Boolean },\n      visible: { type: Boolean },\n      moderatorComments: { type: String, optional: true },\n      retired: { type: Boolean, optional: true },\n    }));\n    this.COURSE = 'course';\n    this.OPPORTUNITY = 'opportunity';\n    this.defineSchema = new SimpleSchema({\n      slug: String,\n      student: String,\n      reviewType: String,\n      reviewee: String,\n      academicTerm: String,\n      rating: { type: SimpleSchema.Integer, optional: true },\n      comments: String,\n      moderated: { type: Boolean, optional: true },\n      visible: { type: Boolean, optional: true },\n      moderatorComments: { type: String, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n    this.updateSchema = new SimpleSchema({\n      academicTerm: { type: String, optional: true },\n      rating: { type: SimpleSchema.Integer, optional: true },\n      comments: { type: String, optional: true },\n      moderated: { type: Boolean, optional: true },\n      visible: { type: Boolean, optional: true },\n      moderatorComments: { type: String, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines a new Review.\n   * @example\n   * Review.define({ slug: 'review-course-ics_111-abi',\n   *                 student: 'abi@hawaii.edu',\n   *                 reviewType: 'course',\n   *                 reviewee: 'ics_111',\n   *                 academicTerm: 'Fall-2016',\n   *                 rating: 3,\n   *                 comments: 'This class is great!',\n   *                 moderated: false,\n   *                 visible: true,\n   *                 moderatedComments: 'sample comments here',\n   *                 retired: false});\n   * @param { Object } description Object with keys slug, student, reviewee,\n   * reviewType,academicTerm, rating, comments, moderated, public, and moderatorComments.\n   * Slug is optional. If supplied, must not be previously defined.\n   * Student must be a user with role 'STUDENT.'\n   * ReviewType must be either 'course' or 'opportunity'.\n   * Reviewee must be a defined course or opportunity slug, depending upon reviewType.\n   * academicTerm must be a defined slug.\n   * Moderated is optional and defaults to false.\n   * Visible is optional and defaults to true.\n   * ModeratorComments is optional.\n   * @throws {Meteor.Error} If the definition includes a defined slug, undefined student,\n   * undefined reviewee, undefined academicTerm, or invalid rating.\n   * @returns The newly created docID.\n   */\n  public define({ slug, student, reviewType, reviewee, academicTerm, rating = 3, comments, moderated = false, visible = true, moderatorComments, retired = false }: IReviewDefine) {\n    // Validate student, get studentID.\n    const studentID = Users.getID(student);\n    Users.assertInRole(studentID, [ROLE.STUDENT, ROLE.ALUMNI]);\n    // Validate reviewType, get revieweeID and assign slug if not provided.\n    this.assertValidReviewType(reviewType);\n    let revieweeID;\n    if (reviewType === this.COURSE) {\n      revieweeID = Courses.getID(reviewee);\n      if (!slug) {\n        slug = `review-course-${Courses.findSlugByID(revieweeID)}-${Users.getProfile(studentID).username}`; // eslint-disable-line no-param-reassign\n      }\n    } else if (reviewType === this.OPPORTUNITY) {\n      revieweeID = Opportunities.getID(reviewee);\n      if (!slug) {\n        slug = `review-opportunity-${Opportunities.findSlugByID(revieweeID)}-${Users.getProfile(studentID).username}`; // eslint-disable-line no-param-reassign\n      }\n    }\n    // Validate academicTerm, get termID.\n    const termID = AcademicTerms.getID(academicTerm);\n    // Validate rating.\n    this.assertValidRating(rating);\n    // Guarantee that moderated and public are booleans.\n    moderated = !!moderated; // eslint-disable-line no-param-reassign\n    visible = !!visible; // eslint-disable-line no-param-reassign\n    // Get SlugID, throw error if found.\n    const slugID = Slugs.define({ name: slug, entityName: this.getType() });\n    // Define the new Review and its Slug.\n    const reviewID = this.collection.insert({\n      slugID,\n      studentID,\n      reviewType,\n      revieweeID,\n      termID,\n      rating,\n      comments,\n      moderated,\n      visible,\n      moderatorComments,\n      retired,\n    });\n    Slugs.updateEntityID(slugID, reviewID);\n    // Return the id to the newly created Review.\n    return reviewID;\n  }\n\n  /**\n   * Throws an error if rating is not an integer between 1 and 5.\n   * @param rating the rating.\n   */\n  public assertValidRating(rating: number) {\n    if (!_.isInteger(rating) || !_.inRange(rating, 1, 6)) {\n      throw new Meteor.Error(`Invalid rating: ${rating}`);\n    }\n  }\n\n  /**\n   * Throws an error if reviewType is not 'opportunity' or 'collection'.\n   * @param reviewType The review type.\n   */\n  public assertValidReviewType(reviewType: string) {\n    if (!_.includes([this.OPPORTUNITY, this.COURSE], reviewType)) {\n      throw new Meteor.Error(`Invalid reviewType: ${reviewType}`);\n    }\n  }\n\n  /**\n   * Update the review. Only academicTerm, rating, comments, moderated, visible, and moderatorComments can be updated.\n   * @param docID The review docID (required).\n   */\n  public update(docID, { academicTerm, rating, comments, moderated, visible, moderatorComments, retired }: IReviewUpdate) {\n    this.assertDefined(docID);\n    const updateData: IReviewUpdateData = {};\n    if (academicTerm) {\n      updateData.termID = AcademicTerms.getID(academicTerm);\n    }\n    if (_.isNumber(rating)) {\n      this.assertValidRating(rating);\n      updateData.rating = rating;\n    }\n    if (comments) {\n      updateData.comments = comments;\n    }\n    if (_.isBoolean(moderated)) {\n      updateData.moderated = moderated;\n    }\n    if (_.isBoolean(visible)) {\n      updateData.visible = !!visible;\n    }\n    if (moderatorComments) {\n      updateData.moderatorComments = moderatorComments;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the review.\n   * @param docID The docID of the review.\n   */\n  public removeIt(docID: string) {\n    this.assertDefined(docID);\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\n   * Student.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.STUDENT]);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks slugID, opportunityTypeID, sponsorID, interestIDs, termIDs\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (!Slugs.isDefined(doc.slugID)) {\n        problems.push(`Bad slugID: ${doc.slugID}`);\n      }\n      if (!Users.isDefined(doc.studentID)) {\n        problems.push(`Bad studentID: ${doc.studentID}`);\n      }\n      if (!Opportunities.isDefined(doc.revieweeID) && !Courses.isDefined(doc.revieweeID)) {\n        problems.push(`Bad reviewee: ${doc.revieweeID}`);\n      }\n      if (!AcademicTerms.isDefined(doc.termID)) {\n        problems.push(`Bad studentID: ${doc.termID}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Updates the Review's modified, visible, and moderatorComments variables.\n   * @param reviewID The review ID.\n   * @param moderated The new moderated value.\n   * @param visible The new visible value.\n   * @param moderatorComments The new moderatorComments value.\n   */\n  public updateModerated(reviewID: string, moderated: boolean, visible: boolean, moderatorComments: string) {\n    this.assertDefined(reviewID);\n    this.collection.update({ _id: reviewID },\n      { $set: { moderated, visible, moderatorComments } });\n  }\n\n  /**\n   * Returns an object representing the Review docID in a format acceptable to define().\n   * @param docID The docID of an Review.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IReviewDefine {\n    const doc = this.findDoc(docID);\n    const slug = Slugs.getNameFromID(doc.slugID);\n    const student = Users.getProfile(doc.studentID).username;\n    const reviewType = doc.reviewType;\n    let reviewee;\n    if (reviewType === this.COURSE) {\n      reviewee = Courses.findSlugByID(doc.revieweeID);\n    } else if (reviewType === this.OPPORTUNITY) {\n      reviewee = Opportunities.findSlugByID(doc.revieweeID);\n    }\n    const academicTerm = AcademicTerms.findSlugByID(doc.termID);\n    const rating = doc.rating;\n    const comments = doc.comments;\n    const moderated = doc.moderated;\n    const visible = doc.visible;\n    const moderatorComments = doc.moderatorComments;\n    const retired = doc.retired;\n    return {\n      slug,\n      student,\n      reviewType,\n      reviewee,\n      academicTerm,\n      rating,\n      comments,\n      moderated,\n      visible,\n      moderatorComments,\n      retired,\n    };\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @type {api/review.ReviewCollection}\n * @memberOf api/review\n */\nexport const Reviews = new ReviewCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/review/ReviewCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 951,
    "kind": "variable",
    "name": "Reviews",
    "memberof": "api/review/ReviewCollection.ts",
    "static": true,
    "longname": "api/review/ReviewCollection.ts~Reviews",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/review/ReviewCollection.ts",
    "importStyle": "{Reviews}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 295,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/review"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/review.ReviewCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 952,
    "kind": "class",
    "name": "ReviewCollection",
    "memberof": "api/review/ReviewCollection.ts",
    "static": true,
    "longname": "api/review/ReviewCollection.ts~ReviewCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/review/ReviewCollection.ts",
    "importStyle": null,
    "description": "Represents a course or opportunity review by a student.",
    "lineNumber": 18,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseSlugCollection.js~BaseSlugCollection"
    ]
  },
  {
    "__docId__": 953,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/review/ReviewCollection.ts~ReviewCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/review/ReviewCollection.ts~ReviewCollection#constructor",
    "access": "public",
    "description": "Creates the Review collection.",
    "lineNumber": 21
  },
  {
    "__docId__": 954,
    "kind": "member",
    "name": "COURSE",
    "memberof": "api/review/ReviewCollection.ts~ReviewCollection",
    "static": false,
    "longname": "api/review/ReviewCollection.ts~ReviewCollection#COURSE",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 955,
    "kind": "member",
    "name": "OPPORTUNITY",
    "memberof": "api/review/ReviewCollection.ts~ReviewCollection",
    "static": false,
    "longname": "api/review/ReviewCollection.ts~ReviewCollection#OPPORTUNITY",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 956,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/review/ReviewCollection.ts~ReviewCollection",
    "static": false,
    "longname": "api/review/ReviewCollection.ts~ReviewCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 957,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/review/ReviewCollection.ts~ReviewCollection",
    "static": false,
    "longname": "api/review/ReviewCollection.ts~ReviewCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 958,
    "kind": "method",
    "name": "define",
    "memberof": "api/review/ReviewCollection.ts~ReviewCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/review/ReviewCollection.ts~ReviewCollection#define",
    "access": "public",
    "description": "Defines a new Review.",
    "lineNumber": 93,
    "params": [
      {
        "nullable": null,
        "types": [
          "IReviewDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 959,
    "kind": "method",
    "name": "assertValidRating",
    "memberof": "api/review/ReviewCollection.ts~ReviewCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/review/ReviewCollection.ts~ReviewCollection#assertValidRating",
    "access": "public",
    "description": "Throws an error if rating is not an integer between 1 and 5.",
    "lineNumber": 143,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "rating",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 960,
    "kind": "method",
    "name": "assertValidReviewType",
    "memberof": "api/review/ReviewCollection.ts~ReviewCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/review/ReviewCollection.ts~ReviewCollection#assertValidReviewType",
    "access": "public",
    "description": "Throws an error if reviewType is not 'opportunity' or 'collection'.",
    "lineNumber": 153,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "reviewType",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 961,
    "kind": "method",
    "name": "update",
    "memberof": "api/review/ReviewCollection.ts~ReviewCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/review/ReviewCollection.ts~ReviewCollection#update",
    "access": "public",
    "description": "Update the review. Only academicTerm, rating, comments, moderated, visible, and moderatorComments can be updated.",
    "lineNumber": 163,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IReviewUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 962,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/review/ReviewCollection.ts~ReviewCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/review/ReviewCollection.ts~ReviewCollection#removeIt",
    "access": "public",
    "description": "Remove the review.",
    "lineNumber": 195,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 963,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/review/ReviewCollection.ts~ReviewCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/review/ReviewCollection.ts~ReviewCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\nStudent.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 207,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 964,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/review/ReviewCollection.ts~ReviewCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/review/ReviewCollection.ts~ReviewCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks slugID, opportunityTypeID, sponsorID, interestIDs, termIDs",
    "lineNumber": 217,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 965,
    "kind": "method",
    "name": "updateModerated",
    "memberof": "api/review/ReviewCollection.ts~ReviewCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/review/ReviewCollection.ts~ReviewCollection#updateModerated",
    "access": "public",
    "description": "Updates the Review's modified, visible, and moderatorComments variables.",
    "lineNumber": 243,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "reviewID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "moderated",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "visible",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "moderatorComments",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 966,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/review/ReviewCollection.ts~ReviewCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/review/ReviewCollection.ts~ReviewCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the Review docID in a format acceptable to define().",
    "lineNumber": 254,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IReviewDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 967,
    "kind": "file",
    "name": "api/review/ReviewTypes.ts",
    "content": "export enum ReviewTypes {\n  COURSE = 'course',\n  OPPORTUNITY = 'opportunity',\n}\n\nexport type IReviewTypes = ReviewTypes.COURSE | ReviewTypes.OPPORTUNITY;\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/review/ReviewTypes.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 968,
    "kind": "file",
    "name": "api/review/index.ts",
    "content": "/** @namespace api/review */\nimport './ReviewCollection';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/review/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 969,
    "kind": "file",
    "name": "api/role/Role.test.ts",
    "content": "import { expect } from 'chai';\nimport { Roles } from 'meteor/alanning:roles';\nimport { Meteor } from 'meteor/meteor';\nimport {} from 'mocha';\nimport { assertRole, isRole, ROLE } from './Role';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('Role', function testSuite() {\n    it('Test role definitions, isRole', function test() {\n      expect(Roles.getAllRoles().fetch()).to.have.lengthOf(6);\n      expect(isRole(ROLE.FACULTY)).to.be.true;\n      expect(isRole('Grad Student')).to.be.false;\n    });\n\n    it('assertRole', function test() {\n      expect(function foo() { assertRole(ROLE.STUDENT); }).to.not.throw(Error);\n      expect(function foo() { assertRole('foo'); }).to.throw(Error);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/role/Role.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 970,
    "kind": "file",
    "name": "api/role/Role.ts",
    "content": "import { Roles } from 'meteor/alanning:roles';\nimport _ from 'lodash';\nimport { Meteor } from 'meteor/meteor';\n\n/** Defines the legal strings used to represent roles in the system. */\n\n/**\n * ROLE Provides ROLE.FACULTY, ROLE.STUDENT, ROLE.ADMIN, ROLE.ALUMNI.\n * @type { Object }\n * @memberOf api/role\n */\nexport const ROLE = {\n  FACULTY: 'FACULTY',\n  STUDENT: 'STUDENT',\n  ADMIN: 'ADMIN',\n  ALUMNI: 'ALUMNI',\n  ADVISOR: 'ADVISOR',\n  MENTOR: 'MENTOR',\n};\n\n/**\n * The valid Roles in RadGrad.\n * @type {Array}\n * @memberOf api/role\n */\nexport const ROLES = _.values(ROLE);\n\n/**\n * Predicate for determining if a string is a defined ROLE.\n * @param { String } role The role.\n * @returns {boolean} True if role is a defined ROLE.\n * @memberOf api/role\n */\nexport function isRole(role) {\n  return (typeof role) === 'string' && _.includes(_.values(ROLE), role);\n}\n\n/**\n * Ensures that role(s) are valid roles.\n * @param role The role or an array of roles.\n * @throws { Meteor.Error } If any of role(s) are not valid.\n * @memberOf api/role\n */\nexport function assertRole(role) {\n  const roleArray = (Array.isArray(role)) ? role : [role];\n  roleArray.forEach((theRole) => {\n    if (!isRole(theRole)) {\n      throw new Meteor.Error(`${role} is not defined, or includes at least one undefined role.`);\n    }\n  });\n}\n\n// Initialize Roles to ROLENAMES by deleting all existing roles, then defining just those in ROLENAMES.\n\nif (Meteor.isServer) {\n  const allDefinedRoles = Roles.getAllRoles().fetch();\n  const definedRoleNames = _.map(allDefinedRoles, (role) => role.name);\n  _.values(ROLE).forEach((role) => {\n    if (!_.includes(definedRoleNames, role)) {\n      Roles.createRole(role, { unlessExists: true });\n    }\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/role/Role.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 971,
    "kind": "variable",
    "name": "ROLE",
    "memberof": "api/role/Role.ts",
    "static": true,
    "longname": "api/role/Role.ts~ROLE",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/role/Role.ts",
    "importStyle": "{ROLE}",
    "description": "ROLE Provides ROLE.FACULTY, ROLE.STUDENT, ROLE.ADMIN, ROLE.ALUMNI.",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/role"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        " Object "
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 972,
    "kind": "variable",
    "name": "ROLES",
    "memberof": "api/role/Role.ts",
    "static": true,
    "longname": "api/role/Role.ts~ROLES",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/role/Role.ts",
    "importStyle": "{ROLES}",
    "description": "The valid Roles in RadGrad.",
    "lineNumber": 23,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/role"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 973,
    "kind": "function",
    "name": "isRole",
    "memberof": "api/role/Role.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/role/Role.ts~isRole",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/role/Role.ts",
    "importStyle": "{isRole}",
    "description": "Predicate for determining if a string is a defined ROLE.",
    "lineNumber": 34,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "role",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 974,
    "kind": "function",
    "name": "assertRole",
    "memberof": "api/role/Role.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/role/Role.ts~assertRole",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/role/Role.ts",
    "importStyle": "{assertRole}",
    "description": "Ensures that role(s) are valid roles.",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "role",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 975,
    "kind": "file",
    "name": "api/role/index.ts",
    "content": "/** @namespace api/role */\nimport './Role';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/role/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 976,
    "kind": "file",
    "name": "api/slug/SlugCollection.test.ts",
    "content": "import { expect } from 'chai';\nimport { Meteor } from 'meteor/meteor';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport slugify, { Slugs } from './SlugCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('SlugCollection', function testSuite() {\n\n    before(function setup() {\n      removeAllEntities();\n      Slugs.removeAll();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n      Slugs.removeAll();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(25000);\n      fc.assert(\n        fc.property(fc.lorem(3), fc.lorem(1), (fcSlugName, fcEntityName) => {\n          const slugName = slugify(fcSlugName);\n          const docID = Slugs.define({ name: slugName, entityName: fcEntityName });\n          expect(Slugs.isDefined(docID)).to.be.true;\n          expect(Slugs.isSlugForEntity(slugName, fcEntityName)).to.be.true;\n          Slugs.removeIt(docID);\n          expect(Slugs.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Can not define duplicates', function test2() {\n      const lName: string = faker.lorem.word();\n      const lEntityName = faker.lorem.word();\n      const docID = Slugs.define({ name: lName, entityName: lEntityName });\n      expect(Slugs.isDefined(docID)).to.be.true;\n      expect(() => Slugs.define({ name: lName, entityName: lEntityName })).to.throw(Error);\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      const origDoc = Slugs.findOne({});\n      let docID = origDoc._id;\n      const dumpObject = Slugs.dumpOne(docID);\n      Slugs.removeIt(docID);\n      expect(Slugs.isDefined(docID)).to.be.false;\n      docID = Slugs.restoreOne(dumpObject);\n      expect(Slugs.isDefined(docID)).to.be.true;\n      const restored = Slugs.findDoc(docID);\n      expect(restored.name).to.equal(origDoc.name);\n      expect(restored.entityName).to.equal(origDoc.entityName);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const errors = Slugs.checkIntegrity();\n      expect(errors).to.have.lengthOf(0);\n    });\n\n    it('#isValidSlugName', function test() {\n      expect(Slugs.isValidSlugName('slug123')).to.be.true;\n      expect(Slugs.isValidSlugName('slug-123')).to.be.true;\n      expect(Slugs.isValidSlugName('Slug-123')).to.be.true;\n      expect(Slugs.isValidSlugName('slug-123#')).to.be.false;\n      expect(Slugs.isValidSlugName('slug 123')).to.be.false;\n      expect(Slugs.isValidSlugName('slug_123')).to.be.true;\n      expect(Slugs.isValidSlugName('')).to.be.false;\n      // expect(Slugs.isValidSlugName(12)).to.be.false;\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/slug/SlugCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 977,
    "kind": "file",
    "name": "api/slug/SlugCollection.ts",
    "content": "import { check } from 'meteor/check';\nimport { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport BaseCollection from '../base/BaseCollection';\nimport { ISlugDefine } from '../../typings/radgrad';\n\n/**\n * Slugifies the give text.\n * @param text\n * @return {string}\n * @memberOf api/slug\n */\nexport default function slugify(text) {\n  return text.toString().toLowerCase()\n    .replace(/\\s+/g, '-') // Replace spaces with -\n    .replace(/[^\\w-]+/g, '') // Remove all non-word chars\n    .replace(/--+/g, '-') // Replace multiple - with single -\n    .replace(/^-+/, '') // Trim - from start of text\n    .replace(/-+$/, ''); // Trim - from end of text\n}\n\n/**\n * Slugs are unique strings that can be used to identify entities and can be used in URLs.\n * @extends api/base.BaseCollection\n * @memberOf api/slug\n */\nclass SlugCollection extends BaseCollection {\n\n  /**\n   * Creates the Slug collection.\n   */\n  constructor() {\n    super('Slug', new SimpleSchema({\n      entityID: { type: SimpleSchema.RegEx.Id, optional: true },\n      entityName: { type: String },\n      name: { type: String },\n    }));\n    if (Meteor.isServer) {\n      this.collection.rawCollection().createIndex({ name: 1, entityName: 1 });\n    }\n\n  }\n\n  /**\n   * Creates a new Slug instance and adds it to the collection.\n   * @example\n   * Slugs.define({ name: 'software-engineering', entityName: 'Interest' });\n   * @param { String } name The name of the slug. Must be globally unique across all entities.\n   * @param { String } entityName The entity it is associated with.\n   * @returns { String } The docID of the created Slug.\n   * @throws { Meteor.Error } If the slug already exists.\n   */\n  public define({ name, entityName }: ISlugDefine) {\n    check(name, String); // TODO: Do we need this? I don't think so, Typescript ensures the type.\n    check(entityName, String);\n    if (super.isDefined(name)) {\n      throw new Meteor.Error(`Attempt to redefine slug: ${name}`);\n    }\n    if (!this.isValidSlugName(name)) {\n      throw new Meteor.Error(`Slug is not a-zA-Z0-9 or dash, period, underscore, or @: ${name}`);\n    }\n    const docID = this.collection.insert({ name, entityName });\n    return docID;\n  }\n\n  /**\n   * Returns true if slugName is syntactically valid (i.e. consists of a-zA-Z0-9 or dash or underscore.)\n   * @param slugName The slug name.\n   * @returns {boolean} True if it's OK.\n   */\n  public isValidSlugName(slugName: string) {\n    const slugRegEx = new RegExp('^[a-zA-Z0-9@.]+(?:[_-][a-zA-Z0-9@.]+)*$');\n    return (typeof slugName === 'string') && slugName.length > 0 && slugRegEx.test(slugName);\n  }\n\n  /**\n   * Updates a Slug with the docID of the associated entity.\n   * @param { String } slugID The docID of this Slug.\n   * @param { String } entityID The docID of the entity to be associated with this Slug.\n   */\n  public updateEntityID(slugID: string, entityID: string) {\n    this.collection.update(slugID, { $set: { entityID } });\n  }\n\n  /**\n   * Returns the docID of the entity associated with this Slug.\n   * @param { String } slugName The slug name or docID.\n   * @param { String } entityName The entity type expected.\n   * @returns { String } The docID of the entity.\n   * @throws { Meteor.Error } If the slug or entity cannot be found or is the wrong type.\n   */\n  public getEntityID(slugName: string, entityName: string) {\n    if (!this.isDefined(slugName)) {\n      throw new Meteor.Error(`Undefined slug ${slugName}.`);\n    }\n    const doc = this.findDoc(slugName);\n    if (doc.entityName !== entityName) {\n      throw new Meteor.Error(`Slug ${slugName} is not associated with the entity ${entityName}.`);\n    }\n    return doc.entityID;\n  }\n\n  /**\n   * Returns true if slugName is a slug and is defined for the entity.\n   * @param slugName The slug name.\n   * @param entityName The entity for which this might be a defined slug.\n   * @returns True if slugName is defined for entityName.\n   */\n  public isSlugForEntity(slugName: string, entityName: string) {\n    if (!this.isDefined(slugName)) {\n      return false;\n    }\n    const doc = this.findDoc(slugName);\n    return doc.entityName === entityName;\n  }\n\n  /**\n   * Returns true if the passed slugID is defined in this collection.\n   * In the case of SlugCollection, hasSlug is a synonym for isDefined, and you should use isDefined instead.\n   * @param { String } slugID A docID.\n   * @returns {boolean} True if the slugID is in this collection.\n   */\n  public hasSlug(slugID: string): boolean {\n    return this.isDefined(slugID);\n  }\n\n  /**\n   * Returns the slug name associated with this ID.\n   * @param slugID The slug ID.\n   * @returns The slug name.\n   * @throws { Meteor.Error } If the passed slugID is not valid.\n   */\n  public getNameFromID(slugID: string): string {\n    this.assertDefined(slugID);\n    return this.findDoc(slugID).name;\n  }\n\n  /**\n   * A stricter form of remove that throws an error if the document or docID could not be found in this collection.\n   * @param { String | Object } docOrID A document or docID in this collection.\n   */\n  public removeIt(docOrID: string | object) {\n    return super.removeIt(docOrID);\n  }\n\n  /**\n   * Throws an Error if the passed slugName is not a slugName.\n   * @param slugName The SlugName\n   * @throws { Meteor.Error } If the passed slugName is not a slug name.\n   */\n  public assertSlug(slugName: string) {\n    if (!this.collection.findOne({ name: slugName })) {\n      throw new Meteor.Error(`Undefined slug ${slugName}.`);\n    }\n  }\n\n  /**\n   * Returns an empty array (no integrity checking done on Slugs.)\n   * @returns {Array} An empty array.\n   */\n  public checkIntegrity() {\n    return [];\n  }\n\n  /**\n   * Returns an object representing the passed slug docID in a format acceptable to define().\n   * @param docID The docID of a Slug.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID): ISlugDefine {\n    const doc = this.findDoc(docID);\n    const name = doc.name;\n    const entityName = doc.entityName;\n    return { name, entityName };\n  }\n}\n\n/**\n * Provides the singleton instance of a SlugCollection to all other entities.\n * @type {api/slug.SlugCollection}\n * @memberOf api/slug\n */\nexport const Slugs = new SlugCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/slug/SlugCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 978,
    "kind": "function",
    "name": "slugify",
    "memberof": "api/slug/SlugCollection.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/slug/SlugCollection.ts~slugify",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/slug/SlugCollection.ts",
    "importStyle": "slugify",
    "description": "Slugifies the give text.",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "text",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 979,
    "kind": "variable",
    "name": "Slugs",
    "memberof": "api/slug/SlugCollection.ts",
    "static": true,
    "longname": "api/slug/SlugCollection.ts~Slugs",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/slug/SlugCollection.ts",
    "importStyle": "{Slugs}",
    "description": "Provides the singleton instance of a SlugCollection to all other entities.",
    "lineNumber": 206,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/slug"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/slug.SlugCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 980,
    "kind": "class",
    "name": "SlugCollection",
    "memberof": "api/slug/SlugCollection.ts",
    "static": true,
    "longname": "api/slug/SlugCollection.ts~SlugCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/slug/SlugCollection.ts",
    "importStyle": null,
    "description": "Slugs are unique strings that can be used to identify entities and can be used in URLs.",
    "lineNumber": 27,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 981,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/slug/SlugCollection.ts~SlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/slug/SlugCollection.ts~SlugCollection#constructor",
    "access": "public",
    "description": "Creates the Slug collection.",
    "lineNumber": 31
  },
  {
    "__docId__": 982,
    "kind": "method",
    "name": "define",
    "memberof": "api/slug/SlugCollection.ts~SlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/slug/SlugCollection.ts~SlugCollection#define",
    "access": "public",
    "description": "Creates a new Slug instance and adds it to the collection.",
    "lineNumber": 53,
    "params": [
      {
        "nullable": null,
        "types": [
          "ISlugDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 983,
    "kind": "method",
    "name": "isValidSlugName",
    "memberof": "api/slug/SlugCollection.ts~SlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/slug/SlugCollection.ts~SlugCollection#isValidSlugName",
    "access": "public",
    "description": "Returns true if slugName is syntactically valid (i.e. consists of a-zA-Z0-9 or dash or underscore.)",
    "lineNumber": 71,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "slugName",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 984,
    "kind": "method",
    "name": "updateEntityID",
    "memberof": "api/slug/SlugCollection.ts~SlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/slug/SlugCollection.ts~SlugCollection#updateEntityID",
    "access": "public",
    "description": "Updates a Slug with the docID of the associated entity.",
    "lineNumber": 81,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "slugID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "entityID",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 985,
    "kind": "method",
    "name": "getEntityID",
    "memberof": "api/slug/SlugCollection.ts~SlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/slug/SlugCollection.ts~SlugCollection#getEntityID",
    "access": "public",
    "description": "Returns the docID of the entity associated with this Slug.",
    "lineNumber": 92,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "slugName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "entityName",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 986,
    "kind": "method",
    "name": "isSlugForEntity",
    "memberof": "api/slug/SlugCollection.ts~SlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/slug/SlugCollection.ts~SlugCollection#isSlugForEntity",
    "access": "public",
    "description": "Returns true if slugName is a slug and is defined for the entity.",
    "lineNumber": 109,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "slugName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "entityName",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 987,
    "kind": "method",
    "name": "hasSlug",
    "memberof": "api/slug/SlugCollection.ts~SlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/slug/SlugCollection.ts~SlugCollection#hasSlug",
    "access": "public",
    "description": "Returns true if the passed slugID is defined in this collection.\nIn the case of SlugCollection, hasSlug is a synonym for isDefined, and you should use isDefined instead.",
    "lineNumber": 123,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "slugID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 988,
    "kind": "method",
    "name": "getNameFromID",
    "memberof": "api/slug/SlugCollection.ts~SlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/slug/SlugCollection.ts~SlugCollection#getNameFromID",
    "access": "public",
    "description": "Returns the slug name associated with this ID.",
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "slugID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 989,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/slug/SlugCollection.ts~SlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/slug/SlugCollection.ts~SlugCollection#removeIt",
    "access": "public",
    "description": "A stricter form of remove that throws an error if the document or docID could not be found in this collection.",
    "lineNumber": 142,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docOrID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 990,
    "kind": "method",
    "name": "assertSlug",
    "memberof": "api/slug/SlugCollection.ts~SlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/slug/SlugCollection.ts~SlugCollection#assertSlug",
    "access": "public",
    "description": "Throws an Error if the passed slugName is not a slugName.",
    "lineNumber": 151,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "slugName",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 991,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/slug/SlugCollection.ts~SlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/slug/SlugCollection.ts~SlugCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an empty array (no integrity checking done on Slugs.)",
    "lineNumber": 161,
    "params": [],
    "return": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 992,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/slug/SlugCollection.ts~SlugCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/slug/SlugCollection.ts~SlugCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the passed slug docID in a format acceptable to define().",
    "lineNumber": 170,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ISlugDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 993,
    "kind": "file",
    "name": "api/slug/SlugCollection.validators.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { Slugs } from './SlugCollection';\n\n/**\n * Custom validator for fields that must contain a previously undefined slug name.\n * @returns Undefined if the slug value is not previously defined, otherwise errorType 'duplicateSlug'.\n * @throws Error if there are no Slugs in the SlugCollection.\n * @memberOf api/slug\n */\nexport function newSlugValidator() {\n  if (Slugs.count() === 0) {\n    throw new Meteor.Error('newSlugValidator called but SlugCollection is empty. Probably a subscription issue.');\n  }\n  return (Slugs.isDefined(this.value)) ? 'duplicateSlug' : undefined;\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/slug/SlugCollection.validators.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 994,
    "kind": "function",
    "name": "newSlugValidator",
    "memberof": "api/slug/SlugCollection.validators.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/slug/SlugCollection.validators.ts~newSlugValidator",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/slug/SlugCollection.validators.ts",
    "importStyle": "{newSlugValidator}",
    "description": "Custom validator for fields that must contain a previously undefined slug name.",
    "lineNumber": 10,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 995,
    "kind": "file",
    "name": "api/slug/index.ts",
    "content": "/** @namespace api/slug */\n\nimport './SlugCollection';\nimport './SlugCollection.validators';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/slug/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 996,
    "kind": "file",
    "name": "api/star/StarProcessor.methods.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { ValidatedMethod } from 'meteor/mdg:validated-method';\nimport _ from 'lodash';\nimport { CourseInstances } from '../course/CourseInstanceCollection';\nimport { Courses } from '../course/CourseCollection';\nimport { Feeds } from '../feed/FeedCollection';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { StudentProfiles } from '../user/StudentProfileCollection';\nimport { Users } from '../user/UserCollection';\nimport { advisorLogsDefineMethod } from '../log/AdvisorLogCollection.methods';\nimport { defineMethod } from '../base/BaseCollection.methods';\nimport { getDepartment } from '../course/CourseUtilities';\nimport {\n  processStarCsvData,\n  processStarJsonData,\n  processBulkStarCsvData,\n  processBulkStarJsonData,\n} from './StarProcessor';\nimport { updateStudentLevel } from '../level/LevelProcessor';\nimport { IStudentProfileDefine } from '../../typings/radgrad';\n\nfunction processStudentStarDefinitions(advisor, student, definitions) {\n  // console.log(`processStudentStarDefinitions(${advisor}, ${student}, ${definitions})`);\n  // console.log(`Processing ${student}'s STAR data`);\n  // console.log(definitions);\n  const studentID = Users.getID(student);\n  // console.log(student, studentID);\n  const oldInstances = CourseInstances.find({ studentID, fromRegistrar: true }).fetch();\n  _.forEach(oldInstances, (instance) => {\n    CourseInstances.removeIt(instance._id);\n  });\n  let numInterstingCourses = 0;\n  // let numOtherCourses = 0;\n  // console.log('create new instances');\n  const departments = {};\n  _.forEach(definitions, (definition) => {\n    // console.log('termID', termID);\n    // console.log(definition);\n    if (definition.course !== Courses.unInterestingSlug) {\n      const termID = AcademicTerms.findIdBySlug(definition.academicTerm);\n      const department = getDepartment(definition.course);\n      if (!(department in departments)) {\n        departments[department] = 1;\n      } else {\n        departments[department] += 1;\n      }\n      numInterstingCourses += 1;\n      const courseID = Courses.findIdBySlug(definition.course);\n      // console.log('courseID', courseID);\n      const planning = CourseInstances.find({ studentID, termID, courseID, verified: false }).fetch();\n      // console.log('planning', planning);\n      if (planning.length > 0) {\n        CourseInstances.removeIt(planning[0]._id);\n      }\n    } else {\n      // numOtherCourses += 1;\n    }\n    definition.fromRegistrar = true; // eslint-disable-line no-param-reassign\n    if (definition.grade === '***' || definition.grade === 'TBD') {\n      definition.grade = 'B'; // eslint-disable-line no-param-reassign\n      definition.verified = false; // eslint-disable-line no-param-reassign\n    }\n    if (definition.course !== Courses.unInterestingSlug) {\n      // console.log('CourseInstances.define', definition);\n      CourseInstances.define(definition);\n    }\n  });\n  let text = 'Uploaded ';\n  for (const key in departments) {\n    if (departments.hasOwnProperty(key)) { // eslint-disable-line no-prototype-builtins\n      text = `${text} ${departments[key]} ${key}, `;\n    }\n  }\n  text = text.substring(0, text.length - 2);\n  if (numInterstingCourses > 1) {\n    text = `${text} courses from STAR.`;\n  } else {\n    text = `${text} course from STAR.`;\n  }\n  // console.log(`${student} had ${numInterstingCourses} course(s)`);\n  advisorLogsDefineMethod.call({ advisor, student, text }, (error) => {\n    if (error) {\n      console.log('Error creating AdvisorLog', error);\n    }\n  });\n}\n\n/**\n * Processes the student's star data creating CourseInstances.\n * @param advisor the advisor's username.\n * @param student the student's username.\n * @param csvData the student's STAR data.\n * @memberOf api/star\n */\nfunction processStudentStarCsvData(advisor, student, csvData) {\n  // console.log('processStudentStarCsvData', student, csvData);\n  const definitions = processStarCsvData(student, csvData);\n  processStudentStarDefinitions(advisor, student, definitions);\n}\n\n/**\n * Processes the student's star json data creating CourseInstances.\n * @param advisor the advisor's username.\n * @param student the student's username.\n * @param jsonData the student's STAR data as JSON object.\n * @memberOf api/star\n */\nfunction processStudentStarJsonData(advisor, student, jsonData) {\n  const defintions = processStarJsonData(student, jsonData);\n  processStudentStarDefinitions(advisor, student, defintions);\n}\n\n/**\n * ValidatedMethod for loading student STAR data.\n * @memberOf api/star\n */\nexport const starLoadDataMethod = new ValidatedMethod({\n  name: 'StarProcessor.loadStarCsvData',\n  validate: null,\n  run(data) {\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to define Star data.');\n    }\n    processStudentStarCsvData(data.advisor, data.student, data.csvData);\n  },\n});\n\n/**\n * ValidatedMethod for loading student STAR JSON data.\n * @memberOf api/star\n */\nexport const starLoadJsonDataMethod = new ValidatedMethod({\n  name: 'StarProcessor.loadStarJsonData',\n  validate: null,\n  run(data) {\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to define Star data.');\n    }\n    processStudentStarJsonData(data.advisor, data.student, data.jsonData);\n  },\n});\n\nfunction processBulkStarDefinitions(advisor, definitions) {\n  let updateNum = 0;\n  let newStudents = 0;\n  // console.log(definitions);\n  if (definitions) {\n    const students = Object.keys(definitions);\n    _.forEach(students, (student) => {\n      if (Users.isDefined(student)) {\n        updateNum += 1;\n        processStudentStarDefinitions(advisor, student, definitions[student].courses);\n        const studentID = Users.getID(student);\n        updateStudentLevel(advisor, studentID);\n      } else {\n        console.log(`${student} is not defined need to create them.`);\n        try {\n          const definitionData: IStudentProfileDefine = {\n            username: student,\n            firstName: definitions[student].firstName,\n            lastName: definitions[student].lastName,\n            level: 1,\n          };\n          StudentProfiles.define(definitionData);\n          const feedData = { feedType: Feeds.NEW_USER, user: definitionData.username };\n          defineMethod.call({ collectionName: Feeds.getCollectionName(), definitionData: feedData });\n          processStudentStarDefinitions(advisor, student, definitions[student].courses);\n          const studentID = Users.getID(student);\n          updateStudentLevel(advisor, studentID);\n          newStudents += 1;\n        } catch (e) {\n          console.log(`Error defining student ${student}`, e);\n        }\n      }\n    });\n  }\n  return `Updated ${updateNum} student(s), Created ${newStudents} new student(s)`;\n}\n\n/**\n * Processes the bulk star data creating CourseInstances.\n * @param advisor the advisor's username.\n * @param csvData the student's STAR data.\n * @memberOf api/star\n */\nfunction processBulkStarData(advisor, csvData) {\n  const definitions = processBulkStarCsvData(csvData);\n  return processBulkStarDefinitions(advisor, definitions);\n}\n\n/**\n * Processes the bulk star data creating CourseInstances.\n * @param advisor the advisor's username.\n * @param jsonData the student's STAR JSON data.\n * @memberOf api/star\n */\nfunction processBulkStarDataJson(advisor, jsonData) {\n  // console.log(`processBulkStarDataJson(${advisor}`, jsonData);\n  const definitions = processBulkStarJsonData(jsonData);\n  // console.log(definitions);\n  return processBulkStarDefinitions(advisor, definitions);\n}\n\n/**\n * ValidatedMethod for loading bulk STAR data.\n * @memberOf api/star\n */\nexport const starBulkLoadDataMethod = new ValidatedMethod({\n  name: 'StarProcess.bulkLoadStarCsvData',\n  validate: null,\n  run(data) {\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to define Star data.');\n    }\n    return processBulkStarData(data.advisor, data.csvData);\n  },\n});\n\nexport const starBulkLoadJsonDataMethod = new ValidatedMethod({\n  name: 'StarProcess.bulkLoadStarJsonData',\n  validate: null,\n  run(data) {\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to define Star data.');\n    }\n    return processBulkStarDataJson(data.advisor, data.jsonData);\n  },\n});\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/star/StarProcessor.methods.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 997,
    "kind": "function",
    "name": "processStudentStarDefinitions",
    "memberof": "api/star/StarProcessor.methods.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/star/StarProcessor.methods.ts~processStudentStarDefinitions",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/star/StarProcessor.methods.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "advisor",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "student",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "definitions",
        "description": ""
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 998,
    "kind": "function",
    "name": "processStudentStarCsvData",
    "memberof": "api/star/StarProcessor.methods.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/star/StarProcessor.methods.ts~processStudentStarCsvData",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/star/StarProcessor.methods.ts",
    "importStyle": null,
    "description": "Processes the student's star data creating CourseInstances.",
    "lineNumber": 95,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "advisor",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "student",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "csvData",
        "description": ""
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 999,
    "kind": "function",
    "name": "processStudentStarJsonData",
    "memberof": "api/star/StarProcessor.methods.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/star/StarProcessor.methods.ts~processStudentStarJsonData",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/star/StarProcessor.methods.ts",
    "importStyle": null,
    "description": "Processes the student's star json data creating CourseInstances.",
    "lineNumber": 108,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "advisor",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "student",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "jsonData",
        "description": ""
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 1000,
    "kind": "variable",
    "name": "starLoadDataMethod",
    "memberof": "api/star/StarProcessor.methods.ts",
    "static": true,
    "longname": "api/star/StarProcessor.methods.ts~starLoadDataMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/star/StarProcessor.methods.ts",
    "importStyle": "{starLoadDataMethod}",
    "description": "ValidatedMethod for loading student STAR data.",
    "lineNumber": 132,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/star"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1001,
    "kind": "variable",
    "name": "starLoadJsonDataMethod",
    "memberof": "api/star/StarProcessor.methods.ts",
    "static": true,
    "longname": "api/star/StarProcessor.methods.ts~starLoadJsonDataMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/star/StarProcessor.methods.ts",
    "importStyle": "{starLoadJsonDataMethod}",
    "description": "ValidatedMethod for loading student STAR JSON data.",
    "lineNumber": 154,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/star"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1002,
    "kind": "function",
    "name": "processBulkStarDefinitions",
    "memberof": "api/star/StarProcessor.methods.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/star/StarProcessor.methods.ts~processBulkStarDefinitions",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/star/StarProcessor.methods.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 143,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "advisor",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "definitions",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1003,
    "kind": "function",
    "name": "processBulkStarData",
    "memberof": "api/star/StarProcessor.methods.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/star/StarProcessor.methods.ts~processBulkStarData",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/star/StarProcessor.methods.ts",
    "importStyle": null,
    "description": "Processes the bulk star data creating CourseInstances.",
    "lineNumber": 186,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "advisor",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "csvData",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1004,
    "kind": "function",
    "name": "processBulkStarDataJson",
    "memberof": "api/star/StarProcessor.methods.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/star/StarProcessor.methods.ts~processBulkStarDataJson",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/star/StarProcessor.methods.ts",
    "importStyle": null,
    "description": "Processes the bulk star data creating CourseInstances.",
    "lineNumber": 197,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "advisor",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "jsonData",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1005,
    "kind": "variable",
    "name": "starBulkLoadDataMethod",
    "memberof": "api/star/StarProcessor.methods.ts",
    "static": true,
    "longname": "api/star/StarProcessor.methods.ts~starBulkLoadDataMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/star/StarProcessor.methods.ts",
    "importStyle": "{starBulkLoadDataMethod}",
    "description": "ValidatedMethod for loading bulk STAR data.",
    "lineNumber": 254,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/star"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1006,
    "kind": "variable",
    "name": "starBulkLoadJsonDataMethod",
    "memberof": "api/star/StarProcessor.methods.ts",
    "static": true,
    "longname": "api/star/StarProcessor.methods.ts~starBulkLoadJsonDataMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/star/StarProcessor.methods.ts",
    "importStyle": "{starBulkLoadJsonDataMethod}",
    "description": null,
    "lineNumber": 272,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1007,
    "kind": "file",
    "name": "api/star/StarProcessor.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport {} from 'mocha';\nimport { defineTestFixtures } from '../test/test-utilities';\nimport { processStarCsvData, processBulkStarJsonData } from './StarProcessor';\nimport { Users } from '../user/UserCollection';\nimport { removeAllEntities } from '../base/BaseUtilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('StarProcessor', function testSuite() {\n    this.timeout(5000);\n    const starDataPath = 'database/star/StarSampleData-1.csv';\n    const starJsonDataPath = 'database/star/BulkStarSampleData-1.json';\n    const badStarJsonDataPath = 'database/star/StarBadSampleData.json';\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it.skip('#processStarCsvData', function test() {\n      defineTestFixtures(['minimal', 'extended.courses.interests', 'abi.student']);\n      const csvData = Assets.getText(starDataPath);\n      const profile = Users.getProfile('abi@hawaii.edu');\n      const courseInstanceDefinitions = processStarCsvData(profile.username, csvData);\n      expect(courseInstanceDefinitions.length).to.equal(11);\n      removeAllEntities();\n    });\n\n    it('#processBulkStarJsonData', function testJson() {\n      defineTestFixtures(['minimal', 'extended.courses.interests', 'abi.student']);\n      let jsonData = JSON.parse(Assets.getText(starJsonDataPath));\n      const profile = Users.getProfile('abi@hawaii.edu');\n      const bulkData = processBulkStarJsonData(jsonData);\n      expect(bulkData[profile.username].courses.length).to.equal(12);\n      expect(bulkData[profile.username].courses[0].grade).to.equal('A');\n      jsonData = JSON.parse(Assets.getText(badStarJsonDataPath));\n      const otherBulkData = processBulkStarJsonData(jsonData);\n      expect(otherBulkData[profile.username].courses.length).to.equal(3);\n      expect(otherBulkData[profile.username].courses[0].grade).to.equal('OTHER');\n      removeAllEntities();\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/star/StarProcessor.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1008,
    "kind": "file",
    "name": "api/star/StarProcessor.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { Papa } from 'meteor/harrison:papa-parse';\nimport _ from 'lodash';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { Courses } from '../course/CourseCollection';\nimport { Slugs } from '../slug/SlugCollection';\nimport { CourseInstances } from '../course/CourseInstanceCollection';\nimport { IStarDataObject } from '../../typings/radgrad';\n\n/**\n * Given the semester string from STAR (for example, 'Fall 2015 ext'), parses it, defines the corresponding academicTerm,\n * and returns the AcademicTerm slug.\n * @param academicTerm The STAR semester string.\n * @returns {String} The RadGrad academicTerm slug.\n * @throws Meteor.Error If parsing fails.\n * @memberOf api/star\n */\nfunction findAcademicTermSlug(starDataObject: IStarDataObject) {\n  const academicTerm = starDataObject.semester;\n  if ((!_.isString(academicTerm)) || (academicTerm.length < 8)) {\n    throw new Meteor.Error(`Could not parse academic term data: ${JSON.stringify(starDataObject)}`);\n  }\n  const academicTermTokens = academicTerm.split(' ');\n  let term;\n  switch (academicTermTokens[0]) {\n    case 'Spring':\n      term = AcademicTerms.SPRING;\n      break;\n    case 'Spr':\n      term = AcademicTerms.SPRING;\n      break;\n    case 'Summer':\n      term = AcademicTerms.SUMMER;\n      break;\n    case 'Sum':\n      term = AcademicTerms.SUMMER;\n      break;\n    case 'Fall':\n      term = AcademicTerms.FALL;\n      break;\n    case 'Winter':\n      term = AcademicTerms.WINTER;\n      break;\n    case 'Win':\n      term = AcademicTerms.WINTER;\n      break;\n    default:\n      return null;\n  }\n  let year = parseInt(academicTermTokens[1], 10);\n  if (isNaN(year)) {\n    year = parseInt(academicTermTokens[2], 10);\n    if (isNaN(year)) {\n      return null;\n    }\n  }\n  return AcademicTerms.findSlugByID(AcademicTerms.define({ term, year }));\n}\n\n/**\n * Returns the course slug, which is either an ICS course or 'other.\n * @param starDataObject The data object.\n * @returns { String } The slug.\n * @memberOf api/star\n */\nfunction findCourseSlug(starDataObject: IStarDataObject) {\n  let slug = `${starDataObject.name.toLowerCase()}_${starDataObject.num}`;\n  if (!Slugs.isSlugForEntity(slug, Courses.getType())) {\n    slug = Courses.unInterestingSlug;\n  }\n  return slug;\n}\n\n/**\n * Creates a courseInstance data object from the passed arguments.\n * @param starDataObject STAR data.\n * @returns { Object } An object suitable for passing to CourseInstances.define.\n * @memberOf api/star\n */\nfunction makeCourseInstanceObject(starDataObject: IStarDataObject) {\n  return {\n    academicTerm: findAcademicTermSlug(starDataObject),\n    course: findCourseSlug(starDataObject),\n    note: `${starDataObject.name} ${starDataObject.num}`,\n    verified: true,\n    fromRegistrar: true,\n    creditHrs: starDataObject.credits,\n    grade: starDataObject.grade,\n    student: starDataObject.student,\n  };\n}\n\n/**\n * Returns an array of arrays, each containing data that can be made into CourseInstances.\n * @param parsedData The parsedData object returned from Papa.parse.\n * @returns { Array } A new array with extraneous elements deleted.\n * @memberOf api/star\n */\nfunction filterParsedData(parsedData) {\n  // First, get the actual data from the Papa results.\n  let filteredData = parsedData.data;\n  // Remove first element containing headers from data array.\n  filteredData = _.drop(filteredData, 1);\n  // Remove trailing elements that don't contain data.\n  filteredData = _.dropRightWhile(filteredData, (data: any) => data.length < 5);\n  // Remove test scores that appear at top.\n  filteredData = _.dropWhile(filteredData, (data) => data[2].startsWith('Test'));\n  return filteredData;\n}\n\n/**\n * Processes STAR CSV data and returns an array of objects containing CourseInstance fields.\n * @param { String } student The slug of the student corresponding to this STAR data.\n * @param { String } csvData A string containing the contents of a CSV file downloaded from STAR.\n * @returns { Array } A list of objects with fields: academicTerm, course, note, verified, grade, and creditHrs.\n * @memberOf api/star\n */\nexport function processStarCsvData(student, csvData) {\n  if (Papa) {\n    const parsedData = Papa.parse(csvData);\n    if (parsedData.errors.length !== 0) {\n      throw new Meteor.Error(`Error found when parsing STAR data for ${student}: ${parsedData.errors}`);\n    }\n    const headers = parsedData.data[0];\n    // console.log('parsed data', parsedData);\n    const academicTermIndex = _.findIndex(headers, (str) => str === 'Semester');\n    const nameIndex = _.findIndex(headers, (str) => str === 'Course Name');\n    const numberIndex = _.findIndex(headers, (str) => str === 'Course Number');\n    const creditsIndex = _.findIndex(headers, (str) => str === 'Credits');\n    const gradeIndex = _.findIndex(headers, (str) => str === 'Grade');\n    const transferGradeIndex = _.findIndex(headers, (str) => str === 'Transfer Grade');\n    // const transferCourseNameIndex = _.findIndex(headers, (str) => str === 'Transfer Course Name');\n    const transferCourseNumberIndex = _.findIndex(headers, (str) => str === 'Transfer Course Number');\n    // const transferCourseDesc = _.findIndex(headers, (str) => str === 'Transfer Course Description');\n    if (_.every([academicTermIndex, nameIndex, numberIndex, creditsIndex, gradeIndex], (num) => num === -1)) {\n      throw new Meteor.Error(`Required CSV header field was not found in ${headers}`);\n    }\n    const filteredData = filterParsedData(parsedData);\n\n    // filteredData.map((data) => console.log('\\n*** START ***\\n', data, '\\n*** END ***\\n'));\n\n    // Create array of objects containing raw data to facilitate error message during processing.\n    const dataObjects = _.map(filteredData, (data) => {\n      const name = data[nameIndex];\n      let grade = data[gradeIndex];\n      // console.log(`grade ${grade}`);\n      if (grade === 'CR' && data[transferGradeIndex] && isNaN(data[transferGradeIndex])) {\n        grade = data[transferGradeIndex];\n      } else if (grade === 'CR' && data[transferGradeIndex] && !isNaN(data[transferGradeIndex])) {\n        // got number assuming it is AP exam score need to determine the type of the exam.\n        // const exam = data[transferCourseDesc];\n        if (data[transferGradeIndex] > 2) {\n          grade = 'B';\n        }\n      } else if (grade === 'unknown' && data[transferGradeIndex] && isNaN(data[transferGradeIndex])) {\n        grade = data[transferGradeIndex];\n      } else if (grade.includes('L')) {\n        grade = 'C';\n      }\n      let num = data[numberIndex];\n      if (isNaN(num)) {\n        num = data[transferCourseNumberIndex];\n      }\n      const obj: IStarDataObject = {\n        semester: data[academicTermIndex],\n        name,\n        num,\n        credits: data[creditsIndex],\n        grade,\n        student,\n      };\n      return obj;\n    });\n    // console.log(dataObjects);\n    // Now we take that array of objects and transform them into CourseInstance data objects.\n    return _.filter(_.map(dataObjects, (dataObject) => makeCourseInstanceObject(dataObject)), (ci) => ci.course !== Courses.unInterestingSlug && ci.academicTerm !== null);\n  }\n  // must be on the client.\n  return null;\n}\n\nexport function processBulkStarCsvData(csvData) {\n  if (Papa) {\n    const parsedData = Papa.parse(csvData);\n    if (parsedData.errors.length !== 0) {\n      throw new Meteor.Error(`Error found when parsing STAR data for ${parsedData.errors}`);\n    }\n    const headers = parsedData.data[0];\n    // console.log('parsed data', parsedData);\n    const academicTermIndex = _.findIndex(headers, (str) => str === 'Semester');\n    const nameIndex = _.findIndex(headers, (str) => str === 'Course Name');\n    const numberIndex = _.findIndex(headers, (str) => str === 'Course Number');\n    const creditsIndex = _.findIndex(headers, (str) => str === 'Credits');\n    const gradeIndex = _.findIndex(headers, (str) => str === 'Grade');\n    const transferGradeIndex = _.findIndex(headers, (str) => str === 'Transfer Grade');\n    // const transferCourseNameIndex = _.findIndex(headers, (str) => str === 'Transfer Course Name');\n    const transferCourseNumberIndex = _.findIndex(headers, (str) => str === 'Transfer Course Number');\n    // const transferCourseDesc = _.findIndex(headers, (str) => str === 'Transfer Course Description');\n    const emailIndex = _.findIndex(headers, (str) => str === 'Email');\n    const firstNameIndex = _.findIndex(headers, (str) => str === 'First Name');\n    const lastNameIndex = _.findIndex(headers, (str) => str === 'Last Name');\n    if (_.every([academicTermIndex, nameIndex, numberIndex, creditsIndex, gradeIndex, emailIndex, firstNameIndex, lastNameIndex], (num) => num === -1)) {\n      throw new Meteor.Error(`Required CSV header field was not found in ${headers}`);\n    }\n    const filteredData = filterParsedData(parsedData);\n    // Create array of objects containing raw data to facilitate error message during processing.\n    const bulkData = {};\n    // const dataObjects = _.map(filteredData, (data) => {\n    _.forEach(filteredData, (data) => {\n      const name = data[nameIndex];\n      let grade = data[gradeIndex];\n      // console.log(`grade ${grade}`);\n      if (grade === 'CR' && data[transferGradeIndex] && isNaN(data[transferGradeIndex])) {\n        grade = data[transferGradeIndex];\n      } else if (grade === 'CR' && data[transferGradeIndex] && !isNaN(data[transferGradeIndex])) {\n        // got number assuming it is AP exam score need to determine the type of the exam.\n        // const exam = data[transferCourseDesc];\n        if (data[transferGradeIndex] > 2) {\n          grade = 'B';\n        }\n      } else if (grade === 'unknown' && data[transferGradeIndex] && isNaN(data[transferGradeIndex])) {\n        grade = data[transferGradeIndex];\n      } else if (grade.includes('L')) {\n        grade = 'C';\n      }\n      let num = data[numberIndex];\n      if (isNaN(num)) {\n        num = data[transferCourseNumberIndex];\n      }\n      const student = data[emailIndex];\n      const obj: IStarDataObject = {\n        semester: data[academicTermIndex],\n        name,\n        num,\n        credits: data[creditsIndex],\n        grade,\n        student,\n      };\n      if (!bulkData[student]) {\n        bulkData[student] = {};\n        bulkData[student].courses = [];\n        bulkData[student].firstName = data[firstNameIndex];\n        bulkData[student].lastName = data[lastNameIndex];\n      }\n      bulkData[student].courses.push(obj);\n    });\n    // Now we take that array of objects and transform them into CourseInstance data objects.\n    _.forEach(Object.keys(bulkData), (key) => {\n      bulkData[key].courses = _.filter(_.map(bulkData[key].courses, (dataObject) => makeCourseInstanceObject(dataObject)), (ci) => ci.course !== Courses.unInterestingSlug && ci.academicTerm !== null);\n    });\n    return bulkData;\n  }\n  return null;\n}\n\n/**\n * Processes STAR JSON data and returns an array of objects containing CourseInstance fields.\n * @param { String } student The slug of the student corresponding to this STAR data.\n * @param { String } jsonData JSON object for a student.\n * @returns { Array } A list of objects with fields: academicTerm, course, note, verified, grade, and creditHrs.\n * @memberOf api/star\n */\nexport function processStarJsonData(student, jsonData) {\n  // console.log(jsonData);\n  if (student !== jsonData.email) {\n    throw new Meteor.Error(`JSON data is not for ${student}`);\n  }\n  const courses = jsonData.courses;\n  const dataObjects = _.map(courses, (course) => {\n    const name = course.name;\n    let grade = course.grade;\n    if (_.includes(CourseInstances.validGrades, grade)) {\n      if (grade === 'CR' && course.transferGrade && isNaN(course.transferGrade)) {\n        grade = course.transferGrade;\n      } else if (grade === 'CR' && course.transferGrade && !isNaN(course.transferGrade)) {\n        // got number assuming it is AP exam score need to determine the type of the exam.\n        if (course.transferGrade > 2) {\n          grade = 'B';\n        }\n      }\n    } else {\n      grade = 'OTHER';\n    }\n    let num = course.number;\n    if (isNaN(num)) {\n      num = course.transferNumber;\n    }\n    const obj: IStarDataObject = {\n      semester: course.semester,\n      name,\n      num,\n      credits: course.credits,\n      grade,\n      student,\n    };\n    return obj;\n  });\n\n  // console.log('single', dataObjects);\n  // Now we take that array of objects and transform them into CourseInstance data objects.\n  return _.filter(_.map(dataObjects, (dataObject) => makeCourseInstanceObject(dataObject)), (ci) => ci.course !== Courses.unInterestingSlug && ci.academicTerm !== null);\n}\n\n/**\n * Processes STAR JSON data and returns an array of objects containing CourseInstance fields.\n * @param { String } jsonData JSON array with objects for students.\n * @returns { Array } A list of objects with fields: academicTerm, course, note, verified, grade, and creditHrs.\n * @memberOf api/star\n */\nexport function processBulkStarJsonData(jsonData) {\n  const bulkData = {};\n  _.forEach(jsonData, (data) => {\n    // console.log(data);\n    const student = data.email;\n    if (!bulkData[student]) {\n      bulkData[student] = {};\n      bulkData[student].courses = processStarJsonData(student, data);\n      bulkData[student].firstName = data.name.first;\n      bulkData[student].lastName = data.name.last;\n    }\n  });\n  // console.log('bulk', bulkData);\n  return bulkData;\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/star/StarProcessor.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1009,
    "kind": "function",
    "name": "findAcademicTermSlug",
    "memberof": "api/star/StarProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/star/StarProcessor.ts~findAcademicTermSlug",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/star/StarProcessor.ts",
    "importStyle": null,
    "description": "Given the semester string from STAR (for example, 'Fall 2015 ext'), parses it, defines the corresponding academicTerm,\nand returns the AcademicTerm slug.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "IStarDataObject"
        ],
        "spread": false,
        "optional": false,
        "name": "starDataObject",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1010,
    "kind": "function",
    "name": "findCourseSlug",
    "memberof": "api/star/StarProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/star/StarProcessor.ts~findCourseSlug",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/star/StarProcessor.ts",
    "importStyle": null,
    "description": "Returns the course slug, which is either an ICS course or 'other.",
    "lineNumber": 66,
    "params": [
      {
        "nullable": null,
        "types": [
          "IStarDataObject"
        ],
        "spread": false,
        "optional": false,
        "name": "starDataObject",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1011,
    "kind": "function",
    "name": "makeCourseInstanceObject",
    "memberof": "api/star/StarProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/star/StarProcessor.ts~makeCourseInstanceObject",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/star/StarProcessor.ts",
    "importStyle": null,
    "description": "Creates a courseInstance data object from the passed arguments.",
    "lineNumber": 80,
    "params": [
      {
        "nullable": null,
        "types": [
          "IStarDataObject"
        ],
        "spread": false,
        "optional": false,
        "name": "starDataObject",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "{\"academicTerm\": *, \"course\": *, \"note\": *, \"verified\": boolean, \"fromRegistrar\": boolean, \"creditHrs\": *, \"grade\": *, \"student\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1012,
    "kind": "function",
    "name": "filterParsedData",
    "memberof": "api/star/StarProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/star/StarProcessor.ts~filterParsedData",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/star/StarProcessor.ts",
    "importStyle": null,
    "description": "Returns an array of arrays, each containing data that can be made into CourseInstances.",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "parsedData",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1013,
    "kind": "function",
    "name": "processStarCsvData",
    "memberof": "api/star/StarProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/star/StarProcessor.ts~processStarCsvData",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/star/StarProcessor.ts",
    "importStyle": "{processStarCsvData}",
    "description": "Processes STAR CSV data and returns an array of objects containing CourseInstance fields.",
    "lineNumber": 118,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "student",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "csvData",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1014,
    "kind": "function",
    "name": "processBulkStarCsvData",
    "memberof": "api/star/StarProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/star/StarProcessor.ts~processBulkStarCsvData",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/star/StarProcessor.ts",
    "importStyle": "{processBulkStarCsvData}",
    "description": "",
    "lineNumber": 182,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "csvData",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1015,
    "kind": "function",
    "name": "processStarJsonData",
    "memberof": "api/star/StarProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/star/StarProcessor.ts~processStarJsonData",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/star/StarProcessor.ts",
    "importStyle": "{processStarJsonData}",
    "description": "Processes STAR JSON data and returns an array of objects containing CourseInstance fields.",
    "lineNumber": 263,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "student",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "jsonData",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1016,
    "kind": "function",
    "name": "processBulkStarJsonData",
    "memberof": "api/star/StarProcessor.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/star/StarProcessor.ts~processBulkStarJsonData",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/star/StarProcessor.ts",
    "importStyle": "{processBulkStarJsonData}",
    "description": "Processes STAR JSON data and returns an array of objects containing CourseInstance fields.",
    "lineNumber": 310,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "jsonData",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1017,
    "kind": "file",
    "name": "api/star/index.ts",
    "content": "/** @namespace api/star */\nimport './StarProcessor';\nimport './StarProcessor.methods';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/star/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1018,
    "kind": "file",
    "name": "api/teaser/TeaserCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { Teasers } from './TeaserCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('TeaserCollection Meteor Methods ', function test() {\n    const collectionName = Teasers.getCollectionName();\n    const definitionData = {\n      title: 'name',\n      slug: 'opportunity-slug-example',\n      author: 'Amy',\n      opportunity: 'acm-manoa',\n      url: 'http://cnn.com',\n      interests: ['algorithms'],\n      description: 'description',\n    };\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal', 'opportunities'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      await defineMethod.callPromise({ collectionName, definitionData });\n    });\n\n    it('Update Method', async function () {\n      const id = Teasers.findIdBySlug(definitionData.slug);\n      const description = 'updated description';\n      await updateMethod.callPromise({ collectionName, updateData: { id, description } });\n    });\n\n    it('Remove Method', async function () {\n      await removeItMethod.callPromise({ collectionName, instance: definitionData.slug });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/teaser/TeaserCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1019,
    "kind": "file",
    "name": "api/teaser/TeaserCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { Teasers } from './TeaserCollection';\nimport { makeSampleInterest } from '../interest/SampleInterests';\nimport { makeSampleOpportunity } from '../opportunity/SampleOpportunities';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { ROLE } from '../role/Role';\nimport slugify, { Slugs } from '../slug/SlugCollection';\nimport { makeSampleCareerGoal } from '../career/SampleCareerGoals';\nimport { makeSampleCourse } from '../course/SampleCourses';\nimport { CareerGoals } from '../career/CareerGoalCollection';\nimport { Courses } from '../course/CourseCollection';\nimport { Interests } from '../interest/InterestCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nconst makeSampleTeaserTargetSlug = () => {\n  const rand = faker.random.number(0, 3);\n  let docID;\n  let doc;\n  switch (rand) {\n    case 0:\n      docID = makeSampleCareerGoal();\n      doc = CareerGoals.findDoc(docID);\n      break;\n    case 1:\n      docID = makeSampleCourse();\n      doc = Courses.findDoc(docID);\n      break;\n    case 2:\n      docID = makeSampleInterest();\n      doc = Interests.findDoc(docID);\n      break;\n    default:\n      docID = makeSampleOpportunity(makeSampleUser(ROLE.FACULTY));\n  }\n  return Slugs.getNameFromID(doc.slugID);\n};\n\nif (Meteor.isServer) {\n  describe('TeaserCollection', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function tearDown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) {\n      this.timeout(25000);\n      fc.assert(\n        fc.property(fc.lorem(3), fc.lorem(2), fc.lorem(10), fc.lorem(1), (fcTitle, fcAuthor, fcDescription, fcDuration) => {\n          const slug = slugify(fcTitle);\n          const url = faker.internet.url();\n          const interests = [makeSampleInterest()];\n          // const opportunity = makeSampleOpportunity(makeSampleUser(ROLE.FACULTY));\n          const targetSlug = makeSampleTeaserTargetSlug();\n          const docID = Teasers.define({\n            title: fcTitle,\n            slug,\n            author: fcAuthor,\n            url,\n            description: fcDescription,\n            duration: fcDuration,\n            interests,\n            targetSlug,\n          });\n          expect(Teasers.isDefined(docID)).to.be.true;\n          Teasers.removeIt(docID);\n          expect(Teasers.isDefined(docID)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Can not define duplicates', function test2() {\n      const title = faker.lorem.words(3);\n      const slug = slugify(title);\n      const author = faker.internet.email();\n      const url = faker.internet.url();\n      const description = faker.lorem.paragraph();\n      const duration = faker.lorem.word();\n      const interests = [makeSampleInterest()];\n      const targetSlug = makeSampleTeaserTargetSlug();\n      const docID = Teasers.define({\n        title,\n        slug,\n        author,\n        url,\n        description,\n        duration,\n        interests,\n        targetSlug,\n      });\n      expect(Teasers.isDefined(docID)).to.be.true;\n      expect(() => Teasers.define({\n        title,\n        slug,\n        author,\n        url,\n        description,\n        duration,\n        interests,\n        targetSlug,\n      })).to.throw(Error);\n    });\n\n    it('Can update', function test3(done) {\n      this.timeout(5000);\n      let doc = Teasers.findOne({});\n      const docID = doc._id;\n      fc.assert(\n        fc.property(fc.lorem(3), fc.lorem(1), fc.lorem(10), fc.lorem(1), fc.boolean(), (fcTitle, fcAuthor, fcDescription, fcDuration, fcRetired) => {\n          const interests = [makeSampleInterest()];\n          const targetSlug = makeSampleTeaserTargetSlug();\n          const url = faker.internet.url();\n          Teasers.update(docID, {\n            title: fcTitle,\n            targetSlug,\n            interests,\n            author: fcAuthor,\n            url,\n            description: fcDescription,\n            duration: fcDuration,\n            retired: fcRetired,\n          });\n          doc = Teasers.findDoc(docID);\n          expect(doc.title).to.equal(fcTitle);\n          expect(Slugs.getNameFromID(doc.targetSlugID)).to.equal(targetSlug);\n          expect(doc.author).to.equal(fcAuthor);\n          expect(doc.url).to.equal(url);\n          expect(doc.description).to.equal(fcDescription);\n          expect(doc.duration).to.equal(fcDuration);\n          expect(doc.retired).to.equal(fcRetired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() {\n      const origDoc = Teasers.findOne({});\n      let docID = origDoc._id;\n      const dumpObject = Teasers.dumpOne(docID);\n      Teasers.removeIt(docID);\n      expect(Teasers.isDefined(docID)).to.be.false;\n      docID = Teasers.restoreOne(dumpObject);\n      expect(Teasers.isDefined(docID)).to.be.true;\n      const doc = Teasers.findDoc(docID);\n      expect(doc.title).to.equal(origDoc.title);\n      expect(doc.targetSlugID).to.equal(origDoc.targetSlugID);\n      expect(doc.author).to.equal(origDoc.author);\n      expect(doc.url).to.equal(origDoc.url);\n      expect(doc.description).to.equal(origDoc.description);\n      expect(doc.duration).to.equal(origDoc.duration);\n      expect(doc.retired).to.equal(origDoc.retired);\n    });\n\n    it('Can checkIntegrity no errors', function test5() {\n      const problems = Teasers.checkIntegrity();\n      expect(problems).to.have.lengthOf(0);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/teaser/TeaserCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1020,
    "kind": "function",
    "name": "makeSampleTeaserTargetSlug",
    "memberof": "api/teaser/TeaserCollection.test.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/teaser/TeaserCollection.test.ts~makeSampleTeaserTargetSlug",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/teaser/TeaserCollection.test.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1021,
    "kind": "file",
    "name": "api/teaser/TeaserCollection.ts",
    "content": "import SimpleSchema from 'simpl-schema';\nimport _ from 'lodash';\nimport { Slugs } from '../slug/SlugCollection';\nimport BaseSlugCollection from '../base/BaseSlugCollection';\nimport { Interests } from '../interest/InterestCollection';\nimport { Opportunities } from '../opportunity/OpportunityCollection';\nimport { ITeaserDefine, ITeaserUpdate, ITeaserUpdateData } from '../../typings/radgrad';\n\n/**\n * Represents a teaser instance, such as \"ACM Webmasters\".\n * @extends api/base.BaseSlugCollection\n * @memberOf api/teaser\n */\nclass TeaserCollection extends BaseSlugCollection {\n\n  /**\n   * Creates the Teaser collection.\n   */\n  constructor() {\n    super('Teaser', new SimpleSchema({\n      title: String,\n      slugID: SimpleSchema.RegEx.Id,\n      author: String,\n      url: String,\n      description: String,\n      interestIDs: [SimpleSchema.RegEx.Id],\n      opportunityID: { type: SimpleSchema.RegEx.Id, optional: true },\n      targetSlugID: SimpleSchema.RegEx.Id,\n      duration: { type: String, optional: true },\n      retired: { type: Boolean, optional: true },\n    }));\n    this.defineSchema = new SimpleSchema({\n      title: String,\n      slug: String,\n      author: String,\n      url: String,\n      description: String,\n      duration: { type: String, optional: true },\n      interests: Array,\n      'interests.$': String,\n      opportunity: { type: String, optional: true },\n      targetSlug: String,\n      retired: { type: Boolean, optional: true },\n    });\n    this.updateSchema = new SimpleSchema({\n      title: { type: String, optional: true },\n      author: { type: String, optional: true },\n      url: { type: String, optional: true },\n      description: { type: String, optional: true },\n      duration: { type: String, optional: true },\n      interests: { type: Array, optional: true },\n      'interests.$': String,\n      opportunity: { type: String, optional: true },\n      targetSlug: { type: String, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines a new Teaser video to provide information about an opportunity.\n   * @example\n   * Teaser.define({ title: 'ACM Webmasters',\n   *                 slug: 'acm-webmasters-teaser',\n   *                 opportunity: 'acm-webmasters'\n   *                 interests: ['html', 'javascript', 'css', 'web-development'],\n   *                 author: 'Torlief Nielson'\n   *                 url: 'https://www.youtube.com/watch?v=OI4CXULK3tw'\n   *                 description: 'Learn web development by helping to develop and maintain the ACM Manoa website.',\n   *                 duration: '0:39',\n   *                 })\n   * @param { Object } description Object with keys title, slug, URL, description, duration. interestIDs.\n   * Title is a required string.\n   * Slug is required and must be previously undefined. By convention, use a '-teaser' suffix.\n   * Interests is a required array of one or more defined interest slugs or interestIDs.\n   * Opportunity is a required opportunity slug or opportunityID.\n   * URL is a required string; the url to the (typically YouTube) video defining this teaser.\n   * Author is a required string indicating the author of the Teaser.\n   * Description is a required string providing a short description of this teaser.\n   * Duration is an optional string indicating the length of the teaser.\n   * @throws {Meteor.Error} If the interest definition includes a defined slug or undefined interestID,\n   * if the slug is already defined, or if the opportunity is supplied and not found.\n   * @returns The newly created docID.\n   */\n  public define({ title, slug, author, url, description, duration, interests, opportunity, targetSlug, retired = false }: ITeaserDefine) {\n    // Get InterestIDs, throw error if any of them are not found.\n    const interestIDs = Interests.getIDs(interests);\n    // Get SlugID, throw error if found.\n    const slugID = Slugs.define({ name: slug, entityName: this.getType() });\n    let targetSlugID;\n    if (!_.isUndefined(opportunity)) {\n      // Get OpportunityID, throw error if not found.\n      const opportunityID = Opportunities.getID(opportunity);\n      // if ()\n      targetSlugID = Slugs.findDoc({ entityID: opportunityID })._id;\n    }\n    if (!_.isUndefined(targetSlug)) {\n      targetSlugID = Slugs.findDoc({ name: targetSlug })._id;\n    }\n    const teaserID = this.collection.insert({ title, slugID, author, url, description, duration, interestIDs,\n      targetSlugID, retired });\n    // Connect the Slug to this teaser\n    Slugs.updateEntityID(slugID, teaserID);\n    return teaserID;\n  }\n\n  /**\n   * Update a Teaser. Everything can be updated except the slug.\n   * @param docID The docID to be updated.\n   * @throws { Meteor.Error } If docID is not defined, or if any interest or opportunity is undefined.\n   */\n  public update(docID, { title, targetSlug, interests, author, url, description, duration, retired }: ITeaserUpdate) {\n    this.assertDefined(docID);\n    const updateData: ITeaserUpdateData = {};\n    if (title) {\n      updateData.title = title;\n    }\n    if (targetSlug) {\n      updateData.targetSlugID = Slugs.findDoc({ name: targetSlug })._id;\n    }\n    if (interests) {\n      updateData.interestIDs = Interests.getIDs(interests);\n    }\n    if (author) {\n      updateData.author = author;\n    }\n    if (url) {\n      updateData.url = url;\n    }\n    if (description) {\n      updateData.description = description;\n    }\n    if (duration) {\n      updateData.duration = duration;\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired;\n    }\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Remove the Teaser.\n   * @param instance The docID or slug of the entity to be removed.\n   * @throws { Meteor.Error } If docID is not a Teaser.\n   */\n  public removeIt(instance: string) {\n    const docID = this.getID(instance);\n    // OK, clear to delete.\n    return super.removeIt(docID);\n  }\n\n  /**\n   * Returns true if teaser has the specified interest.\n   * @param teaser The teaser (docID or slug)\n   * @param interest The Interest (docID or slug).\n   * @returns {boolean} True if the teaser has the associated Interest.\n   * @throws { Meteor.Error } If teaser is not a teaser or interest is not a Interest.\n   */\n  public hasInterest(teaser: string, interest: string) {\n    const interestID = Interests.getID(interest);\n    const doc = this.findDoc(teaser);\n    return _.includes(doc.interestIDs, interestID);\n  }\n\n  /**\n   * Returns true if teaser has the specified slug.\n   * @param teaser The teaser (docID or slug)\n   * @param target The target (slug).\n   * @returns {boolean} True if the teaser has the associated slug.\n   * @throws { Meteor.Error } If teaser is not a teaser or target isn't a defined slug.\n   */\n  hasTarget(teaser, target) {\n    const targetSlugID = Slugs.findDoc({ name: target })._id;\n    const doc = this.findDoc(teaser);\n    return (doc.targetSlugID === targetSlugID);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks slugID, interestIDs\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (!Slugs.isDefined(doc.slugID)) {\n        problems.push(`Bad slugID: ${doc.slugID}`);\n      }\n      _.forEach(doc.interestIDs, (interestID) => {\n        if (!Interests.isDefined(interestID)) {\n          problems.push(`Bad interestID: ${interestID}`);\n        }\n      });\n      if (doc.opportunityID && !Opportunities.isDefined(doc.opportunityID)) {\n        problems.push(`Bad opportunityID: ${doc.opportunityID}`);\n      }\n      if (doc.opportunityID) {\n        if (!doc.targetSlugID) {\n          const slugDoc = Slugs.findDoc({ entityID: doc.opportunityID });\n          const docID = doc._id;\n          const updateData: any = {};\n          updateData.targetSlugID = slugDoc._id;\n          if (slugDoc) {\n            this.collection.update(docID, { $set: updateData });\n          }\n        }\n        if (!Opportunities.isDefined(doc.opportunityID)) {\n          problems.push(`Bad opportunityID ${doc.opportunityID}`);\n        }\n      }\n      if (doc.targetSlugID && !Slugs.isDefined(doc.targetSlugID)) {\n        problems.push(`Bad targetSlugID: ${doc.targetSlugID}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the Teaser docID in a format acceptable to define().\n   * @param docID The docID of a Teaser.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): ITeaserDefine {\n    const doc = this.findDoc(docID);\n    const title = doc.title;\n    const slug = Slugs.getNameFromID(doc.slugID);\n    const author = doc.author;\n    const url = doc.url;\n    const description = doc.description;\n    const duration = doc.duration;\n    const interests = _.map(doc.interestIDs, (interestID) => Interests.findSlugByID(interestID));\n    let targetSlug;\n    if (doc.targetSlugID) {\n      targetSlug = Slugs.getNameFromID(doc.targetSlugID);\n    }\n    const retired = doc.retired;\n    return { title, slug, author, url, description, duration, interests, targetSlug, retired };\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @type {api/teaser.TeaserCollection}\n * @memberOf api/teaser\n */\nexport const Teasers = new TeaserCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/teaser/TeaserCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1022,
    "kind": "variable",
    "name": "Teasers",
    "memberof": "api/teaser/TeaserCollection.ts",
    "static": true,
    "longname": "api/teaser/TeaserCollection.ts~Teasers",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/teaser/TeaserCollection.ts",
    "importStyle": "{Teasers}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 241,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/teaser"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/teaser.TeaserCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1023,
    "kind": "class",
    "name": "TeaserCollection",
    "memberof": "api/teaser/TeaserCollection.ts",
    "static": true,
    "longname": "api/teaser/TeaserCollection.ts~TeaserCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/teaser/TeaserCollection.ts",
    "importStyle": null,
    "description": "Represents a teaser instance, such as \"ACM Webmasters\".",
    "lineNumber": 14,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseSlugCollection.js~BaseSlugCollection"
    ]
  },
  {
    "__docId__": 1024,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/teaser/TeaserCollection.ts~TeaserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/teaser/TeaserCollection.ts~TeaserCollection#constructor",
    "access": "public",
    "description": "Creates the Teaser collection.",
    "lineNumber": 17
  },
  {
    "__docId__": 1025,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/teaser/TeaserCollection.ts~TeaserCollection",
    "static": false,
    "longname": "api/teaser/TeaserCollection.ts~TeaserCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1026,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/teaser/TeaserCollection.ts~TeaserCollection",
    "static": false,
    "longname": "api/teaser/TeaserCollection.ts~TeaserCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1027,
    "kind": "method",
    "name": "define",
    "memberof": "api/teaser/TeaserCollection.ts~TeaserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/teaser/TeaserCollection.ts~TeaserCollection#define",
    "access": "public",
    "description": "Defines a new Teaser video to provide information about an opportunity.",
    "lineNumber": 84,
    "params": [
      {
        "nullable": null,
        "types": [
          "ITeaserDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1028,
    "kind": "method",
    "name": "update",
    "memberof": "api/teaser/TeaserCollection.ts~TeaserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/teaser/TeaserCollection.ts~TeaserCollection#update",
    "access": "public",
    "description": "Update a Teaser. Everything can be updated except the slug.",
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "ITeaserUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1029,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/teaser/TeaserCollection.ts~TeaserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/teaser/TeaserCollection.ts~TeaserCollection#removeIt",
    "access": "public",
    "description": "Remove the Teaser.",
    "lineNumber": 146,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1030,
    "kind": "method",
    "name": "hasInterest",
    "memberof": "api/teaser/TeaserCollection.ts~TeaserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/teaser/TeaserCollection.ts~TeaserCollection#hasInterest",
    "access": "public",
    "description": "Returns true if teaser has the specified interest.",
    "lineNumber": 159,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "teaser",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "interest",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1031,
    "kind": "method",
    "name": "hasTarget",
    "memberof": "api/teaser/TeaserCollection.ts~TeaserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/teaser/TeaserCollection.ts~TeaserCollection#hasTarget",
    "access": "public",
    "description": "Returns true if teaser has the specified slug.",
    "lineNumber": 172,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "teaser",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1032,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/teaser/TeaserCollection.ts~TeaserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/teaser/TeaserCollection.ts~TeaserCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks slugID, interestIDs",
    "lineNumber": 184,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1033,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/teaser/TeaserCollection.ts~TeaserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/teaser/TeaserCollection.ts~TeaserCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the Teaser docID in a format acceptable to define().",
    "lineNumber": 224,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ITeaserDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1034,
    "kind": "file",
    "name": "api/teaser/index.ts",
    "content": "/** @namespace api/teaser */\nimport './TeaserCollection';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/teaser/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1035,
    "kind": "file",
    "name": "api/test/index.ts",
    "content": "/** @namespace api/test */\nimport './test-utilities';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/test/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1036,
    "kind": "file",
    "name": "api/test/test-utilities.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { DDP } from 'meteor/ddp-client';\nimport _ from 'lodash';\nimport { ValidatedMethod } from 'meteor/mdg:validated-method';\nimport { RadGrad } from '../radgrad/RadGrad';\nimport { Users } from '../user/UserCollection';\nimport { removeAllEntities } from '../base/BaseUtilities';\n\n/**\n * Returns the definition array associated with collectionName in the loadJSON structure,\n * or an empty array if none was found.\n * @param loadJSON The load file contents.\n * @param collection The collection of interest.\n * @memberOf api/test\n */\nexport function getDefinitions(loadJSON, collection) {\n  const definitionObj = _.find(loadJSON.collections, (obj) => obj.name === collection);\n  return definitionObj ? definitionObj.contents : [];\n}\n\n/**\n * Given a collection and the loadJSON structure, looks up the definitions and invokes define() on them.\n * @param collection The collection to be loadd.\n * @param loadJSON The structure containing all of the definitions.\n * @param consolep output console.log message if truey.\n * @memberOf api/test\n */\nexport function loadCollection(collection, loadJSON, consolep) {\n  const definitions = getDefinitions(loadJSON, collection.collectionName);\n  if (consolep) {\n    console.log(`Defining ${definitions.length} ${collection.collectionName} documents.`);\n  }\n  _.each(definitions, (definition) => collection.define(definition));\n  if (consolep) {\n    console.log(`Have ${collection.find().count()} documents.`);\n  }\n}\n\n/**\n * Loads data from a modular test fixture file.\n * @param fixtureName The name of the test fixture data file. (located in private/database/modular).\n * @memberOf api/test\n */\nexport function defineTestFixture(fixtureName) {\n  if (Meteor.isServer) {\n    const loadFileName = `database/modular/${fixtureName}`;\n    const loadJSON = JSON.parse(Assets.getText(loadFileName));\n    console.log(`    Loaded ${loadFileName}: ${loadJSON.fixtureDescription}`);\n    _.each(RadGrad.collectionLoadSequence, (collection) => loadCollection(collection, loadJSON, false));\n  }\n}\n\n/**\n * Loads all the data from an array of fixture file names.\n * @param fixtureNames an array of the name of the test fixture data file. (located in private/database/modular).\n * @memberOf api/test\n */\nexport function defineTestFixtures(fixtureNames) {\n  _.each(fixtureNames, (fixtureName) => defineTestFixture(`${fixtureName}.fixture.json`));\n}\n\n// /**\n//  * A validated method that loads the passed fixture file.\n//  */\n// export const defineTestFixtureMethod = new ValidatedMethod({\n//   name: 'test.defineTestFixtureMethod',\n//   validate: null,\n//   run(fixtureName) {\n//     defineTestFixture(fixtureName);\n//     return true;\n//   },\n// });\n\n/**\n * A validated method that loads the passed list of fixture files in the order passed.\n * @memberOf api/test\n */\nexport const defineTestFixturesMethod = new ValidatedMethod({\n  name: 'test.defineTestFixturesMethod',\n  validate: null,\n  run(fixtureNames) {\n    removeAllEntities();\n    defineTestFixtures(fixtureNames);\n    return true;\n  },\n});\n\n/**\n * Returns a Promise that resolves when all RadGrad collections subscriptions are ready.\n * @see {@link https://guide.meteor.com/testing.html#full-app-integration-test}\n * @memberOf api/test\n */\nexport function withRadGradSubscriptions(userID?: string) {\n  return new Promise((resolve) => {\n    _.each(RadGrad.collections, (collection) => collection.subscribe(userID));\n    Users.subscribe();\n    const poll = Meteor.setInterval(() => {\n      if (DDP._allSubscriptionsReady()) {\n        Meteor.clearInterval(poll);\n        resolve();\n      }\n    }, 200);\n  });\n}\n\n/**\n * Returns a Promise that resolves if one can successfully login with the passed credentials.\n * Credentials default to the standard admin username and password.\n * @memberOf api/test\n */\nexport function withLoggedInUser({ username = 'radgrad@hawaii.edu', password = 'foo' } = {}) {\n  return new Promise((resolve, reject) => {\n    Meteor.loginWithPassword(username, password, (error) => {\n      if (error) {\n        console.log('Error: withLoggedInUser', error);\n        reject();\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/test/test-utilities.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1037,
    "kind": "function",
    "name": "getDefinitions",
    "memberof": "api/test/test-utilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/test/test-utilities.ts~getDefinitions",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/test/test-utilities.ts",
    "importStyle": "{getDefinitions}",
    "description": "Returns the definition array associated with collectionName in the loadJSON structure,\nor an empty array if none was found.",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "loadJSON",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "collection",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1038,
    "kind": "function",
    "name": "loadCollection",
    "memberof": "api/test/test-utilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/test/test-utilities.ts~loadCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/test/test-utilities.ts",
    "importStyle": "{loadCollection}",
    "description": "Given a collection and the loadJSON structure, looks up the definitions and invokes define() on them.",
    "lineNumber": 28,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "collection",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "loadJSON",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "consolep",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1039,
    "kind": "function",
    "name": "defineTestFixture",
    "memberof": "api/test/test-utilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/test/test-utilities.ts~defineTestFixture",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/test/test-utilities.ts",
    "importStyle": "{defineTestFixture}",
    "description": "Loads data from a modular test fixture file.",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "fixtureName",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1040,
    "kind": "function",
    "name": "defineTestFixtures",
    "memberof": "api/test/test-utilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/test/test-utilities.ts~defineTestFixtures",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/test/test-utilities.ts",
    "importStyle": "{defineTestFixtures}",
    "description": "Loads all the data from an array of fixture file names.",
    "lineNumber": 58,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "fixtureNames",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1041,
    "kind": "variable",
    "name": "defineTestFixturesMethod",
    "memberof": "api/test/test-utilities.ts",
    "static": true,
    "longname": "api/test/test-utilities.ts~defineTestFixturesMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/test/test-utilities.ts",
    "importStyle": "{defineTestFixturesMethod}",
    "description": "A validated method that loads the passed list of fixture files in the order passed.",
    "lineNumber": 87,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/test"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1042,
    "kind": "function",
    "name": "withRadGradSubscriptions",
    "memberof": "api/test/test-utilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/test/test-utilities.ts~withRadGradSubscriptions",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/test/test-utilities.ts",
    "importStyle": "{withRadGradSubscriptions}",
    "description": "Returns a Promise that resolves when all RadGrad collections subscriptions are ready.",
    "lineNumber": 93,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1043,
    "kind": "function",
    "name": "withLoggedInUser",
    "memberof": "api/test/test-utilities.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/test/test-utilities.ts~withLoggedInUser",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/test/test-utilities.ts",
    "importStyle": "{withLoggedInUser}",
    "description": "Returns a Promise that resolves if one can successfully login with the passed credentials.\nCredentials default to the standard admin username and password.",
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1044,
    "kind": "file",
    "name": "api/user/AdminProfileCollection.ts",
    "content": "import _ from 'lodash';\nimport { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport BaseProfileCollection, { defaultProfilePicture } from './BaseProfileCollection';\nimport { Users } from './UserCollection';\nimport { Interests } from '../interest/InterestCollection';\nimport { CareerGoals } from '../career/CareerGoalCollection';\nimport { Slugs } from '../slug/SlugCollection';\nimport { ROLE } from '../role/Role';\nimport { IProfileDefine, IProfileUpdate } from '../../typings/radgrad';\nimport { FavoriteInterests } from '../favorite/FavoriteInterestCollection';\nimport { FavoriteCareerGoals } from '../favorite/FavoriteCareerGoalCollection';\n\n/**\n * Represents a Admin Profile.\n * @extends api/user.BaseProfileCollection\n * @memberOf api/user\n */\nclass AdminProfileCollection extends BaseProfileCollection {\n  constructor() {\n    super('AdminProfile', new SimpleSchema({}));\n  }\n\n  /**\n   * Defines the profile associated with an Admin and the associated Meteor account.\n   * @param username The username string associated with this profile, which should be an email.\n   * @param firstName The first name.\n   * @param lastName The last name.\n   * @param picture The URL to their picture. (optional, defaults to a default picture.)\n   * @param website The URL to their personal website (optional).\n   * @param interests An array of interests. (optional)\n   * @param careerGoals An array of career goals. (optional)\n   * @throws { Meteor.Error } If username has been previously defined, or if any interests or careerGoals are invalid.\n   * @return { String } The docID of the AdminProfile.\n   */\n  public define({ username, firstName, lastName, picture = defaultProfilePicture, website, interests,\n           careerGoals, retired = false }: IProfileDefine) {\n    if (Meteor.isServer) {\n      const user = Meteor.users.findOne({ username });\n      // console.log(`AdminProfile.define ${user}`);\n      if (!user) {\n        const role = ROLE.ADMIN;\n        Slugs.define({ name: username, entityName: this.getType() });\n        const profileID = this.collection.insert({\n          username, firstName, lastName, role, picture, website, userID: this.getFakeUserId(), retired,\n        });\n        const userID = Users.define({ username, role });\n        this.collection.update(profileID, { $set: { userID } });\n        if (interests) {\n          interests.forEach((interest) => FavoriteInterests.define({ interest, username }));\n        }\n        if (careerGoals) {\n          careerGoals.forEach((careerGoal) => FavoriteCareerGoals.define({ careerGoal, username }));\n        }\n        return profileID;\n      }\n      return this.collection.findOne({ username })._id;\n    }\n    return undefined;\n  }\n\n  /**\n   * Updates the AdminProfile.\n   * You cannot change the username or role once defined.\n   * @param docID the id of the AdminProfile.\n   */\n  public update(docID, { firstName, lastName, picture, website, interests, careerGoals, retired, courseExplorerFilter, opportunityExplorerSortOrder }: IProfileUpdate) {\n    this.assertDefined(docID);\n    const updateData = {};\n    this.updateCommonFields(updateData, { firstName, lastName, picture, website, retired, courseExplorerFilter, opportunityExplorerSortOrder });\n    this.collection.update(docID, { $set: updateData });\n    const profile = this.findDoc(docID);\n    const username = profile.username;\n    if (interests) {\n      FavoriteInterests.removeUser(username);\n      interests.forEach((interest) => FavoriteInterests.define({ interest, username }));\n    }\n    if (careerGoals) {\n      FavoriteCareerGoals.removeUser(username);\n      careerGoals.forEach((careerGoal) => FavoriteCareerGoals.define({ careerGoal, username }));\n    }\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin or Admin.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Admin.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN]);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks the profile common fields and the role..\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    let problems = [];\n    this.find().forEach((doc) => {\n      problems = problems.concat(this.checkIntegrityCommonFields(doc));\n      if (doc.role !== ROLE.ADMIN) {\n        problems.push(`AdminProfile instance does not have ROLE.ADMIN: ${doc}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the AdminProfile docID in a format acceptable to define().\n   * @param docID The docID of a AdminProfile\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IProfileDefine {\n    const doc = this.findDoc(docID);\n    const username = doc.username;\n    const firstName = doc.firstName;\n    const lastName = doc.lastName;\n    const picture = doc.picture;\n    const website = doc.website;\n    const userID = Users.getID(username);\n    const favInterests = FavoriteInterests.findNonRetired({ userID });\n    const interests = _.map(favInterests, (fav) => Interests.findSlugByID(fav.interestID));\n    const favCareerGoals = FavoriteCareerGoals.findNonRetired({ userID });\n    const careerGoals = _.map(favCareerGoals, (fav) => CareerGoals.findSlugByID(fav.careerGoalID));\n    const retired = doc.retired;\n    return { username, firstName, lastName, picture, website, interests, careerGoals, retired };\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @type {api/user.AdminProfileCollection}\n * @memberOf api/user\n */\nexport const AdminProfiles = new AdminProfileCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/AdminProfileCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1045,
    "kind": "variable",
    "name": "AdminProfiles",
    "memberof": "api/user/AdminProfileCollection.ts",
    "static": true,
    "longname": "api/user/AdminProfileCollection.ts~AdminProfiles",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/AdminProfileCollection.ts",
    "importStyle": "{AdminProfiles}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 142,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/user"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/user.AdminProfileCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1046,
    "kind": "class",
    "name": "AdminProfileCollection",
    "memberof": "api/user/AdminProfileCollection.ts",
    "static": true,
    "longname": "api/user/AdminProfileCollection.ts~AdminProfileCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/AdminProfileCollection.ts",
    "importStyle": null,
    "description": "Represents a Admin Profile.",
    "lineNumber": 19,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/user/BaseProfileCollection.js~BaseProfileCollection"
    ]
  },
  {
    "__docId__": 1047,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/user/AdminProfileCollection.ts~AdminProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/AdminProfileCollection.ts~AdminProfileCollection#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true
  },
  {
    "__docId__": 1048,
    "kind": "method",
    "name": "define",
    "memberof": "api/user/AdminProfileCollection.ts~AdminProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/AdminProfileCollection.ts~AdminProfileCollection#define",
    "access": "public",
    "description": "Defines the profile associated with an Admin and the associated Meteor account.",
    "lineNumber": 36,
    "params": [
      {
        "nullable": null,
        "types": [
          "IProfileDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1049,
    "kind": "method",
    "name": "update",
    "memberof": "api/user/AdminProfileCollection.ts~AdminProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/AdminProfileCollection.ts~AdminProfileCollection#update",
    "access": "public",
    "description": "Updates the AdminProfile.\nYou cannot change the username or role once defined.",
    "lineNumber": 67,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IProfileUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1050,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/user/AdminProfileCollection.ts~AdminProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/AdminProfileCollection.ts~AdminProfileCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin or Admin.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 90,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1051,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/user/AdminProfileCollection.ts~AdminProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/AdminProfileCollection.ts~AdminProfileCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks the profile common fields and the role..",
    "lineNumber": 100,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1052,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/user/AdminProfileCollection.ts~AdminProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/AdminProfileCollection.ts~AdminProfileCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the AdminProfile docID in a format acceptable to define().",
    "lineNumber": 116,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IProfileDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1053,
    "kind": "file",
    "name": "api/user/AdvisorProfileCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { AdvisorProfiles } from './AdvisorProfileCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('AdvisorProfileCollection Meteor Methods ', function test() {\n    const collectionName = AdvisorProfiles.getCollectionName();\n    const username = 'glau@hawaii.edu';\n    const firstName = 'Gerald';\n    const lastName = 'Lau';\n    const picture = 'glau.jpg';\n    const website = 'http://glau.github.io';\n    const interests = [];\n    const careerGoals = [];\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      const definitionData = { username, firstName, lastName, picture, website, interests, careerGoals };\n      await defineMethod.callPromise({ collectionName, definitionData });\n    });\n\n    it('Update Method', async function () {\n      const id = AdvisorProfiles.getID(username);\n      await updateMethod.callPromise({ collectionName, updateData: { id, picture: 'glau2.jpg' } });\n    });\n\n    it('Remove Method', async function () {\n      const instance = AdvisorProfiles.getID(username);\n      await removeItMethod.callPromise({ collectionName, instance });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/AdvisorProfileCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1054,
    "kind": "file",
    "name": "api/user/AdvisorProfileCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { AdvisorProfiles } from './AdvisorProfileCollection';\nimport { makeSampleInterestArray, makeSampleInterestSlugArray } from '../interest/SampleInterests';\nimport { makeSampleCareerGoalSlugArray } from '../career/SampleCareerGoals';\nimport { FavoriteInterests } from '../favorite/FavoriteInterestCollection';\nimport { FavoriteCareerGoals } from '../favorite/FavoriteCareerGoalCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('AdvisorProfileCollection', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function tearDown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) { // Test the define and removeIt methods\n      this.timeout(15000);\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(1), fc.lorem(1), fc.lorem(1), fc.lorem(1), (username, firstName, lastName, picture, website) => {\n          const interests = makeSampleInterestArray();\n          const careerGoals = makeSampleCareerGoalSlugArray();\n          const docID = AdvisorProfiles.define({ username, firstName, lastName, picture, website, interests, careerGoals });\n          expect(AdvisorProfiles.isDefined(docID)).to.be.true;\n          expect(FavoriteInterests.count()).to.equal(interests.length);\n          expect(FavoriteCareerGoals.count()).to.equal(careerGoals.length);\n          AdvisorProfiles.removeIt(docID);\n          expect(AdvisorProfiles.isDefined(docID)).to.be.false;\n          expect(FavoriteInterests.count()).to.equal(0);\n          expect(FavoriteCareerGoals.count()).to.equal(0);\n        }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicates', function test2() { // Test if duplicate documents can be defined\n      const username = faker.internet.userName();\n      const firstName = faker.name.firstName();\n      const lastName = faker.name.lastName();\n      const picture = faker.image.imageUrl();\n      const website = faker.internet.url();\n      const interests = makeSampleInterestSlugArray();\n      const careerGoals = makeSampleCareerGoalSlugArray();\n      const docID = AdvisorProfiles.define({ username, firstName, lastName, picture, website, interests, careerGoals });\n      expect(AdvisorProfiles.isDefined(docID)).to.be.true;\n      expect(() => AdvisorProfiles.define({ username, firstName, lastName, picture, website, interests, careerGoals })).to.throw(Error);\n    });\n\n    it('Can update', function test3(done) { // Test updating documents\n      this.timeout(15000);\n      let doc = AdvisorProfiles.findOne({});\n      const docID = doc._id;\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(1), fc.lorem(1), fc.boolean(), (firstName, lastName, picture, retired) => {\n          const website = faker.internet.url();\n          const interests = makeSampleInterestArray();\n          const careerGoals = makeSampleCareerGoalSlugArray();\n          AdvisorProfiles.update(docID, { firstName, lastName, picture, retired, website, interests, careerGoals });\n          doc = AdvisorProfiles.findDoc(docID);\n          expect(doc.firstName).to.equal(firstName);\n          expect(doc.lastName).to.equal(lastName);\n          expect(doc.picture).to.equal(picture);\n          expect(doc.website).to.equal(website);\n          expect(FavoriteInterests.count()).to.equal(interests.length);\n          expect(FavoriteCareerGoals.count()).to.equal(careerGoals.length);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() { // Tests dumpOne and restoreOne\n      const origDoc = AdvisorProfiles.findOne({});\n      let docID = origDoc._id;\n      const dumpObject = AdvisorProfiles.dumpOne(docID);\n      AdvisorProfiles.removeIt(docID);\n      expect(AdvisorProfiles.isDefined(docID)).to.be.false;\n      expect(FavoriteInterests.count()).to.equal(0);\n      expect(FavoriteCareerGoals.count()).to.equal(0);\n      docID = AdvisorProfiles.restoreOne(dumpObject);\n      expect(AdvisorProfiles.isDefined(docID)).to.be.true;\n      const doc = AdvisorProfiles.findDoc(docID);\n      expect(doc.firstName).to.equal(origDoc.firstName);\n      expect(doc.lastName).to.equal(origDoc.lastName);\n      expect(doc.picture).to.equal(origDoc.picture);\n      expect(doc.website).to.equal(origDoc.website);\n    });\n\n    it('Can checkIntegrity no errors', function test5() { // Tests checkIntegrity\n      const problems = AdvisorProfiles.checkIntegrity();\n      expect(problems).to.have.lengthOf(0);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/AdvisorProfileCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1055,
    "kind": "file",
    "name": "api/user/AdvisorProfileCollection.ts",
    "content": "import _ from 'lodash';\nimport { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport BaseProfileCollection, { defaultProfilePicture } from './BaseProfileCollection';\nimport { Users } from './UserCollection';\nimport { Interests } from '../interest/InterestCollection';\nimport { CareerGoals } from '../career/CareerGoalCollection';\nimport { Slugs } from '../slug/SlugCollection';\nimport { ROLE } from '../role/Role';\nimport { IProfileDefine, IProfileUpdate } from '../../typings/radgrad';\nimport { FavoriteInterests } from '../favorite/FavoriteInterestCollection';\nimport { FavoriteCareerGoals } from '../favorite/FavoriteCareerGoalCollection';\n\n/**\n * Represents a Advisor Profile.\n * @extends api/user.BaseProfileCollection\n * @memberOf api/user\n */\nclass AdvisorProfileCollection extends BaseProfileCollection {\n  constructor() {\n    super('AdvisorProfile', new SimpleSchema({}));\n  }\n\n  /**\n   * Defines the profile associated with an Advisor and the associated Meteor account.\n   * @param username The username string associated with this profile, which should be an email.\n   * @param firstName The first name.\n   * @param lastName The last name.\n   * @param picture The URL to their picture. (optional, defaults to a default picture.)\n   * @param website The URL to their personal website (optional).\n   * @param interests An array of interests. (optional)\n   * @param careerGoals An array of career goals. (optional)\n   * @throws { Meteor.Error } If username has been previously defined, or if any interests or careerGoals are invalid.\n   * @return { String } The docID of the AdvisorProfile.\n   */\n  public define({ username, firstName, lastName, picture = defaultProfilePicture, website, interests,\n           careerGoals, retired = false }: IProfileDefine) {\n    if (Meteor.isServer) {\n      const role = ROLE.ADVISOR;\n      Slugs.define({ name: username, entityName: this.getType() });\n      const profileID = this.collection.insert({\n        username, firstName, lastName, role, picture, website, userID: this.getFakeUserId(), retired });\n      const userID = Users.define({ username, role });\n      this.collection.update(profileID, { $set: { userID } });\n      if (interests) {\n        interests.forEach((interest) => FavoriteInterests.define({ interest, username }));\n      }\n      if (careerGoals) {\n        careerGoals.forEach((careerGoal) => FavoriteCareerGoals.define({ careerGoal, username }));\n      }\n      return profileID;\n    }\n    return undefined;\n  }\n\n  /**\n   * Updates the AdvisorProfile.\n   * You cannot change the username or role once defined.\n   * @param docID the id of the AdvisorProfile.\n   */\n  public update(docID, { firstName, lastName, picture, website, interests, careerGoals, retired, courseExplorerFilter, opportunityExplorerSortOrder }: IProfileUpdate) {\n    this.assertDefined(docID);\n    const updateData = {};\n    this.updateCommonFields(updateData, { firstName, lastName, picture, website, retired, courseExplorerFilter, opportunityExplorerSortOrder });\n    this.collection.update(docID, { $set: updateData });\n    const profile = this.findDoc(docID);\n    const username = profile.username;\n    if (interests) {\n      FavoriteInterests.removeUser(username);\n      interests.forEach((interest) => FavoriteInterests.define({ interest, username }));\n    }\n    if (careerGoals) {\n      FavoriteCareerGoals.removeUser(username);\n      careerGoals.forEach((careerGoal) => FavoriteCareerGoals.define({ careerGoal, username }));\n    }\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin or Advisor.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR]);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks the profile common fields and the role..\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    let problems = [];\n    this.find().forEach((doc) => {\n      problems = problems.concat(this.checkIntegrityCommonFields(doc));\n      if (doc.role !== ROLE.ADVISOR) {\n        problems.push(`AdvisorProfile instance does not have ROLE.ADVISOR: ${doc}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the AdvisorProfile docID in a format acceptable to define().\n   * @param docID The docID of a AdvisorProfile\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IProfileDefine {\n    const doc = this.findDoc(docID);\n    const username = doc.username;\n    const firstName = doc.firstName;\n    const lastName = doc.lastName;\n    const picture = doc.picture;\n    const website = doc.website;\n    const userID = Users.getID(username);\n    const favInterests = FavoriteInterests.findNonRetired({ userID });\n    const interests = _.map(favInterests, (fav) => Interests.findSlugByID(fav.interestID));\n    const favCareerGoals = FavoriteCareerGoals.findNonRetired({ userID });\n    const careerGoals = _.map(favCareerGoals, (fav) => CareerGoals.findSlugByID(fav.careerGoalID));\n    const retired = doc.retired;\n    return { username, firstName, lastName, picture, website, interests, careerGoals, retired };\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @type {api/user.AdvisorProfileCollection}\n * @memberOf api/user\n */\nexport const AdvisorProfiles = new AdvisorProfileCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/AdvisorProfileCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1056,
    "kind": "variable",
    "name": "AdvisorProfiles",
    "memberof": "api/user/AdvisorProfileCollection.ts",
    "static": true,
    "longname": "api/user/AdvisorProfileCollection.ts~AdvisorProfiles",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/AdvisorProfileCollection.ts",
    "importStyle": "{AdvisorProfiles}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 137,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/user"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/user.AdvisorProfileCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1057,
    "kind": "class",
    "name": "AdvisorProfileCollection",
    "memberof": "api/user/AdvisorProfileCollection.ts",
    "static": true,
    "longname": "api/user/AdvisorProfileCollection.ts~AdvisorProfileCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/AdvisorProfileCollection.ts",
    "importStyle": null,
    "description": "Represents a Advisor Profile.",
    "lineNumber": 19,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/user/BaseProfileCollection.js~BaseProfileCollection"
    ]
  },
  {
    "__docId__": 1058,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/user/AdvisorProfileCollection.ts~AdvisorProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/AdvisorProfileCollection.ts~AdvisorProfileCollection#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true
  },
  {
    "__docId__": 1059,
    "kind": "method",
    "name": "define",
    "memberof": "api/user/AdvisorProfileCollection.ts~AdvisorProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/AdvisorProfileCollection.ts~AdvisorProfileCollection#define",
    "access": "public",
    "description": "Defines the profile associated with an Advisor and the associated Meteor account.",
    "lineNumber": 36,
    "params": [
      {
        "nullable": null,
        "types": [
          "IProfileDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1060,
    "kind": "method",
    "name": "update",
    "memberof": "api/user/AdvisorProfileCollection.ts~AdvisorProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/AdvisorProfileCollection.ts~AdvisorProfileCollection#update",
    "access": "public",
    "description": "Updates the AdvisorProfile.\nYou cannot change the username or role once defined.",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IProfileUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1061,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/user/AdvisorProfileCollection.ts~AdvisorProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/AdvisorProfileCollection.ts~AdvisorProfileCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin or Advisor.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 84,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1062,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/user/AdvisorProfileCollection.ts~AdvisorProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/AdvisorProfileCollection.ts~AdvisorProfileCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks the profile common fields and the role..",
    "lineNumber": 94,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1063,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/user/AdvisorProfileCollection.ts~AdvisorProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/AdvisorProfileCollection.ts~AdvisorProfileCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the AdvisorProfile docID in a format acceptable to define().",
    "lineNumber": 110,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IProfileDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1064,
    "kind": "file",
    "name": "api/user/BaseProfileCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport SimpleSchema from 'simpl-schema';\nimport BaseSlugCollection from '../base/BaseSlugCollection';\nimport { AcademicYearInstances } from '../degree-plan/AcademicYearInstanceCollection';\nimport { AdvisorLogs } from '../log/AdvisorLogCollection';\nimport { CourseInstances } from '../course/CourseInstanceCollection';\nimport { FeedbackInstances } from '../feedback/FeedbackInstanceCollection';\nimport { Feeds } from '../feed/FeedCollection';\nimport { OpportunityInstances } from '../opportunity/OpportunityInstanceCollection';\nimport { Slugs } from '../slug/SlugCollection';\nimport { Users } from './UserCollection';\nimport { ROLE } from '../role/Role';\nimport { VerificationRequests } from '../verification/VerificationRequestCollection';\nimport { IBaseProfile } from '../../typings/radgrad';\nimport { FavoriteAcademicPlans } from '../favorite/FavoriteAcademicPlanCollection';\nimport { FavoriteCareerGoals } from '../favorite/FavoriteCareerGoalCollection';\nimport { FavoriteCourses } from '../favorite/FavoriteCourseCollection';\nimport { FavoriteInterests } from '../favorite/FavoriteInterestCollection';\nimport { FavoriteOpportunities } from '../favorite/FavoriteOpportunityCollection';\n\nexport const defaultProfilePicture = '/images/default-profile-picture.png';\n\n/**\n * Set up the object to be used to map role names to their corresponding collections.\n * @memberOf api/user\n */\nconst rolesToCollectionNames = {};\nrolesToCollectionNames[ROLE.ADVISOR] = 'AdvisorProfileCollection';\nrolesToCollectionNames[ROLE.FACULTY] = 'FacultyProfileCollection';\nrolesToCollectionNames[ROLE.MENTOR] = 'MentorProfileCollection';\nrolesToCollectionNames[ROLE.STUDENT] = 'StudentProfileCollection';\n\n/**\n * BaseProfileCollection is an abstract superclass of all profile collections.\n * @extends api/base.BaseSlugCollection\n * @memberOf api/user\n */\nclass BaseProfileCollection extends BaseSlugCollection {\n  constructor(type, schema) {\n    super(type, schema.extend(new SimpleSchema({\n      username: String,\n      firstName: String,\n      lastName: String,\n      role: String,\n      picture: { type: String, optional: true },\n      website: { type: String, optional: true },\n      userID: SimpleSchema.RegEx.Id,\n      retired: { type: Boolean, optional: true },\n      shareUsername: { type: Boolean, optional: true },\n      sharePicture: { type: Boolean, optional: true },\n      shareWebsite: { type: Boolean, optional: true },\n      shareInterests: { type: Boolean, optional: true },\n      shareCareerGoals: { type: Boolean, optional: true },\n      courseExplorerFilter: { type: String, optional: true },\n      opportunityExplorerSortOrder: { type: String, optional: true },\n    })));\n  }\n\n  /**\n   * The subclass methods need a way to create a profile with a valid, though fake, userId.\n   * @returns {string}\n   */\n  public getFakeUserId() {\n    return 'ABCDEFGHJKLMNPQRS';\n  }\n\n  /**\n   * Returns the name of the collection associated with the given profile.\n   * @param profile A Profile object.\n   * @returns  { String } The name of a profile collection.\n   */\n  public getCollectionNameForProfile(profile: IBaseProfile) {\n    return rolesToCollectionNames[profile.role];\n  }\n\n  /**\n   * Returns the Profile's docID associated with instance, or throws an error if it cannot be found.\n   * If instance is a docID, then it is returned unchanged. If instance is a slug, its corresponding docID is returned.\n   * If instance is the value for the username field in this collection, then return that document's ID.\n   * If instance is the userID for the profile, then return the Profile's ID.\n   * If instance is an object with an _id field, then that value is checked to see if it's in the collection.\n   * @param { String } instance Either a valid docID, valid userID or a valid slug string.\n   * @returns { String } The docID associated with instance.\n   * @throws { Meteor.Error } If instance is not a docID or a slug.\n   */\n  public getID(instance) {\n    let id;\n    // If we've been passed a document, check to see if it has an _id field and use that if available.\n    if (_.isObject(instance) && _.has(instance, '_id')) {\n      instance = instance['_id']; // eslint-disable-line no-param-reassign, dot-notation\n    }\n    // If instance is the value of the username field for some document in the collection, then return its ID.\n    const usernameBasedDoc = this.collection.findOne({ username: instance });\n    if (usernameBasedDoc) {\n      return usernameBasedDoc._id;\n    }\n    // If instance is the value of the userID field for some document in the collection, then return its ID.\n    const userIDBasedDoc = this.collection.findOne({ userID: instance });\n    if (userIDBasedDoc) {\n      return userIDBasedDoc._id;\n    }\n    // Otherwise see if we can find instance as a docID or as a slug.\n    try {\n      id = (this.collection.findOne({ _id: instance })) ? instance : this.findIdBySlug(instance);\n    } catch (err) {\n      throw new Meteor.Error(`Error in ${this.collectionName} getID(): Failed to convert ${instance} to an ID.`);\n    }\n    return id;\n  }\n\n  /**\n   * Returns the profile associated with the specified user.\n   * @param user The user (either their username (email) or their userID).\n   * @return The profile document.\n   * @throws { Meteor.Error } If user is not a valid user, or profile is not found.\n   */\n  public getProfile(user) {\n    const userID = Users.getID(user);\n    const doc = this.collection.findOne({ userID });\n    if (!doc) {\n      throw new Meteor.Error(`No profile found for user ${user}`);\n    }\n    return doc;\n  }\n\n  /**\n   * Returns the profile document associated with username, or null if none was found.\n   * @param username A username, such as 'johnson@hawaii.edu'.\n   * @returns The profile document, or null.\n   */\n  public findByUsername(username) {\n    return this.collection.findOne({ username });\n  }\n\n  /**\n   * Returns non-null if the user has a profile in this collection.\n   * @param user The user (either their username (email) or their userID).\n   * @return The profile document if the profile exists, or null if not found.\n   * @throws { Meteor.Error } If user is not a valid user.\n   */\n  public hasProfile(user) {\n    const userID = Users.getID(user);\n    return this.collection.findOne({ userID });\n  }\n\n  /**\n   * Returns true if the user has set their picture.\n   * @param user The user (either their username (email) or their userID).\n   * @return {boolean}\n   */\n  public hasSetPicture(user) {\n    const userID = Users.getID(user);\n    const doc = this.collection.findOne({ userID });\n    // console.log(doc);\n    if (!doc) {\n      return false;\n    }\n    return !(_.isNil(doc.picture) || doc.picture === defaultProfilePicture);\n  }\n\n  /**\n   * Returns the userID associated with the given profile.\n   * @param profileID The ID of the profile.\n   * @returns The associated userID.\n   */\n  public getUserID(profileID) {\n    return this.collection.findOne(profileID).userID;\n  }\n\n  /**\n   * Internal method for use by subclasses.\n   * @param doc The profile document.\n   * @returns {Array} An array of problems\n   */\n  protected checkIntegrityCommonFields(doc) {\n    const problems = [];\n    if (!Slugs.isDefined(doc.username)) {\n      problems.push(`Bad username: ${doc.username}`);\n    }\n    if (!Users.isDefined(doc.userID)) {\n      problems.push(`Bad userID: ${doc.userID}`);\n    }\n    return problems;\n  }\n\n  /**\n   * Removes this profile, given its profile ID.\n   * Also removes this user from Meteor Accounts.\n   * @param profileID The ID for this profile object.\n   */\n  public removeIt(profileID) {\n    const profile = this.collection.findOne({ _id: profileID });\n    const userID = profile.userID;\n    if (!Users.isReferenced(userID)) {\n      // Automatically remove references to user from other collections that are \"private\" to this user.\n      _.forEach([Feeds, CourseInstances, OpportunityInstances, AcademicYearInstances, FeedbackInstances, AdvisorLogs,\n        VerificationRequests, FavoriteAcademicPlans, FavoriteCareerGoals, FavoriteCourses, FavoriteInterests,\n        FavoriteOpportunities], (collection) => collection.removeUser(userID));\n      Meteor.users.remove({ _id: userID });\n      Slugs.getCollection().remove({ name: profile.username });\n      return super.removeIt(profileID);\n    }\n    return null;\n  }\n\n  /**\n   * Internal method for use by subclasses.\n   * Destructively modifies updateData with the values of the passed fields.\n   * Call this function for side-effect only.\n   */\n  protected updateCommonFields(updateData, { firstName, lastName, picture, website, retired, courseExplorerFilter, opportunityExplorerSortOrder }) {\n    if (firstName) {\n      updateData.firstName = firstName; // eslint-disable-line no-param-reassign\n    }\n    if (lastName) {\n      updateData.lastName = lastName; // eslint-disable-line no-param-reassign\n    }\n    if (_.isString(picture)) {\n      updateData.picture = picture; // eslint-disable-line no-param-reassign\n    }\n    if (_.isString(website)) {\n      updateData.website = website; // eslint-disable-line no-param-reassign\n    }\n    if (_.isBoolean(retired)) {\n      updateData.retired = retired; // eslint-disable-line no-param-reassign\n    }\n    if (_.isString(courseExplorerFilter)) {\n      updateData.courseExplorerFilter = courseExplorerFilter; // eslint-disable-line no-param-reassign\n    }\n    if (_.isString(opportunityExplorerSortOrder)) {\n      updateData.opportunityExplorerSortOrder = opportunityExplorerSortOrder; // eslint-disable-line no-param-reassign\n    }\n    // console.log('_updateCommonFields', updateData);\n  }\n}\n\n/**\n * The BaseProfileCollection used by all Profile classes.\n * @memberOf api/user\n */\nexport default BaseProfileCollection;\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/BaseProfileCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1065,
    "kind": "variable",
    "name": "defaultProfilePicture",
    "memberof": "api/user/BaseProfileCollection.ts",
    "static": true,
    "longname": "api/user/BaseProfileCollection.ts~defaultProfilePicture",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/BaseProfileCollection.ts",
    "importStyle": "{defaultProfilePicture}",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1066,
    "kind": "variable",
    "name": "rolesToCollectionNames",
    "memberof": "api/user/BaseProfileCollection.ts",
    "static": true,
    "longname": "api/user/BaseProfileCollection.ts~rolesToCollectionNames",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/user/BaseProfileCollection.ts",
    "importStyle": null,
    "description": "Set up the object to be used to map role names to their corresponding collections.",
    "lineNumber": 25,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/user"
      }
    ],
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1067,
    "kind": "class",
    "name": "BaseProfileCollection",
    "memberof": "api/user/BaseProfileCollection.ts",
    "static": true,
    "longname": "api/user/BaseProfileCollection.ts~BaseProfileCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/BaseProfileCollection.ts",
    "importStyle": "BaseProfileCollection",
    "description": "BaseProfileCollection is an abstract superclass of all profile collections.",
    "lineNumber": 39,
    "interface": false,
    "extends": [
      "api/base/BaseSlugCollection.js~BaseSlugCollection"
    ]
  },
  {
    "__docId__": 1068,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/user/BaseProfileCollection.ts~BaseProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/BaseProfileCollection.ts~BaseProfileCollection#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true
  },
  {
    "__docId__": 1069,
    "kind": "method",
    "name": "getFakeUserId",
    "memberof": "api/user/BaseProfileCollection.ts~BaseProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/BaseProfileCollection.ts~BaseProfileCollection#getFakeUserId",
    "access": "public",
    "description": "The subclass methods need a way to create a profile with a valid, though fake, userId.",
    "lineNumber": 64,
    "params": [],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1070,
    "kind": "method",
    "name": "getCollectionNameForProfile",
    "memberof": "api/user/BaseProfileCollection.ts~BaseProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/BaseProfileCollection.ts~BaseProfileCollection#getCollectionNameForProfile",
    "access": "public",
    "description": "Returns the name of the collection associated with the given profile.",
    "lineNumber": 73,
    "params": [
      {
        "nullable": null,
        "types": [
          "IBaseProfile"
        ],
        "spread": false,
        "optional": false,
        "name": "profile",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1071,
    "kind": "method",
    "name": "getID",
    "memberof": "api/user/BaseProfileCollection.ts~BaseProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/BaseProfileCollection.ts~BaseProfileCollection#getID",
    "access": "public",
    "description": "Returns the Profile's docID associated with instance, or throws an error if it cannot be found.\nIf instance is a docID, then it is returned unchanged. If instance is a slug, its corresponding docID is returned.\nIf instance is the value for the username field in this collection, then return that document's ID.\nIf instance is the userID for the profile, then return the Profile's ID.\nIf instance is an object with an _id field, then that value is checked to see if it's in the collection.",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "instance",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1072,
    "kind": "method",
    "name": "getProfile",
    "memberof": "api/user/BaseProfileCollection.ts~BaseProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/BaseProfileCollection.ts~BaseProfileCollection#getProfile",
    "access": "public",
    "description": "Returns the profile associated with the specified user.",
    "lineNumber": 118,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1073,
    "kind": "method",
    "name": "findByUsername",
    "memberof": "api/user/BaseProfileCollection.ts~BaseProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/BaseProfileCollection.ts~BaseProfileCollection#findByUsername",
    "access": "public",
    "description": "Returns the profile document associated with username, or null if none was found.",
    "lineNumber": 132,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1074,
    "kind": "method",
    "name": "hasProfile",
    "memberof": "api/user/BaseProfileCollection.ts~BaseProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/BaseProfileCollection.ts~BaseProfileCollection#hasProfile",
    "access": "public",
    "description": "Returns non-null if the user has a profile in this collection.",
    "lineNumber": 142,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1075,
    "kind": "method",
    "name": "hasSetPicture",
    "memberof": "api/user/BaseProfileCollection.ts~BaseProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/BaseProfileCollection.ts~BaseProfileCollection#hasSetPicture",
    "access": "public",
    "description": "Returns true if the user has set their picture.",
    "lineNumber": 152,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1076,
    "kind": "method",
    "name": "getUserID",
    "memberof": "api/user/BaseProfileCollection.ts~BaseProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/BaseProfileCollection.ts~BaseProfileCollection#getUserID",
    "access": "public",
    "description": "Returns the userID associated with the given profile.",
    "lineNumber": 167,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "profileID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1077,
    "kind": "method",
    "name": "checkIntegrityCommonFields",
    "memberof": "api/user/BaseProfileCollection.ts~BaseProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/BaseProfileCollection.ts~BaseProfileCollection#checkIntegrityCommonFields",
    "access": "public",
    "description": "Internal method for use by subclasses.",
    "lineNumber": 176,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "doc",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1078,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/user/BaseProfileCollection.ts~BaseProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/BaseProfileCollection.ts~BaseProfileCollection#removeIt",
    "access": "public",
    "description": "Removes this profile, given its profile ID.\nAlso removes this user from Meteor Accounts.",
    "lineNumber": 192,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "profileID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1079,
    "kind": "method",
    "name": "updateCommonFields",
    "memberof": "api/user/BaseProfileCollection.ts~BaseProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/BaseProfileCollection.ts~BaseProfileCollection#updateCommonFields",
    "access": "public",
    "description": "Internal method for use by subclasses.\nDestructively modifies updateData with the values of the passed fields.\nCall this function for side-effect only.",
    "lineNumber": 212,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "updateData",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1080,
    "kind": "file",
    "name": "api/user/FacultyProfileCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { FacultyProfiles } from './FacultyProfileCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('FacultyProfileCollection Meteor Methods ', function test() {\n    const collectionName = FacultyProfiles.getCollectionName();\n    const username = 'esb@hawaii.edu';\n    const firstName = 'Edo';\n    const lastName = 'Biagioni';\n    const picture = 'esb.jpg';\n    const website = 'http://esb.github.io';\n    const interests = [];\n    const careerGoals = [];\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      const definitionData = { username, firstName, lastName, picture, website, interests, careerGoals };\n      await defineMethod.callPromise({ collectionName, definitionData });\n    });\n\n    it('Update Method', async function () {\n      const id = FacultyProfiles.getID(username);\n      await updateMethod.callPromise({ collectionName, updateData: { id, picture: 'esb2.jpg' } });\n    });\n\n    it('Remove Method', async function () {\n      const instance = FacultyProfiles.getID(username);\n      await removeItMethod.callPromise({ collectionName, instance });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/FacultyProfileCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1081,
    "kind": "file",
    "name": "api/user/FacultyProfileCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { FacultyProfiles } from './FacultyProfileCollection';\nimport { makeSampleInterestArray, makeSampleInterestSlugArray } from '../interest/SampleInterests';\nimport { makeSampleCareerGoalSlugArray } from '../career/SampleCareerGoals';\nimport { FavoriteInterests } from '../favorite/FavoriteInterestCollection';\nimport { FavoriteCareerGoals } from '../favorite/FavoriteCareerGoalCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('FacultyProfileCollection', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function tearDown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) { // Test the define and removeIt methods\n      this.timeout(15000);\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(1), fc.lorem(1), fc.lorem(1), fc.lorem(1), (username, firstName, lastName, picture, website) => {\n          const interests = makeSampleInterestArray();\n          const careerGoals = makeSampleCareerGoalSlugArray();\n          const docID = FacultyProfiles.define({ username, firstName, lastName, picture, website, interests, careerGoals });\n          expect(FacultyProfiles.isDefined(docID)).to.be.true;\n          expect(FavoriteInterests.count()).to.equal(interests.length);\n          expect(FavoriteCareerGoals.count()).to.equal(careerGoals.length);\n          FacultyProfiles.removeIt(docID);\n          expect(FacultyProfiles.isDefined(docID)).to.be.false;\n          expect(FavoriteInterests.count()).to.equal(0);\n          expect(FavoriteCareerGoals.count()).to.equal(0);\n        }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicates', function test2() { // Test if duplicate documents can be defined\n      const username = faker.internet.userName();\n      const firstName = faker.name.firstName();\n      const lastName = faker.name.lastName();\n      const picture = faker.image.imageUrl();\n      const website = faker.internet.url();\n      const interests = makeSampleInterestSlugArray();\n      const careerGoals = makeSampleCareerGoalSlugArray();\n      const docID = FacultyProfiles.define({ username, firstName, lastName, picture, website, interests, careerGoals });\n      expect(FacultyProfiles.isDefined(docID)).to.be.true;\n      expect(() => FacultyProfiles.define({ username, firstName, lastName, picture, website, interests, careerGoals })).to.throw(Error);\n    });\n\n    it('Can update', function test3(done) { // Test updating documents\n      this.timeout(15000);\n      let doc = FacultyProfiles.findOne({});\n      const docID = doc._id;\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(1), fc.lorem(1), fc.boolean(), (firstName, lastName, picture, retired) => {\n          const website = faker.internet.url();\n          const interests = makeSampleInterestArray();\n          const careerGoals = makeSampleCareerGoalSlugArray();\n          FacultyProfiles.update(docID, { firstName, lastName, picture, retired, website, interests, careerGoals });\n          doc = FacultyProfiles.findDoc(docID);\n          expect(doc.firstName).to.equal(firstName);\n          expect(doc.lastName).to.equal(lastName);\n          expect(doc.picture).to.equal(picture);\n          expect(doc.website).to.equal(website);\n          expect(FavoriteInterests.count()).to.equal(interests.length);\n          expect(FavoriteCareerGoals.count()).to.equal(careerGoals.length);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() { // Tests dumpOne and restoreOne\n      const origDoc = FacultyProfiles.findOne({});\n      let docID = origDoc._id;\n      const dumpObject = FacultyProfiles.dumpOne(docID);\n      FacultyProfiles.removeIt(docID);\n      expect(FacultyProfiles.isDefined(docID)).to.be.false;\n      expect(FavoriteInterests.count()).to.equal(0);\n      expect(FavoriteCareerGoals.count()).to.equal(0);\n      docID = FacultyProfiles.restoreOne(dumpObject);\n      expect(FacultyProfiles.isDefined(docID)).to.be.true;\n      const doc = FacultyProfiles.findDoc(docID);\n      expect(doc.firstName).to.equal(origDoc.firstName);\n      expect(doc.lastName).to.equal(origDoc.lastName);\n      expect(doc.picture).to.equal(origDoc.picture);\n      expect(doc.website).to.equal(origDoc.website);\n    });\n\n    it('Can checkIntegrity no errors', function test5() { // Tests checkIntegrity\n      const problems = FacultyProfiles.checkIntegrity();\n      expect(problems).to.have.lengthOf(0);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/FacultyProfileCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1082,
    "kind": "file",
    "name": "api/user/FacultyProfileCollection.ts",
    "content": "import _ from 'lodash';\nimport { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport BaseProfileCollection, { defaultProfilePicture } from './BaseProfileCollection';\nimport { Users } from './UserCollection';\nimport { Interests } from '../interest/InterestCollection';\nimport { CareerGoals } from '../career/CareerGoalCollection';\nimport { Slugs } from '../slug/SlugCollection';\nimport { ROLE } from '../role/Role';\nimport { IProfileDefine, IProfileUpdate } from '../../typings/radgrad';\nimport { FavoriteInterests } from '../favorite/FavoriteInterestCollection';\nimport { FavoriteCareerGoals } from '../favorite/FavoriteCareerGoalCollection';\n\n/**\n * Represents a Faculty Profile.\n * @extends api/user.BaseProfileCollection\n * @memberOf api/user\n */\nclass FacultyProfileCollection extends BaseProfileCollection {\n  constructor() {\n    super('FacultyProfile', new SimpleSchema({}));\n  }\n\n  /**\n   * Defines the profile associated with a Faculty.\n   * @param username The username string associated with this profile, which should be an email.\n   * @param firstName The first name.\n   * @param lastName The last name.\n   * @param picture The URL to their picture. (optional, defaults to a default picture.)\n   * @param website The URL to their personal website (optional).\n   * @param interests An array of interests. (optional)\n   * @param careerGoals An array of career goals. (optional)\n   * @throws { Meteor.Error } If username has been previously defined, or if any interests or careerGoals are invalid.\n   * @return { String } The docID of the FacultyProfile.\n   */\n  public define({ username, firstName, lastName, picture = defaultProfilePicture, website, interests,\n           careerGoals, retired = false }: IProfileDefine) {\n    if (Meteor.isServer) {\n      const role = ROLE.FACULTY;\n      Slugs.define({ name: username, entityName: this.getType() });\n      const profileID = this.collection.insert({\n        username, firstName, lastName, role, picture, website, userID: this.getFakeUserId(), retired });\n      const userID = Users.define({ username, role });\n      this.collection.update(profileID, { $set: { userID } });\n      if (interests) {\n        interests.forEach((interest) => FavoriteInterests.define({ interest, username }));\n      }\n      if (careerGoals) {\n        careerGoals.forEach((careerGoal) => FavoriteCareerGoals.define({ careerGoal, username }));\n      }\n      return profileID;\n    }\n    return undefined;\n  }\n\n  /**\n   * Updates the FacultyProfile.\n   * You cannot change the username or role once defined.\n   * @param docID the id of the FacultyProfile.\n   */\n  public update(docID: string, { firstName, lastName, picture, website, interests, careerGoals, retired, courseExplorerFilter, opportunityExplorerSortOrder }: IProfileUpdate) {\n    this.assertDefined(docID);\n    const updateData = {};\n    this.updateCommonFields(updateData, { firstName, lastName, picture, website, retired, courseExplorerFilter, opportunityExplorerSortOrder });\n    this.collection.update(docID, { $set: updateData });\n    const profile = this.findDoc(docID);\n    const username = profile.username;\n    if (interests) {\n      FavoriteInterests.removeUser(username);\n      interests.forEach((interest) => FavoriteInterests.define({ interest, username }));\n    }\n    if (careerGoals) {\n      FavoriteCareerGoals.removeUser(username);\n      careerGoals.forEach((careerGoal) => FavoriteCareerGoals.define({ careerGoal, username }));\n    }\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Faculty or\n   * Advisor.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Faculty.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.FACULTY]);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks the profile common fields and the role..\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    let problems = [];\n    this.find().forEach((doc) => {\n      problems = problems.concat(this.checkIntegrityCommonFields(doc));\n      if (doc.role !== ROLE.FACULTY) {\n        problems.push(`FacultyProfile instance does not have ROLE.FACULTY: ${doc}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the FacultyProfile docID in a format acceptable to define().\n   * @param docID The docID of a FacultyProfile\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IProfileDefine {\n    const doc = this.findDoc(docID);\n    const username = doc.username;\n    const firstName = doc.firstName;\n    const lastName = doc.lastName;\n    const picture = doc.picture;\n    const website = doc.website;\n    const userID = Users.getID(username);\n    const favInterests = FavoriteInterests.findNonRetired({ userID });\n    const interests = _.map(favInterests, (fav) => Interests.findSlugByID(fav.interestID));\n    const favCareerGoals = FavoriteCareerGoals.findNonRetired({ userID });\n    const careerGoals = _.map(favCareerGoals, (fav) => CareerGoals.findSlugByID(fav.careerGoalID));\n    const retired = doc.retired;\n    return { username, firstName, lastName, picture, website, interests, careerGoals, retired };\n  }\n}\n\n/**\n * Provides the singleton instance.\n * @type {api/user.FacultyProfileCollection}\n * @memberOf api/user\n */\nexport const FacultyProfiles = new FacultyProfileCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/FacultyProfileCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1083,
    "kind": "variable",
    "name": "FacultyProfiles",
    "memberof": "api/user/FacultyProfileCollection.ts",
    "static": true,
    "longname": "api/user/FacultyProfileCollection.ts~FacultyProfiles",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/FacultyProfileCollection.ts",
    "importStyle": "{FacultyProfiles}",
    "description": "Provides the singleton instance.",
    "lineNumber": 138,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/user"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/user.FacultyProfileCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1084,
    "kind": "class",
    "name": "FacultyProfileCollection",
    "memberof": "api/user/FacultyProfileCollection.ts",
    "static": true,
    "longname": "api/user/FacultyProfileCollection.ts~FacultyProfileCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/FacultyProfileCollection.ts",
    "importStyle": null,
    "description": "Represents a Faculty Profile.",
    "lineNumber": 19,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/user/BaseProfileCollection.js~BaseProfileCollection"
    ]
  },
  {
    "__docId__": 1085,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/user/FacultyProfileCollection.ts~FacultyProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/FacultyProfileCollection.ts~FacultyProfileCollection#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true
  },
  {
    "__docId__": 1086,
    "kind": "method",
    "name": "define",
    "memberof": "api/user/FacultyProfileCollection.ts~FacultyProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/FacultyProfileCollection.ts~FacultyProfileCollection#define",
    "access": "public",
    "description": "Defines the profile associated with a Faculty.",
    "lineNumber": 36,
    "params": [
      {
        "nullable": null,
        "types": [
          "IProfileDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1087,
    "kind": "method",
    "name": "update",
    "memberof": "api/user/FacultyProfileCollection.ts~FacultyProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/FacultyProfileCollection.ts~FacultyProfileCollection#update",
    "access": "public",
    "description": "Updates the FacultyProfile.\nYou cannot change the username or role once defined.",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IProfileUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1088,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/user/FacultyProfileCollection.ts~FacultyProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/FacultyProfileCollection.ts~FacultyProfileCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Faculty or\nAdvisor.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 85,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1089,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/user/FacultyProfileCollection.ts~FacultyProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/FacultyProfileCollection.ts~FacultyProfileCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks the profile common fields and the role..",
    "lineNumber": 95,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1090,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/user/FacultyProfileCollection.ts~FacultyProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/FacultyProfileCollection.ts~FacultyProfileCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the FacultyProfile docID in a format acceptable to define().",
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IProfileDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1091,
    "kind": "file",
    "name": "api/user/MentorProfileCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { MentorProfiles } from './MentorProfileCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('MentorProfileCollection Meteor Methods ', function test() {\n    const collectionName = MentorProfiles.getCollectionName();\n    const username = 'rbrewer@tableau.com';\n    const firstName = 'Robert';\n    const lastName = 'Brewer';\n    const picture = 'foo.jpg';\n    const website = 'http://rbrewer.github.io';\n    const interests = [];\n    const careerGoals = [];\n    const company = 'Tableau Inc';\n    const career = 'Software Engineer';\n    const location = 'San Francisco, CA';\n    const linkedin = 'robertsbrewer';\n    const motivation = 'Help future students.';\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      const definitionData = {\n        username, firstName, lastName, picture, website, interests, careerGoals, company,\n        career, location, linkedin, motivation,\n      };\n      await defineMethod.callPromise({ collectionName, definitionData });\n    });\n\n    it('Update Method', async function () {\n      const id = MentorProfiles.getID(username);\n      await updateMethod.callPromise({ collectionName, updateData: { id, company: 'Google, Inc.' } });\n    });\n\n    it('Remove Method', async function () {\n      const instance = MentorProfiles.getID(username);\n      await removeItMethod.callPromise({ collectionName, instance });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/MentorProfileCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1092,
    "kind": "file",
    "name": "api/user/MentorProfileCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { MentorProfiles } from './MentorProfileCollection';\nimport { makeSampleInterestArray, makeSampleInterestSlugArray } from '../interest/SampleInterests';\nimport { makeSampleCareerGoalSlugArray } from '../career/SampleCareerGoals';\nimport { FavoriteInterests } from '../favorite/FavoriteInterestCollection';\nimport { FavoriteCareerGoals } from '../favorite/FavoriteCareerGoalCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('MentorProfileCollection', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function tearDown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) { // Test the define and removeIt methods\n      this.timeout(25000);\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(1), fc.lorem(1), fc.lorem(1), fc.lorem(1), fc.lorem(3), fc.lorem(2), fc.lorem(2), fc.lorem(1), fc.lorem(10),\n          (username, firstName, lastName, picture, website, company, career, location, linkedin, motivation) => {\n            const interests = makeSampleInterestArray();\n            const careerGoals = makeSampleCareerGoalSlugArray();\n            const docID = MentorProfiles.define({\n              username, firstName, lastName, picture, website, interests,\n              careerGoals, company, career, location, linkedin, motivation,\n            });\n            expect(MentorProfiles.isDefined(docID)).to.be.true;\n            expect(FavoriteInterests.count()).to.equal(interests.length);\n            expect(FavoriteCareerGoals.count()).to.equal(careerGoals.length);\n            MentorProfiles.removeIt(docID);\n            expect(MentorProfiles.isDefined(docID)).to.be.false;\n            expect(FavoriteInterests.count()).to.equal(0);\n            expect(FavoriteCareerGoals.count()).to.equal(0);\n          }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicates', function test2() { // Test if duplicate documents can be defined\n      const username = faker.internet.userName();\n      const firstName = faker.name.firstName();\n      const lastName = faker.name.lastName();\n      const picture = faker.image.imageUrl();\n      const website = faker.internet.url();\n      const interests = makeSampleInterestSlugArray();\n      const careerGoals = makeSampleCareerGoalSlugArray();\n      const company = faker.company.companyName();\n      const location = `${faker.address.county()}, ${faker.address.state()}`;\n      const career = faker.name.jobTitle();\n      const linkedin = faker.internet.userName();\n      const motivation = faker.lorem.paragraph();\n      const docID = MentorProfiles.define({\n        username, firstName, lastName, picture, website, interests,\n        careerGoals, company, career, location, linkedin, motivation,\n      });\n      expect(MentorProfiles.isDefined(docID)).to.be.true;\n      expect(() => MentorProfiles.define({\n        username, firstName, lastName, picture, website, interests,\n        careerGoals, company, career, location, linkedin, motivation,\n      })).to.throw(Error);\n    });\n\n    it('Can update', function test3(done) { // Test updating documents\n      this.timeout(25000);\n      let doc = MentorProfiles.findOne({});\n      const docID = doc._id;\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(1), fc.lorem(1), fc.boolean(), (firstName, lastName, picture, retired) => {\n          const website = faker.internet.url();\n          const interests = makeSampleInterestArray(3);\n          const careerGoals = makeSampleCareerGoalSlugArray(4);\n          const company = faker.company.companyName();\n          const location = `${faker.address.county()}, ${faker.address.state()}`;\n          const career = faker.name.jobTitle();\n          const linkedin = faker.internet.userName();\n          const motivation = faker.lorem.paragraph();\n          MentorProfiles.update(docID, {\n            firstName,\n            lastName,\n            picture,\n            website,\n            interests,\n            careerGoals,\n            retired,\n            company,\n            location,\n            career,\n            linkedin,\n            motivation,\n          });\n          doc = MentorProfiles.findDoc(docID);\n          expect(doc.firstName).to.equal(firstName);\n          expect(doc.lastName).to.equal(lastName);\n          expect(doc.picture).to.equal(picture);\n          expect(doc.website).to.equal(website);\n          expect(FavoriteInterests.count()).to.equal(interests.length);\n          expect(FavoriteCareerGoals.count()).to.equal(careerGoals.length);\n          expect(doc.retired).to.equal(retired);\n          expect(doc.company).to.equal(company);\n          expect(doc.location).to.equal(location);\n          expect(doc.career).to.equal(career);\n          expect(doc.linkedin).to.equal(linkedin);\n          expect(doc.motivation).to.equal(motivation);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() { // Tests dumpOne and restoreOne\n      const origDoc = MentorProfiles.findOne({});\n      let docID = origDoc._id;\n      const dumpObject = MentorProfiles.dumpOne(docID);\n      MentorProfiles.removeIt(docID);\n      expect(MentorProfiles.isDefined(docID)).to.be.false;\n      docID = MentorProfiles.restoreOne(dumpObject);\n      expect(MentorProfiles.isDefined(docID)).to.be.true;\n      const doc = MentorProfiles.findDoc(docID);\n      expect(doc.firstName).to.equal(origDoc.firstName);\n      expect(doc.lastName).to.equal(origDoc.lastName);\n      expect(doc.picture).to.equal(origDoc.picture);\n      expect(doc.website).to.equal(origDoc.website);\n      expect(doc.interestIDs).to.deep.equal(origDoc.interestIDs);\n      expect(doc.careerGoalIDs).to.deep.equal(origDoc.careerGoalIDs);\n      expect(doc.retired).to.equal(origDoc.retired);\n      expect(doc.company).to.equal(origDoc.company);\n      expect(doc.location).to.equal(origDoc.location);\n      expect(doc.career).to.equal(origDoc.career);\n      expect(doc.linkedin).to.equal(origDoc.linkedin);\n      expect(doc.motivation).to.equal(origDoc.motivation);\n    });\n\n    it('Can checkIntegrity no errors', function test5() { // Tests checkIntegrity\n      const problems = MentorProfiles.checkIntegrity();\n      expect(problems).to.have.lengthOf(0);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/MentorProfileCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1093,
    "kind": "file",
    "name": "api/user/MentorProfileCollection.ts",
    "content": "import _ from 'lodash';\nimport { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport BaseProfileCollection, { defaultProfilePicture } from './BaseProfileCollection';\nimport { Users } from './UserCollection';\nimport { Interests } from '../interest/InterestCollection';\nimport { CareerGoals } from '../career/CareerGoalCollection';\nimport { Slugs } from '../slug/SlugCollection';\nimport { ROLE } from '../role/Role';\nimport { IMentorProfileDefine, IMentorProfileUpdate } from '../../typings/radgrad';\nimport { FavoriteInterests } from '../favorite/FavoriteInterestCollection';\nimport { FavoriteCareerGoals } from '../favorite/FavoriteCareerGoalCollection';\n\n/**\n * Represents a Mentor Profile.\n * @extends api/user.BaseProfileCollection\n * @memberOf api/user\n */\nclass MentorProfileCollection extends BaseProfileCollection {\n  constructor() {\n    super('MentorProfile', new SimpleSchema({\n      company: String,\n      career: String,\n      location: String,\n      linkedin: { type: String, optional: true },\n      motivation: String,\n    }));\n  }\n\n  /**\n   * Defines the profile associated with a Mentor.\n   * The username does not need to be defined in Meteor Accounts yet, but it must be a unique Slug.\n   * @param username The username string associated with this profile, which should be an email.\n   * @param firstName The first name.\n   * @param lastName The last name.\n   * @param picture The URL to their picture. (optional, defaults to a default picture.)\n   * @param website The URL to their personal website (optional).\n   * @param interests An array of interests. (optional)\n   * @param careerGoals An array of career goals. (optional)\n   * @param company The company the mentor works for.\n   * @param career The mentor's career (or title).\n   * @param location The mentor's location.\n   * @param linkedin The mentor's LinkedIn user ID. (optional)\n   * @param motivation The reason why the user mentors.\n   * @param retired Is this mentor retired? (optional)\n   * @throws { Meteor.Error } If username has been previously defined, or if any interests or careerGoals are invalid.\n   * @return { String } The docID of the MentorProfile.\n   */\n  public define({ username, firstName, lastName, picture = defaultProfilePicture, website, interests,\n           careerGoals, company, career, location, linkedin, motivation, retired = false }: IMentorProfileDefine) {\n    if (Meteor.isServer) {\n      const role = ROLE.MENTOR;\n      Slugs.define({ name: username, entityName: this.getType() });\n      const profileID = this.collection.insert({\n        username, firstName, lastName, role, picture, website, company, career, location, linkedin,\n        motivation, userID: this.getFakeUserId(), retired });\n      const userID = Users.define({ username, role });\n      this.collection.update(profileID, { $set: { userID } });\n      if (interests) {\n        interests.forEach((interest) => FavoriteInterests.define({ interest, username }));\n      }\n      if (careerGoals) {\n        careerGoals.forEach((careerGoal) => FavoriteCareerGoals.define({ careerGoal, username }));\n      }\n      return profileID;\n    }\n    return undefined;\n  }\n\n  /**\n   * Updates the MentorProfile.\n   * You cannot change the username or role once defined.\n   * @param docID the id of the MentorProfile.\n   * @param {string} firstName\n   * @param {string} lastName\n   * @param {string} picture\n   * @param {string} website\n   * @param {string[]} interests\n   * @param {string[]} careerGoals\n   * @param company the company (optional).\n   * @param career the career (optional).\n   * @param location the location (optional).\n   * @param linkedin LinkedIn user ID (optional).\n   * @param motivation the motivation (optional).\n   */\n  public update(docID: string, { firstName, lastName, picture, website, interests, careerGoals, retired, company, career, location, linkedin,\n    motivation, courseExplorerFilter, opportunityExplorerSortOrder }: IMentorProfileUpdate) {\n    this.assertDefined(docID);\n    const updateData: IMentorProfileUpdate = {};\n    this.updateCommonFields(updateData, { firstName, lastName, picture, website, retired, courseExplorerFilter, opportunityExplorerSortOrder });\n    if (_.isString(company)) {\n      updateData.company = company;\n    }\n    if (_.isString(career)) {\n      updateData.career = career;\n    }\n    if (_.isString(location)) {\n      updateData.location = location;\n    }\n    if (_.isString(linkedin)) {\n      updateData.linkedin = linkedin;\n    }\n    if (_.isString(motivation)) {\n      updateData.motivation = motivation;\n    }\n    this.collection.update(docID, { $set: updateData });\n    const profile = this.findDoc(docID);\n    const username = profile.username;\n    if (interests) {\n      FavoriteInterests.removeUser(username);\n      interests.forEach((interest) => FavoriteInterests.define({ interest, username }));\n    }\n    if (careerGoals) {\n      FavoriteCareerGoals.removeUser(username);\n      careerGoals.forEach((careerGoal) => FavoriteCareerGoals.define({ careerGoal, username }));\n    }\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\n   * Mentor.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.MENTOR]);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks the profile common fields and the role..\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    let problems = [];\n    this.find().forEach((doc) => {\n      problems = problems.concat(this.checkIntegrityCommonFields(doc));\n      if (doc.role !== ROLE.MENTOR) {\n        problems.push(`MentorProfile instance does not have ROLE.MENTOR: ${doc}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the MentorProfile docID in a format acceptable to define().\n   * @param docID The docID of a MentorProfile\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IMentorProfileDefine {\n    const doc = this.findDoc(docID);\n    const username = doc.username;\n    const firstName = doc.firstName;\n    const lastName = doc.lastName;\n    const picture = doc.picture;\n    const website = doc.website;\n    const userID = Users.getID(username);\n    const favInterests = FavoriteInterests.findNonRetired({ userID });\n    const interests = _.map(favInterests, (fav) => Interests.findSlugByID(fav.interestID));\n    const favCareerGoals = FavoriteCareerGoals.findNonRetired({ userID });\n    const careerGoals = _.map(favCareerGoals, (fav) => CareerGoals.findSlugByID(fav.careerGoalID));\n    const company = doc.company;\n    const career = doc.career;\n    const location = doc.location;\n    const linkedin = doc.linkedin;\n    const motivation = doc.motivation;\n    const retired = doc.retired;\n    return { username, firstName, lastName, picture, website, interests, careerGoals, company, career, location,\n      linkedin, motivation, retired };\n  }\n}\n\n/**\n * Provides the singleton instance.\n * @type {api/user.MentorProfileCollection}\n * @memberOf api/user\n */\nexport const MentorProfiles = new MentorProfileCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/MentorProfileCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1094,
    "kind": "variable",
    "name": "MentorProfiles",
    "memberof": "api/user/MentorProfileCollection.ts",
    "static": true,
    "longname": "api/user/MentorProfileCollection.ts~MentorProfiles",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/MentorProfileCollection.ts",
    "importStyle": "{MentorProfiles}",
    "description": "Provides the singleton instance.",
    "lineNumber": 167,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/user"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/user.MentorProfileCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1095,
    "kind": "class",
    "name": "MentorProfileCollection",
    "memberof": "api/user/MentorProfileCollection.ts",
    "static": true,
    "longname": "api/user/MentorProfileCollection.ts~MentorProfileCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/MentorProfileCollection.ts",
    "importStyle": null,
    "description": "Represents a Mentor Profile.",
    "lineNumber": 19,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/user/BaseProfileCollection.js~BaseProfileCollection"
    ]
  },
  {
    "__docId__": 1096,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/user/MentorProfileCollection.ts~MentorProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/MentorProfileCollection.ts~MentorProfileCollection#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true
  },
  {
    "__docId__": 1097,
    "kind": "method",
    "name": "define",
    "memberof": "api/user/MentorProfileCollection.ts~MentorProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/MentorProfileCollection.ts~MentorProfileCollection#define",
    "access": "public",
    "description": "Defines the profile associated with a Mentor.\nThe username does not need to be defined in Meteor Accounts yet, but it must be a unique Slug.",
    "lineNumber": 49,
    "params": [
      {
        "nullable": null,
        "types": [
          "IMentorProfileDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1098,
    "kind": "method",
    "name": "update",
    "memberof": "api/user/MentorProfileCollection.ts~MentorProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/MentorProfileCollection.ts~MentorProfileCollection#update",
    "access": "public",
    "description": "Updates the MentorProfile.\nYou cannot change the username or role once defined.",
    "lineNumber": 86,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IMentorProfileUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1099,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/user/MentorProfileCollection.ts~MentorProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/MentorProfileCollection.ts~MentorProfileCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\nMentor.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 126,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1100,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/user/MentorProfileCollection.ts~MentorProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/MentorProfileCollection.ts~MentorProfileCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks the profile common fields and the role..",
    "lineNumber": 136,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1101,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/user/MentorProfileCollection.ts~MentorProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/MentorProfileCollection.ts~MentorProfileCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the MentorProfile docID in a format acceptable to define().",
    "lineNumber": 152,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IMentorProfileDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1102,
    "kind": "file",
    "name": "api/user/SampleUsers.ts",
    "content": "import faker from 'faker';\nimport { Meteor } from 'meteor/meteor';\nimport { StudentProfiles } from './StudentProfileCollection';\nimport { AdvisorProfiles } from './AdvisorProfileCollection';\nimport { MentorProfiles } from './MentorProfileCollection';\nimport { FacultyProfiles } from './FacultyProfileCollection';\nimport { ROLE } from '../role/Role';\nimport { Users } from './UserCollection';\n\nfunction makeSampleStudent() {\n  const username = `student.${faker.internet.email()}`;\n  const firstName = faker.name.firstName();\n  const lastName = faker.name.lastName();\n  const picture = faker.image.avatar();\n  const website = faker.internet.url();\n  const interests = [];\n  const careerGoals = [];\n  const level = 6;\n  const declaredAcademicTerm = 'Spring-2017';\n  const profileID = StudentProfiles.define({\n    username, firstName, lastName, picture, website, interests,\n    careerGoals, level, declaredAcademicTerm,\n  });\n  return StudentProfiles.getUserID(profileID);\n}\n\nfunction makeSampleMentor() {\n  const username = `mentor.${faker.internet.email()}`;\n  const firstName = faker.name.firstName();\n  const lastName = faker.name.lastName();\n  const picture = faker.image.avatar();\n  const website = faker.internet.url();\n  const interests = [];\n  const careerGoals = [];\n  const company = faker.company.companyName();\n  const career = faker.name.title();\n  const location = faker.address.city();\n  const linkedin = faker.lorem.word();\n  const motivation = faker.company.bs();\n  const profileID = MentorProfiles.define({\n    username, firstName, lastName, picture, website, interests,\n    careerGoals, company, career, location, linkedin, motivation,\n  });\n  return MentorProfiles.getUserID(profileID);\n}\n\nfunction makeSampleAdvisor() {\n  const username = `advisor.${faker.internet.email()}`;\n  const firstName = faker.name.firstName();\n  const lastName = faker.name.lastName();\n  const picture = faker.image.avatar();\n  const website = faker.internet.url();\n  const interests = [];\n  const careerGoals = [];\n  const profileID = AdvisorProfiles.define({ username, firstName, lastName, picture, website, interests, careerGoals });\n  return AdvisorProfiles.getUserID(profileID);\n}\n\nfunction makeSampleFaculty() {\n  const username = `faculty.${faker.internet.email()}`;\n  const firstName = faker.name.firstName();\n  const lastName = faker.name.lastName();\n  const picture = faker.image.avatar();\n  const website = faker.internet.url();\n  const interests = [];\n  const careerGoals = [];\n  const profileID = FacultyProfiles.define({ username, firstName, lastName, picture, website, interests, careerGoals });\n  return FacultyProfiles.getUserID(profileID);\n}\n\n/**\n * Creates a User based upon the specified role.\n * If role is not supplied, it defaults to ROLE.STUDENT.\n * @returns { String } The docID of the newly generated User.\n * @memberOf api/user\n */\nexport function makeSampleUser(role: string = ROLE.STUDENT) {\n  if (role === ROLE.STUDENT) {\n    return makeSampleStudent();\n  }\n  if (role === ROLE.FACULTY) {\n    return makeSampleFaculty();\n  }\n  if (role === ROLE.ADVISOR) {\n    return makeSampleAdvisor();\n  }\n  if (role === ROLE.MENTOR) {\n    return makeSampleMentor();\n  }\n  throw new Meteor.Error(`Unexpected role: ${role}`);\n}\n\n/**\n * Returns an array of defined usernames.\n * @param num the number of user to define. Defaults to 1.\n * @param role the Role of the users. Defaults to STUDENT.\n * @return an array of defined usernames.\n */\nexport function makeSampleUserArray(num = 1, role: string = ROLE.STUDENT) {\n  const retVal = [];\n  for (let i = 0; i < num; i++) {\n    retVal.push(Users.getProfile(makeSampleUser(role)).username);\n  }\n  return retVal;\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/SampleUsers.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1103,
    "kind": "function",
    "name": "makeSampleStudent",
    "memberof": "api/user/SampleUsers.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/user/SampleUsers.ts~makeSampleStudent",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/user/SampleUsers.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 10,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1104,
    "kind": "function",
    "name": "makeSampleMentor",
    "memberof": "api/user/SampleUsers.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/user/SampleUsers.ts~makeSampleMentor",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/user/SampleUsers.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 27,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1105,
    "kind": "function",
    "name": "makeSampleAdvisor",
    "memberof": "api/user/SampleUsers.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/user/SampleUsers.ts~makeSampleAdvisor",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/user/SampleUsers.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 47,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1106,
    "kind": "function",
    "name": "makeSampleFaculty",
    "memberof": "api/user/SampleUsers.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/user/SampleUsers.ts~makeSampleFaculty",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/user/SampleUsers.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 59,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1107,
    "kind": "function",
    "name": "makeSampleUser",
    "memberof": "api/user/SampleUsers.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/user/SampleUsers.ts~makeSampleUser",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/SampleUsers.ts",
    "importStyle": "{makeSampleUser}",
    "description": "Creates a User based upon the specified role.\nIf role is not supplied, it defaults to ROLE.STUDENT.",
    "lineNumber": 77,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "role",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1108,
    "kind": "function",
    "name": "makeSampleUserArray",
    "memberof": "api/user/SampleUsers.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/user/SampleUsers.ts~makeSampleUserArray",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/SampleUsers.ts",
    "importStyle": "{makeSampleUserArray}",
    "description": "Returns an array of defined usernames.",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "num",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "role",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1109,
    "kind": "file",
    "name": "api/user/StudentProfileCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport { defineMethod, removeItMethod, updateMethod } from '../base/BaseCollection.methods';\nimport { StudentProfiles } from './StudentProfileCollection';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nfunction sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nconst delay = 500;\n\nif (Meteor.isClient) {\n  describe('StudentProfileCollection Meteor Methods ', function test() {\n    this.timeout(5000);\n    const collectionName = StudentProfiles.getCollectionName();\n    const username = 'amytaka';\n    const firstName = 'Amy';\n    const lastName = 'Takayesu';\n    const picture = 'amytaka.jpg';\n    const website = 'http://amytaka.github.io';\n    const interests = [];\n    const careerGoals = [];\n    const level = 6;\n\n    before(function (done) {\n      defineTestFixturesMethod.call(['minimal'], done);\n    });\n\n    it('Define Method', async function () {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      const definitionData = { username, firstName, lastName, picture, website, interests, careerGoals, level };\n      const profileID = await defineMethod.callPromise({ collectionName, definitionData });\n      await sleep(delay); // give the system time to propagate the changes\n      const profile = StudentProfiles.findDoc({ _id: profileID });\n      // console.log(profileID, profile);\n      expect(profile.username).to.equal(username);\n      expect(profile.level).to.equal(level);\n      expect(profile.userID).to.not.equal(StudentProfiles.getFakeUserId());\n    });\n\n    it('Update Method', async function () {\n      const id = StudentProfiles.getID(username);\n      await updateMethod.callPromise({ collectionName, updateData: { id, level: 4 } });\n      await sleep(delay); // give the system time to propagate the changes\n      const profile = StudentProfiles.findDoc({ _id: id });\n      expect(profile.level).to.equal(4);\n    });\n\n    it('Remove Method', async function () {\n      const instance = StudentProfiles.getID(username);\n      // const profile = StudentProfiles.findDoc({ username });\n      // console.log(instance, profile);\n      await removeItMethod.callPromise({ collectionName, instance });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/StudentProfileCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1110,
    "kind": "function",
    "name": "sleep",
    "memberof": "api/user/StudentProfileCollection.methods.app-test.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/user/StudentProfileCollection.methods.app-test.ts~sleep",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/user/StudentProfileCollection.methods.app-test.ts",
    "importStyle": null,
    "description": "",
    "lineNumber": 10,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "ms",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1111,
    "kind": "variable",
    "name": "delay",
    "memberof": "api/user/StudentProfileCollection.methods.app-test.ts",
    "static": true,
    "longname": "api/user/StudentProfileCollection.methods.app-test.ts~delay",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/user/StudentProfileCollection.methods.app-test.ts",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1112,
    "kind": "file",
    "name": "api/user/StudentProfileCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport moment from 'moment';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { StudentProfiles } from './StudentProfileCollection';\nimport { makeSampleInterestArray, makeSampleInterestSlugArray } from '../interest/SampleInterests';\nimport { makeSampleCareerGoalSlugArray } from '../career/SampleCareerGoals';\nimport { FavoriteInterests } from '../favorite/FavoriteInterestCollection';\nimport { FavoriteCareerGoals } from '../favorite/FavoriteCareerGoalCollection';\nimport { makeSampleAcademicPlan } from '../degree-plan/SampleAcademicPlans';\nimport { makeSampleAcademicTermSlug } from '../academic-term/SampleAcademicTerms';\nimport { makeSampleCourseSlugArray } from '../course/SampleCourses';\nimport { makeSampleOpportunitySlugArray } from '../opportunity/SampleOpportunities';\nimport { makeSampleUser } from './SampleUsers';\nimport { ROLE } from '../role/Role';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('StudentProfileCollection', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function tearDown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) { // Test the define and removeIt methods\n      this.timeout(150000);\n      const sponsor = makeSampleUser(ROLE.FACULTY);\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(1), fc.lorem(1), fc.lorem(1), fc.boolean(),\n          (firstName, lastName, picture, website, retired) => {\n          const username = `${faker.internet.userName()}${moment().format('YYYY-MM-DD-HH-mm-ss-SSSSS')}`;\n            const interests = makeSampleInterestArray();\n            const careerGoals = makeSampleCareerGoalSlugArray();\n            const level = faker.random.number({ min: 1, max: 6 });\n            const favoriteAcademicPlans = [makeSampleAcademicPlan()];\n            const declaredAcademicTerm = makeSampleAcademicTermSlug();\n            const favoriteCourses = makeSampleCourseSlugArray(2);\n            const favoriteOpportunities = makeSampleOpportunitySlugArray(sponsor, 2);\n            const docID = StudentProfiles.define({\n              username, firstName, lastName, picture, website, interests,\n              careerGoals, level, favoriteAcademicPlans, declaredAcademicTerm,\n              favoriteCourses, favoriteOpportunities, retired,\n            });\n            expect(StudentProfiles.isDefined(docID)).to.be.true;\n            expect(FavoriteInterests.count()).to.equal(interests.length);\n            expect(FavoriteCareerGoals.count()).to.equal(careerGoals.length);\n            const doc = StudentProfiles.findDoc(docID);\n            expect(doc.username).to.equal(username);\n            StudentProfiles.removeIt(docID);\n            expect(StudentProfiles.isDefined(docID)).to.be.false;\n            expect(FavoriteInterests.count()).to.equal(0);\n            expect(FavoriteCareerGoals.count()).to.equal(0);\n          }),\n      );\n      done();\n    });\n\n    it('Cannot define duplicates', function test2() { // Test if duplicate documents can be defined\n      const username = faker.internet.userName();\n      const firstName = faker.name.firstName();\n      const lastName = faker.name.lastName();\n      const picture = faker.image.imageUrl();\n      const website = faker.internet.url();\n      const interests = makeSampleInterestSlugArray();\n      const careerGoals = makeSampleCareerGoalSlugArray();\n      const level = faker.random.number({ min: 1, max: 6 });\n      const declaredAcademicTerm = makeSampleAcademicTermSlug();\n      const docID = StudentProfiles.define({\n        username, firstName, lastName, picture, website, interests,\n        careerGoals, level, declaredAcademicTerm,\n      });\n      expect(StudentProfiles.isDefined(docID)).to.be.true;\n      expect(() => StudentProfiles.define({\n        username, firstName, lastName, picture, website, interests,\n        careerGoals, level, declaredAcademicTerm,\n      })).to.throw(Error);\n    });\n\n    it('Can update', function test3(done) { // Test updating documents\n      this.timeout(25000);\n      let doc = StudentProfiles.findOne({});\n      const docID = doc._id;\n      fc.assert(\n        fc.property(fc.lorem(1), fc.lorem(1), fc.lorem(1), fc.boolean(),\n          fc.boolean(), fc.boolean(), fc.boolean(), fc.boolean(), fc.boolean(), fc.boolean(), fc.boolean(),\n          fc.boolean(), fc.boolean(), fc.boolean(),\n          (firstName, lastName, picture, isAlumni, retired, shareUsername, sharePicture, shareWebsite, shareInterests, shareCareerGoals, shareAcademicPlan, shareCourses, shareOpportunities, shareLevel) => {\n          const website = faker.internet.url();\n          const interests = makeSampleInterestArray(3);\n          const careerGoals = makeSampleCareerGoalSlugArray(4);\n          StudentProfiles.update(docID, {\n            firstName,\n            lastName,\n            picture,\n            website,\n            interests,\n            careerGoals,\n            isAlumni, retired, shareUsername,\n            sharePicture, shareWebsite, shareInterests, shareCareerGoals, shareAcademicPlan, shareCourses,\n            shareOpportunities, shareLevel,\n          });\n          doc = StudentProfiles.findDoc(docID);\n          expect(doc.firstName).to.equal(firstName);\n          expect(doc.lastName).to.equal(lastName);\n          expect(doc.picture).to.equal(picture);\n          expect(doc.website).to.equal(website);\n          // expect(FavoriteInterests.count()).to.equal(interests.length);\n          // expect(FavoriteCareerGoals.count()).to.equal(careerGoals.length);\n          expect(doc.retired).to.equal(retired);\n          expect(doc.isAlumni).to.equal(isAlumni);\n          expect(doc.shareUsername).to.equal(shareUsername);\n          expect(doc.sharePicture).to.equal(sharePicture);\n          expect(doc.shareWebsite).to.equal(shareWebsite);\n          expect(doc.shareInterests).to.equal(shareInterests);\n          expect(doc.shareCareerGoals).to.equal(shareCareerGoals);\n          expect(doc.shareAcademicPlan).to.equal(shareAcademicPlan);\n          expect(doc.shareCourses).to.equal(shareCourses);\n          expect(doc.shareOpportunities).to.equal(shareOpportunities);\n          expect(doc.shareLevel).to.equal(shareLevel);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() { // Tests dumpOne and restoreOne\n      const origDoc = StudentProfiles.findOne({});\n      let docID = origDoc._id;\n      const dumpObject = StudentProfiles.dumpOne(docID);\n      StudentProfiles.removeIt(docID);\n      expect(StudentProfiles.isDefined(docID)).to.be.false;\n      docID = StudentProfiles.restoreOne(dumpObject);\n      expect(StudentProfiles.isDefined(docID)).to.be.true;\n      const doc = StudentProfiles.findDoc(docID);\n      expect(doc.firstName).to.equal(origDoc.firstName);\n      expect(doc.lastName).to.equal(origDoc.lastName);\n      expect(doc.picture).to.equal(origDoc.picture);\n      expect(doc.website).to.equal(origDoc.website);\n      expect(doc.interestIDs).to.deep.equal(origDoc.interestIDs);\n      expect(doc.careerGoalIDs).to.deep.equal(origDoc.careerGoalIDs);\n      expect(doc.retired).to.equal(origDoc.retired);\n      expect(doc.isAlumni).to.equal(origDoc.isAlumni);\n      expect(doc.shareUsername).to.equal(origDoc.shareUsername);\n      expect(doc.sharePicture).to.equal(origDoc.sharePicture);\n      expect(doc.shareWebsite).to.equal(origDoc.shareWebsite);\n      expect(doc.shareInterests).to.equal(origDoc.shareInterests);\n      expect(doc.shareCareerGoals).to.equal(origDoc.shareCareerGoals);\n      expect(doc.shareAcademicPlan).to.equal(origDoc.shareAcademicPlan);\n      expect(doc.shareCourses).to.equal(origDoc.shareCourses);\n      expect(doc.shareOpportunities).to.equal(origDoc.shareOpportunities);\n      expect(doc.shareLevel).to.equal(origDoc.shareLevel);\n    });\n\n    it('Can checkIntegrity no errors', function test5() { // Tests checkIntegrity\n      const problems = StudentProfiles.checkIntegrity();\n      expect(problems).to.have.lengthOf(0);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/StudentProfileCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1113,
    "kind": "file",
    "name": "api/user/StudentProfileCollection.ts",
    "content": "import _ from 'lodash';\nimport { Meteor } from 'meteor/meteor';\nimport SimpleSchema from 'simpl-schema';\nimport { Roles } from 'meteor/alanning:roles';\nimport { ReactiveAggregate } from 'meteor/jcbernack:reactive-aggregate';\nimport BaseProfileCollection, { defaultProfilePicture } from './BaseProfileCollection';\nimport { AcademicPlans } from '../degree-plan/AcademicPlanCollection';\nimport { CareerGoals } from '../career/CareerGoalCollection';\nimport { Courses } from '../course/CourseCollection';\nimport { CourseInstances } from '../course/CourseInstanceCollection';\nimport { Interests } from '../interest/InterestCollection';\nimport { Opportunities } from '../opportunity/OpportunityCollection';\nimport { OpportunityInstances } from '../opportunity/OpportunityInstanceCollection';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { Users } from './UserCollection';\nimport { Slugs } from '../slug/SlugCollection';\nimport { ROLE } from '../role/Role';\nimport { getProjectedICE, getEarnedICE } from '../ice/IceProcessor';\nimport { IStudentProfileDefine, IStudentProfileUpdate, IStudentProfileUpdateData } from '../../typings/radgrad';\nimport { FavoriteInterests } from '../favorite/FavoriteInterestCollection';\nimport { FavoriteCareerGoals } from '../favorite/FavoriteCareerGoalCollection';\nimport { FavoriteAcademicPlans } from '../favorite/FavoriteAcademicPlanCollection';\nimport { FavoriteCourses } from '../favorite/FavoriteCourseCollection';\nimport { FavoriteOpportunities } from '../favorite/FavoriteOpportunityCollection';\n\n/**\n * Represents a Student Profile.\n * @extends api/user.BaseProfileCollection\n * @memberOf api/user\n */\nclass StudentProfileCollection extends BaseProfileCollection {\n  constructor() {\n    super('StudentProfile', new SimpleSchema({\n      level: { type: SimpleSchema.Integer, min: 1, max: 6 },\n      declaredAcademicTermID: { type: SimpleSchema.RegEx.Id, optional: true },\n      isAlumni: Boolean,\n      shareAcademicPlan: { type: Boolean, optional: true },\n      shareOpportunities: { type: Boolean, optional: true },\n      shareCourses: { type: Boolean, optional: true },\n      shareLevel: { type: Boolean, optional: true },\n    }));\n    this.defineSchema = new SimpleSchema({\n      username: String,\n      firstName: String,\n      lastName: String,\n      picture: { type: String, optional: true },\n      website: { type: String, optional: true },\n      interests: { type: Array, optional: true },\n      'interests.$': String,\n      careerGoals: { type: Array, optional: true },\n      'careerGoals.$': String,\n      retired: { type: Boolean, optional: true },\n      level: { type: SimpleSchema.Integer, min: 1, max: 6 },\n      favoriteAcademicPlans: { type: Array, optional: true },\n      'favoriteAcademicPlans.$': String,\n      declaredAcademicTerm: { type: String, optional: true },\n      isAlumni: { type: Boolean, optional: true },\n      favoriteCourses: { type: Array, optional: true },\n      'favoriteCourses.$': String,\n      favoriteOpportunities: { type: Array, optional: true },\n      'favoriteOpportunities.$': String,\n      shareUsername: { type: Boolean, optional: true },\n      sharePicture: { type: Boolean, optional: true },\n      shareWebsite: { type: Boolean, optional: true },\n      shareInterests: { type: Boolean, optional: true },\n      shareCareerGoals: { type: Boolean, optional: true },\n      shareAcademicPlan: { type: Boolean, optional: true },\n      shareOpportunities: { type: Boolean, optional: true },\n      shareCourses: { type: Boolean, optional: true },\n      shareLevel: { type: Boolean, optional: true },\n    });\n    this.updateSchema = new SimpleSchema({\n      firstName: { type: String, optional: true },\n      lastName: { type: String, optional: true },\n      picture: { type: String, optional: true },\n      website: { type: String, optional: true },\n      interests: { type: Array, optional: true },\n      'interests.$': String,\n      careerGoals: { type: Array, optional: true },\n      'careerGoals.$': String,\n      retired: { type: Boolean, optional: true },\n      level: { type: SimpleSchema.Integer, min: 1, max: 6 },\n      favoriteAcademicPlans: { type: Array, optional: true },\n      'favoriteAcademicPlans.$': String,\n      declaredAcademicTermID: { type: String, optional: true },\n      isAlumni: { type: Boolean, optional: true },\n      favoriteCourses: { type: Array, optional: true },\n      'favoriteCourses.$': String,\n      favoriteOpportunities: { type: Array, optional: true },\n      'favoriteOpportunities.$': String,\n      shareUsername: { type: Boolean, optional: true },\n      sharePicture: { type: Boolean, optional: true },\n      shareWebsite: { type: Boolean, optional: true },\n      shareInterests: { type: Boolean, optional: true },\n      shareCareerGoals: { type: Boolean, optional: true },\n      shareAcademicPlan: { type: Boolean, optional: true },\n      shareOpportunities: { type: Boolean, optional: true },\n      shareCourses: { type: Boolean, optional: true },\n      shareLevel: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines the profile associated with a Student.\n   * The username does not need to be defined in Meteor Accounts yet, but it must be a unique Slug.\n   * @param username The username string associated with this profile, which should be an email.\n   * @param firstName The first name.\n   * @param lastName The last name.\n   * @param picture The URL to their picture. (optional, defaults to a default picture.)\n   * @param website The URL to their personal website (optional).\n   * @param interests An array of interests. (optional)\n   * @param careerGoals An array of career goals. (optional)\n   * @param level An integer between 1 and 6 indicating the student's level.\n   * @param retired boolean. (optional defaults to false)\n   * @param academicPlan An optional slug indicating the academic plan.\n   * @param declaredAcademicTerm An optional string indicating the student's declared academic term.\n   * @param isAlumni An optional boolean indicating if this student has graduated. Defaults to false.\n   * @param shareUsername An optional boolean indicating if this student is sharing their username. Defaults to false.\n   * @param sharePicture An optional boolean indicating if this student is sharing their picture. Defaults to false.\n   * @param shareWebsite An optional boolean indicating if this student is sharing their website. Defaults to false.\n   * @param shareInterests An optional boolean indicating if this student is sharing their interests. Defaults to false.\n   * @param shareCareerGoals An optional boolean indicating if this student is sharing their career goals. Defaults to false.\n   * @param shareAcademicPlan An optional boolean indicating if this student is sharing their academic plans. Defaults to false.\n   * @param shareCourses An optional boolean indicating if this student is sharing their courses. Defaults to false.\n   * @param shareOpportunities An optional boolean indicating if this student is sharing their opportunities. Defaults to false.\n   * @param shareLevel An optional boolean indicating if this student is sharing their level. Defaults to false.\n   * @throws { Meteor.Error } If username has been previously defined, or if any interests, careerGoals, level,\n   * academicPlan, or declaredAcademicTerm are invalid.\n   * @return { String } The docID of the StudentProfile.\n   */\n\n  public define({\n                  username, firstName, lastName, picture = defaultProfilePicture, website, interests,\n                  careerGoals, level, favoriteAcademicPlans = [], declaredAcademicTerm, favoriteCourses = [], favoriteOpportunities = [],\n                  isAlumni = false, retired = false, shareUsername = false, sharePicture = false, shareWebsite = false,\n                  shareInterests = false, shareCareerGoals = false, shareAcademicPlan = false, shareCourses = false,\n                  shareOpportunities = false, shareLevel = false,\n                }: IStudentProfileDefine) {\n    if (Meteor.isServer) {\n      // Validate parameters.\n      const declaredAcademicTermID = (declaredAcademicTerm) ? AcademicTerms.getID(declaredAcademicTerm) : undefined;\n      this.assertValidLevel(level);\n      if (!_.isBoolean(isAlumni)) {\n        throw new Meteor.Error(`Invalid isAlumni: ${isAlumni}`);\n      }\n\n      // Create the slug, which ensures that username is unique.\n      Slugs.define({ name: username, entityName: this.getType() });\n      const role = (isAlumni) ? ROLE.ALUMNI : ROLE.STUDENT;\n      const profileID = this.collection.insert({\n        username,\n        firstName,\n        lastName,\n        role,\n        picture,\n        website,\n        level,\n        declaredAcademicTermID,\n        isAlumni,\n        userID: this.getFakeUserId(),\n        retired,\n        shareUsername,\n        sharePicture,\n        shareWebsite,\n        shareInterests,\n        shareCareerGoals,\n        shareAcademicPlan,\n        shareCourses,\n        shareOpportunities,\n        shareLevel,\n      });\n      const userID = Users.define({ username, role });\n      this.collection.update(profileID, { $set: { userID } });\n      if (interests) {\n        interests.forEach((interest) => FavoriteInterests.define({ interest, username }));\n      }\n      if (careerGoals) {\n        careerGoals.forEach((careerGoal) => FavoriteCareerGoals.define({ careerGoal, username }));\n      }\n      if (favoriteAcademicPlans) {\n        favoriteAcademicPlans.forEach((academicPlan) => FavoriteAcademicPlans.define({\n          academicPlan,\n          student: username,\n        }));\n      }\n      if (favoriteCourses) {\n        favoriteCourses.forEach((course) => FavoriteCourses.define({ course, student: username }));\n      }\n      if (favoriteOpportunities) {\n        favoriteOpportunities.forEach((opportunity) => FavoriteOpportunities.define({\n          opportunity,\n          student: username,\n        }));\n      }\n      return profileID;\n    }\n    return undefined;\n  }\n\n  /**\n   * Updates the StudentProfile.\n   * You cannot change the username or role once defined. (You can implicitly change the role by setting isAlumni).\n   * Users in ROLE.STUDENT cannot change their level or isAlumni setting.\n   * @param docID\n   * @param firstName\n   * @param lastName\n   * @param picture\n   * @param website\n   * @param interests\n   * @param careerGoals\n   * @param level\n   * @param academicPlan\n   * @param declaredAcademicTerm\n   * @param isAlumni\n   * @param retired\n   * @param shareUsername\n   * @param sharePicture\n   * @param shareWebsite\n   * @param shareInterests\n   * @param shareCareerGoals\n   * @param shareAcademicPlan\n   * @param shareCourses\n   * @param shareOpportunities\n   * @param shareLevel\n   */\n  public update(docID, {\n    firstName, lastName, picture, website, interests, careerGoals, level, favoriteAcademicPlans, favoriteCourses,\n    favoriteOpportunities, declaredAcademicTerm,\n    isAlumni, retired, courseExplorerFilter, opportunityExplorerSortOrder, shareUsername, sharePicture, shareWebsite, shareInterests,\n    shareCareerGoals, shareAcademicPlan, shareCourses, shareOpportunities, shareLevel,\n  }: IStudentProfileUpdate) {\n    this.assertDefined(docID);\n    const profile = this.findDoc(docID);\n    const updateData: IStudentProfileUpdateData = {};\n    this.updateCommonFields(updateData, { firstName, lastName, picture, website, retired, courseExplorerFilter, opportunityExplorerSortOrder });\n    if (declaredAcademicTerm) {\n      updateData.declaredAcademicTermID = AcademicTerms.getID(declaredAcademicTerm);\n    }\n    // Only Admins and Advisors can update the isAlumni and level fields.\n    // Or if no one is logged in when this is executed (i.e. for testing) then it's cool.\n    if (Meteor.isTest || !Meteor.userId() || this.hasRole(Meteor.userId(), [ROLE.ADMIN, ROLE.ADVISOR])) {\n      const userID = this.findDoc(docID).userID;\n      if (_.isBoolean(isAlumni)) {\n        updateData.isAlumni = isAlumni;\n        if (isAlumni) {\n          updateData.role = ROLE.ALUMNI;\n          Roles.createRole(ROLE.ALUMNI, { unlessExists: true });\n          Roles.addUsersToRoles(userID, [ROLE.ALUMNI]);\n          Roles.removeUsersFromRoles(userID, [ROLE.STUDENT]);\n        } else {\n          updateData.role = ROLE.STUDENT;\n          Roles.createRole(ROLE.STUDENT, { unlessExists: true });\n          Roles.addUsersToRoles(userID, [ROLE.STUDENT]);\n          Roles.removeUsersFromRoles(userID, [ROLE.ALUMNI]);\n        }\n      }\n      if (level) {\n        this.assertValidLevel(level);\n        updateData.level = level;\n      }\n      if (_.isBoolean(retired)) {\n        updateData.retired = retired;\n      }\n    }\n    if (_.isBoolean(shareUsername)) {\n      updateData.shareUsername = shareUsername;\n    }\n    if (_.isBoolean(sharePicture)) {\n      updateData.sharePicture = sharePicture;\n    }\n    if (_.isBoolean(shareWebsite)) {\n      updateData.shareWebsite = shareWebsite;\n    }\n    if (_.isBoolean(shareInterests)) {\n      updateData.shareInterests = shareInterests;\n    }\n    if (_.isBoolean(shareCareerGoals)) {\n      updateData.shareCareerGoals = shareCareerGoals;\n    }\n    if (_.isBoolean(shareAcademicPlan)) {\n      updateData.shareAcademicPlan = shareAcademicPlan;\n    }\n    if (_.isBoolean(shareCourses)) {\n      updateData.shareCourses = shareCourses;\n    }\n    if (_.isBoolean(shareOpportunities)) {\n      updateData.shareOpportunities = shareOpportunities;\n    }\n    if (_.isBoolean(shareLevel)) {\n      updateData.shareLevel = shareLevel;\n    }\n    // console.log('StudentProfile.update %o', updateData);\n    this.collection.update(docID, { $set: updateData });\n    const username = profile.username;\n    if (interests) {\n      FavoriteInterests.removeUser(username);\n      interests.forEach((interest) => FavoriteInterests.define({ interest, username }));\n    }\n    if (careerGoals) {\n      FavoriteCareerGoals.removeUser(username);\n      careerGoals.forEach((careerGoal) => FavoriteCareerGoals.define({ careerGoal, username }));\n    }\n    if (favoriteAcademicPlans) {\n      FavoriteAcademicPlans.removeUser(username);\n      favoriteAcademicPlans.forEach((academicPlan) => FavoriteAcademicPlans.define({\n        academicPlan,\n        student: username,\n      }));\n    }\n    if (favoriteCourses) {\n      FavoriteCourses.removeUser(username);\n      favoriteCourses.forEach((course) => FavoriteCourses.define({ course, student: username }));\n    }\n    if (favoriteOpportunities) {\n      FavoriteOpportunities.removeUser(username);\n      favoriteOpportunities.forEach((opportunity) => FavoriteOpportunities.define({ opportunity, student: username }));\n    }\n  }\n\n  /**\n   * Removes this profile, given its profile ID.\n   * Also removes this user from Meteor Accounts.\n   * @param profileID The ID for this profile object.\n   */\n  public removeIt(profileID) {\n    if (this.isDefined(profileID)) {\n      return super.removeIt(profileID);\n    }\n    return null;\n  }\n\n  /**\n   * Asserts that level is an integer between 1 and 6.\n   * @param level The level.\n   */\n  public assertValidLevel(level: number) {\n    if (!_.isInteger(level) && !_.inRange(level, 1, 7)) {\n      throw new Meteor.Error(`Level ${level} is not between 1 and 6.`);\n    }\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\n   * Student.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.STUDENT]);\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks the profile common fields and the role..\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    let problems = [];\n    this.find().forEach((doc) => {\n      problems = problems.concat(this.checkIntegrityCommonFields(doc));\n      if ((doc.role !== ROLE.STUDENT) && (doc.role !== ROLE.ALUMNI)) {\n        problems.push(`StudentProfile instance does not have ROLE.STUDENT or ROLE.ALUMNI: ${doc.username}`);\n      }\n      if (!_.isInteger(doc.level) && !_.inRange(doc.level, 1, 7)) {\n        problems.push(`Level ${doc.level} is not an integer between 1 and 6 in ${doc.username}`);\n      }\n      if (!_.isBoolean(doc.isAlumni)) {\n        problems.push(`Invalid isAlumni: ${doc.isAlumni} in ${doc.username}`);\n      }\n      if (doc.academicPlanID && !AcademicPlans.isDefined(doc.academicPlanID)) {\n        problems.push(`Bad academicPlanID: ${doc.academicPlanID} in ${doc.username}`);\n      }\n      if (doc.declaredAcademicTermID && !AcademicTerms.isDefined(doc.declaredAcademicTermID)) {\n        problems.push(`Bad termID: ${doc.declaredAcademicTermID} in ${doc.username}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an ICE object with the total earned course and opportunity ICE values.\n   * @param user The student (username or userID).\n   * @throws {Meteor.Error} If userID is not defined.\n   */\n  public getEarnedICE(user: string) {\n    const studentID = Users.getID(user);\n    const courseDocs = CourseInstances.findNonRetired({ studentID });\n    const oppDocs = OpportunityInstances.findNonRetired({ studentID });\n    return getEarnedICE(courseDocs.concat(oppDocs));\n  }\n\n  /**\n   * Returns an ICE object with the total projected course and opportunity ICE values.\n   * @param user The student (username or userID).\n   * @throws {Meteor.Error} If user is not defined.\n   */\n  public getProjectedICE(user: string) {\n    const studentID = Users.getID(user);\n    const courseDocs = CourseInstances.findNonRetired({ studentID });\n    const oppDocs = OpportunityInstances.findNonRetired({ studentID });\n    return getProjectedICE(courseDocs.concat(oppDocs));\n  }\n\n  /**\n   * Returns an array of courseIDs that this user has taken (or plans to take) based on their courseInstances.\n   * @param studentID The studentID.\n   */\n  public getCourseIDs(user: string) {\n    const studentID = Users.getID(user);\n    const courseInstanceDocs = CourseInstances.findNonRetired({ studentID });\n    const courseIDs = courseInstanceDocs.map((doc) => doc.courseID);\n    return courseIDs; // allow for multiple 491 or 499 classes.\n    // return _.uniq(courseIDs);\n  }\n\n  /**\n   * Returns the user's interests as IDs. It is a union of interestIDs and careerGoal interestIDs.\n   * @param userID\n   * @returns {Array}\n   */\n  public getInterestIDs(userID: string) {\n    let interestIDs = [];\n    const favoriteInterests = FavoriteInterests.findNonRetired({ userID });\n    _.forEach(favoriteInterests, (fav) => {\n      interestIDs.push(fav.interestID);\n    });\n    const favoriteCareerGoals = FavoriteCareerGoals.findNonRetired({ userID });\n    _.forEach(favoriteCareerGoals, (fav) => {\n      const goal = CareerGoals.findDoc(fav.careerGoalID);\n      interestIDs = _.union(interestIDs, goal.interestIDs);\n    });\n    return interestIDs;\n  }\n\n  /**\n   * Returns the user's interest IDs in an Array with two sub-arrays. The first sub-array is the interest IDs that the\n   * User selected. The second sub-array is the interestIDs from the user's career goals.\n   * @param userID The user's ID.\n   */\n  public getInterestIDsByType(userID: string) {\n    const interestIDs = [];\n    const userInterests = [];\n    const favoriteInterests = FavoriteInterests.findNonRetired({ userID });\n    _.forEach(favoriteInterests, (fav) => {\n      userInterests.push(fav.interestID);\n    });\n    interestIDs.push(userInterests);\n    let careerInterestIDs = [];\n    const favoriteCareerGoals = FavoriteCareerGoals.findNonRetired({ userID });\n    _.forEach(favoriteCareerGoals, (fav) => {\n      const goal = CareerGoals.findDoc(fav.careerGoalID);\n      careerInterestIDs = _.union(careerInterestIDs, goal.interestIDs);\n    });\n    careerInterestIDs = _.difference(careerInterestIDs, userInterests);\n    interestIDs.push(careerInterestIDs);\n    return interestIDs;\n  }\n\n  /**\n   * Updates user's level.\n   * @param user The user (username or userID).\n   * @param level The new level.\n   */\n  public setLevel(user: string, level: number) {\n    const id = this.getID(user);\n    this.collection.update({ _id: id }, { $set: { level } });\n  }\n\n  public publish() {\n    if (Meteor.isServer) {\n      // console.log('StudentProfileCollection.publish');\n      const inst = this;\n      Meteor.publish(this.collectionName, function () {\n        const userID = Meteor.userId();\n        ReactiveAggregate(this, inst.collection, [{\n          $project: {\n            username: {\n              $cond: [{\n                $or: [\n                  { $ifNull: ['$shareUsername', false] },\n                  { $eq: [userID, '$userID'] },\n                  { $eq: [Roles.userIsInRole(userID, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.FACULTY]), true] },\n                ],\n              }, '$username', ''],\n            },\n            firstName: 1,\n            lastName: 1,\n            role: 1,\n            picture: {\n              $cond: [{\n                $or: [\n                  { $ifNull: ['$sharePicture', false] },\n                  { $eq: [userID, '$userID'] },\n                  { $eq: [Roles.userIsInRole(userID, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.FACULTY]), true] },\n                ],\n              }, '$picture', '/images/default-profile-picture.png'],\n            },\n            website: {\n              $cond: [{\n                $or: [\n                  { $ifNull: ['$shareWebsite', false] },\n                  { $eq: [userID, '$userID'] },\n                  { $eq: [Roles.userIsInRole(userID, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.FACULTY]), true] },\n                ],\n              }, '$website', ''],\n            },\n            interestIDs: {\n              $cond: [{\n                $or: [\n                  { $ifNull: ['$shareInterests', false] },\n                  { $eq: [userID, '$userID'] },\n                  { $eq: [Roles.userIsInRole(userID, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.FACULTY]), true] },\n                ],\n              }, '$interestIDs', []],\n            },\n            careerGoalIDs: {\n              $cond: [{\n                $or: [\n                  { $ifNull: ['$shareCareerGoals', false] },\n                  { $eq: [userID, '$userID'] },\n                  { $eq: [Roles.userIsInRole(userID, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.FACULTY]), true] },\n                ],\n              }, '$careerGoalIDs', []],\n            },\n            userID: 1,\n            retired: 1,\n            level: {\n              $cond: [{\n                $or: [\n                  { $ifNull: ['$shareLevel', false] },\n                  { $eq: [userID, '$userID'] },\n                  { $eq: [Roles.userIsInRole(userID, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.FACULTY]), true] },\n                ],\n              }, '$level', 0],\n            },\n            academicPlanID: {\n              $cond: [{\n                $or: [\n                  { $ifNull: ['$shareAcademicPlan', false] },\n                  { $eq: [userID, '$userID'] },\n                  { $eq: [Roles.userIsInRole(userID, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.FACULTY]), true] },\n                ],\n              }, '$academicPlanID', ''],\n            },\n            declaredAcademicTermID: 1,\n            isAlumni: 1,\n            shareUsername: 1,\n            sharePicture: 1,\n            shareWebsite: 1,\n            shareInterests: 1,\n            shareCareerGoals: 1,\n            shareAcademicPlan: 1,\n            shareOpportunities: 1,\n            shareCourses: 1,\n            shareLevel: 1,\n            optedIn: {\n              $cond: [{\n                $or: [\n                  '$shareUsername',\n                  '$sharePicture',\n                  '$shareWebsite',\n                  '$shareInterests',\n                  '$shareCareerGoals',\n                  '$shareAcademicPlan',\n                  '$shareOpportunities',\n                  '$shareCourses',\n                  '$shareLevel',\n                ],\n              }, true, false],\n            },\n          },\n        }]);\n      });\n    }\n  }\n\n  /**\n   * Returns an object representing the StudentProfile docID in a format acceptable to define().\n   * @param docID The docID of a StudentProfile\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IStudentProfileDefine {\n    const doc = this.findDoc(docID);\n    const username = doc.username;\n    const firstName = doc.firstName;\n    const lastName = doc.lastName;\n    const picture = doc.picture;\n    const website = doc.website;\n    const userID = Users.getID(username);\n    const favInterests = FavoriteInterests.findNonRetired({ userID });\n    const interests = _.map(favInterests, (fav) => Interests.findSlugByID(fav.interestID));\n    const favCareerGoals = FavoriteCareerGoals.findNonRetired({ userID });\n    const careerGoals = _.map(favCareerGoals, (fav) => CareerGoals.findSlugByID(fav.careerGoalID));\n    const level = doc.level;\n    const favAcademicPlans = FavoriteAcademicPlans.findNonRetired({ studentID: userID });\n    const favoriteAcademicPlans = _.map(favAcademicPlans, (fav) => AcademicPlans.findSlugByID(fav.academicPlanID));\n    const favCourses = FavoriteCourses.findNonRetired({ studentID: userID });\n    const favoriteCourses = _.map(favCourses, (fav) => Courses.findSlugByID(fav.courseID));\n    const favOpps = FavoriteOpportunities.findNonRetired({ studentID: userID });\n    const favoriteOpportunities = _.map(favOpps, (fav) => Opportunities.findSlugByID(fav.opportunityID));\n    const declaredAcademicTerm = doc.declaredAcademicTermID && AcademicTerms.findSlugByID(doc.declaredAcademicTermID);\n    const isAlumni = doc.isAlumni;\n    const retired = doc.retired;\n    const shareUsername = doc.shareUsername;\n    const sharePicture = doc.sharePicture;\n    const shareWebsite = doc.shareWebsite;\n    const shareInterests = doc.shareInterests;\n    const shareCareerGoals = doc.shareCareerGoals;\n    const shareOpportunities = doc.shareOpportunities;\n    const shareCourses = doc.shareCourses;\n    const shareLevel = doc.shareLevel;\n    const shareAcademicPlan = doc.shareAcademicPlan;\n    return {\n      username, firstName, lastName, picture, website, interests, careerGoals, level, favoriteAcademicPlans,\n      favoriteCourses, favoriteOpportunities, declaredAcademicTerm, isAlumni, retired, shareUsername, sharePicture,\n      shareWebsite, shareInterests, shareCareerGoals, shareOpportunities, shareCourses, shareLevel, shareAcademicPlan,\n    };\n  }\n}\n\n/**\n * Provides the singleton instance this collection to all other entities.\n * @type {api/user.StudentProfileCollection}\n * @memberOf api/user\n */\nexport const StudentProfiles = new StudentProfileCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/StudentProfileCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1114,
    "kind": "variable",
    "name": "StudentProfiles",
    "memberof": "api/user/StudentProfileCollection.ts",
    "static": true,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfiles",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/StudentProfileCollection.ts",
    "importStyle": "{StudentProfiles}",
    "description": "Provides the singleton instance this collection to all other entities.",
    "lineNumber": 613,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/user"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/user.StudentProfileCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1115,
    "kind": "class",
    "name": "StudentProfileCollection",
    "memberof": "api/user/StudentProfileCollection.ts",
    "static": true,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/StudentProfileCollection.ts",
    "importStyle": null,
    "description": "Represents a Student Profile.",
    "lineNumber": 31,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/user/BaseProfileCollection.js~BaseProfileCollection"
    ]
  },
  {
    "__docId__": 1116,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true
  },
  {
    "__docId__": 1117,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1118,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1119,
    "kind": "method",
    "name": "define",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#define",
    "access": "public",
    "description": "Defines the profile associated with a Student.\nThe username does not need to be defined in Meteor Accounts yet, but it must be a unique Slug.",
    "lineNumber": 132,
    "params": [
      {
        "nullable": null,
        "types": [
          "IStudentProfileDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1120,
    "kind": "method",
    "name": "update",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#update",
    "access": "public",
    "description": "Updates the StudentProfile.\nYou cannot change the username or role once defined. (You can implicitly change the role by setting isAlumni).\nUsers in ROLE.STUDENT cannot change their level or isAlumni setting.",
    "lineNumber": 226,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IStudentProfileUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1121,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#removeIt",
    "access": "public",
    "description": "Removes this profile, given its profile ID.\nAlso removes this user from Meteor Accounts.",
    "lineNumber": 325,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "profileID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1122,
    "kind": "method",
    "name": "assertValidLevel",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#assertValidLevel",
    "access": "public",
    "description": "Asserts that level is an integer between 1 and 6.",
    "lineNumber": 336,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "level",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1123,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\nStudent.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 349,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1124,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks the profile common fields and the role..",
    "lineNumber": 359,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1125,
    "kind": "method",
    "name": "getEarnedICE",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#getEarnedICE",
    "access": "public",
    "description": "Returns an ICE object with the total earned course and opportunity ICE values.",
    "lineNumber": 387,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1126,
    "kind": "method",
    "name": "getProjectedICE",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#getProjectedICE",
    "access": "public",
    "description": "Returns an ICE object with the total projected course and opportunity ICE values.",
    "lineNumber": 399,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1127,
    "kind": "method",
    "name": "getCourseIDs",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#getCourseIDs",
    "access": "public",
    "description": "Returns an array of courseIDs that this user has taken (or plans to take) based on their courseInstances.",
    "lineNumber": 410,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1128,
    "kind": "method",
    "name": "getInterestIDs",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#getInterestIDs",
    "access": "public",
    "description": "Returns the user's interests as IDs. It is a union of interestIDs and careerGoal interestIDs.",
    "lineNumber": 423,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1129,
    "kind": "method",
    "name": "getInterestIDsByType",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#getInterestIDsByType",
    "access": "public",
    "description": "Returns the user's interest IDs in an Array with two sub-arrays. The first sub-array is the interest IDs that the\nUser selected. The second sub-array is the interestIDs from the user's career goals.",
    "lineNumber": 442,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1130,
    "kind": "method",
    "name": "setLevel",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#setLevel",
    "access": "public",
    "description": "Updates user's level.",
    "lineNumber": 466,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "level",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1131,
    "kind": "method",
    "name": "publish",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#publish",
    "access": "public",
    "description": "",
    "lineNumber": 471,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1132,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/user/StudentProfileCollection.ts~StudentProfileCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/StudentProfileCollection.ts~StudentProfileCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the StudentProfile docID in a format acceptable to define().",
    "lineNumber": 584,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IStudentProfileDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1133,
    "kind": "file",
    "name": "api/user/UserCollection.methods.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { CallPromiseMixin } from 'meteor/didericis:callpromise-mixin';\nimport { ValidatedMethod } from 'meteor/mdg:validated-method';\nimport _ from 'lodash';\nimport { ROLE } from '../role/Role';\nimport { StudentProfiles } from './StudentProfileCollection';\nimport { Users } from './UserCollection';\n\n/**\n * Allows students to update their academic plans.\n * @memberOf api/user\n */\nexport const updateAcademicPlanMethod = new ValidatedMethod({\n  name: 'User.updateAcademicPlan',\n  mixins: [CallPromiseMixin],\n  validate: null,\n  run(academicPlan) {\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to dump the database..');\n    } else {\n      const profile = Users.getProfile(this.userId);\n      if (!_.includes([ROLE.ADMIN, ROLE.ADVISOR, ROLE.STUDENT], profile.role)) {\n        throw new Meteor.Error('unauthorized', 'You must be an admin, advisor, or student to update the academic plan.');\n      }\n    }\n      // console.log(academicPlan);\n    // Don't update except on server side (disable client-side simulation).\n    if (Meteor.isServer) {\n      // const profile = Users.getProfile(this.userId);\n      // const docID = profile._id;\n      // StudentProfiles.update(docID, { academicPlan });\n      return null;\n    }\n    return null;\n  },\n});\n\nexport const generateStudentEmailsMethod = new ValidatedMethod({\n  name: 'User.studentEmails',\n  mixins: [CallPromiseMixin],\n  validate: null,\n  run() {\n    if (!this.userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in to get student emails.');\n    } else {\n      const profile = Users.getProfile(this.userId);\n      if (!_.includes([ROLE.ADMIN, ROLE.ADVISOR], profile.role)) {\n        throw new Meteor.Error('unauthorized', 'You must be an admin or advisor to get student emails.');\n      }\n    }\n    // Don't generate unless on Server side.\n    if (Meteor.isServer) {\n      const profiles = StudentProfiles.findNonRetired({ isAlumni: false });\n      const students = _.map(profiles, (student) => student.username);\n      return { students };\n    }\n    return null;\n  },\n});\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/UserCollection.methods.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1134,
    "kind": "variable",
    "name": "updateAcademicPlanMethod",
    "memberof": "api/user/UserCollection.methods.ts",
    "static": true,
    "longname": "api/user/UserCollection.methods.ts~updateAcademicPlanMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/UserCollection.methods.ts",
    "importStyle": "{updateAcademicPlanMethod}",
    "description": "Allows students to update their academic plans.",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/user"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1135,
    "kind": "variable",
    "name": "generateStudentEmailsMethod",
    "memberof": "api/user/UserCollection.methods.ts",
    "static": true,
    "longname": "api/user/UserCollection.methods.ts~generateStudentEmailsMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/UserCollection.methods.ts",
    "importStyle": "{generateStudentEmailsMethod}",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1136,
    "kind": "file",
    "name": "api/user/UserCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { Accounts } from 'meteor/accounts-base';\nimport { Roles } from 'meteor/alanning:roles';\nimport _ from 'lodash';\nimport { CareerGoals } from '../career/CareerGoalCollection';\nimport { MentorAnswers } from '../mentor/MentorAnswerCollection';\nimport { MentorQuestions } from '../mentor/MentorQuestionCollection';\nimport { Opportunities } from '../opportunity/OpportunityCollection';\nimport { RadGradProperties } from '../radgrad/RadGradProperties';\nimport { Reviews } from '../review/ReviewCollection';\nimport { ROLE } from '../role/Role';\nimport { AdminProfiles } from './AdminProfileCollection';\nimport { AdvisorProfiles } from './AdvisorProfileCollection';\nimport { StudentProfiles } from './StudentProfileCollection';\nimport { MentorProfiles } from './MentorProfileCollection';\nimport { FacultyProfiles } from './FacultyProfileCollection';\nimport { FavoriteInterests } from '../favorite/FavoriteInterestCollection';\nimport { FavoriteCareerGoals } from '../favorite/FavoriteCareerGoalCollection';\n\n/**\n * Represents a user, which is someone who has a Meteor account.\n *\n * Users are defined when the various Profile collections are initialized, so the User collection is the union\n * of Students, Faculty, Advisors, and Mentors, plus the single Admin account who also has a Meteor account.\n *\n * Note that this collection does not extend any of our Base collections, because it has a very limited API\n * which should be used by clients to access the various Profile collections.\n *\n * It is not saved out or restored when the DB is dumped. It is not listed in RadGrad.collections.\n *\n * Clients provide a \"user\" as a parameter, which is either the username (i.e. email) or userID.\n * @memberOf api/user\n */\nclass UserCollection {\n  private readonly collectionName: string;\n  constructor() {\n    this.collectionName = 'UserCollection';\n  }\n\n  private generateAdminCredential() {\n    if (Meteor.isTest || Meteor.isAppTest || Meteor.settings.public.admin.development) {\n      return 'foo';\n    }\n    // adapted from: https://stackoverflow.com/questions/1349404/generate-random-string-characters-in-javascript\n    let credential = '';\n    const maxPasswordLength = 30;\n    const minPasswordLength = 6;\n    const passwordLength = Math.floor(Math.random() * (maxPasswordLength - (minPasswordLength + 1))) + minPasswordLength;\n    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    for (let i = 0; i < passwordLength; i++) {\n      credential += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return credential;\n  }\n\n  /**\n   * Define a new user, which means creating an entry in Meteor.Accounts.\n   * This is called in the various Profile define() methods.\n   * @param username The username to be defined (must be an email address).\n   * @param role The role.\n   * @returns { String } The docID of the newly created user.\n   * @throws { Meteor.Error } If the user exists.\n   */\n  public define({ username, role }: { username: string; role: string; }) {\n    if (Meteor.isServer) {\n      Roles.createRole(role, { unlessExists: true });\n      if ((role === ROLE.STUDENT) || (role === ROLE.FACULTY) || (role === ROLE.ADVISOR || (role === ROLE.ALUMNI))) {\n        // Define this user with a CAS login.\n        const userWithoutHost = username.split('@')[0];\n        const result = { id: userWithoutHost };\n        const options = { profile: { name: userWithoutHost } };\n        const casReturn: { userId: string; } = Accounts.updateOrCreateUserFromExternalService('cas', result, options);\n        const userID2 = casReturn.userId;\n        Meteor.users.update(userID2, { $set: { username } });\n        Roles.addUsersToRoles(userID2, [role]);\n        return userID2;\n      }\n      if (role === ROLE.ADMIN) {\n        const credential = this.generateAdminCredential();\n        const userID = Accounts.createUser({ username: username, email: username, password: credential });\n        Roles.addUsersToRoles(userID, ROLE.ADMIN);\n        console.log(`Defining admin ${username} with password ${credential}`);\n        return userID;\n      }\n      // Otherwise define this user with a Meteor login and randomly generated password.\n      const password = this.generateRandomPassword();\n      console.log(`Defining ${role} ${username} with password ${password}`);\n      const userID = Accounts.createUser({ username, email: username, password });\n      Roles.addUsersToRoles(userID, [role]);\n      return userID;\n    }\n    return undefined;\n  }\n\n  /**\n   * Generate a random password.\n   * Adapted from: https://stackoverflow.com/questions/1349404/generate-random-string-characters-in-javascript\n   * @returns {string} The password.\n   * @private\n   */\n  private generateRandomPassword() {\n    let password = '';\n    const maxLength = 10;\n    const minLength = 6;\n    const passwordLength = Math.floor(Math.random() * (maxLength - (minLength + 1))) + minLength;\n    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    for (let i = 0; i < passwordLength; i++) {\n      password += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return password;\n  }\n\n  /**\n   * Asserts that the passed user has the specified role.\n   * @param user The user (username or userID).\n   * @param role The role or an array of roles.\n   * @throws { Meteor.Error } If the user does not have the role, or if user or role is not valid.\n   */\n  public assertInRole(user, role) {\n    // console.log('assertInRole(%o, %o)', user, role);\n    const userID = this.getID(user);\n    const profile = this.getProfile(userID);\n    if (Array.isArray(role)) {\n      if (!_.includes(role, profile.role)) {\n        throw new Meteor.Error(`${userID} (${this.getProfile(userID).username}) is not in role ${role}.`);\n      }\n    } else if (profile.role !== role) {\n      throw new Meteor.Error(`${userID} (${this.getProfile(userID).username}) is not in role ${role}.`);\n    }\n  }\n\n  /**\n   * Returns true if user is a defined userID or username.\n   * @param user The user.\n   * @returns { boolean } True if user is defined, false otherwise.\n   */\n  public isDefined(user) {\n    const userDoc = (Meteor.users.findOne({ _id: user })) || (Meteor.users.findOne({ username: user }));\n    return userDoc;\n  }\n\n  /**\n   * Returns the userID associated with user, or throws an error if not defined.\n   * @param user The user (username or userID).\n   * @returns { String } The userID\n   * @throws { Meteor.Error } If user is not a defined username or userID.\n   */\n  public getID(user) {\n    const userDoc = (Meteor.users.findOne({ _id: user })) || (Meteor.users.findOne({ username: user }));\n    if (!userDoc) {\n      console.error('Error: user is not defined: ', user);\n    }\n    return userDoc._id;\n  }\n\n  /**\n   * Returns the userIDs associated with users, or throws an error if any cannot be found.\n   * @param { String[] } users An array of valid users.\n   * @returns { String[] } The docIDs associated with users.\n   * @throws { Meteor.Error } If any instance is not a user.\n   */\n  public getIDs(users) {\n    let ids;\n    try {\n      ids = (users) ? users.map((instance) => this.getID(instance)) : [];\n    } catch (err) {\n      throw new Meteor.Error(`Error in getIDs(): Failed to convert one of ${users} to an ID.`);\n    }\n    return ids;\n  }\n\n  /**\n   * Returns the full name for the given user.\n   * @param user the user (username or ID).\n   * @returns {string} The user's full name.\n   * @throws {Meteor.Error} If user is not a valid user.\n   */\n  public getFullName(user) {\n    const profile = this.getProfile(user);\n    return `${profile.firstName} ${profile.lastName}`;\n  }\n\n  /**\n   * Returns true if user is referenced by other \"public\" entities. Specifically:\n   *   * The user is a student and has published a review.\n   *   * The user is a mentor and has published an answer.\n   *   * The user is a student and has published a question.\n   *   * The user is a faculty member as has sponsored an opportunity.\n   * Used to determine if this user can be deleted.\n   * Note this doesn't test for references to CourseInstances, etc. These are \"private\" and will be deleted\n   * implicitly if this user is deleted.\n   * @param user The username or userID.\n   * @returns {boolean} True if this user is referenced \"publicly\" elsewhere.\n   * @throws { Meteor.Error } If the username is not defined.\n   */\n  public isReferenced(user) {\n    const userID = this.getID(user);\n    const hasReviews = Reviews.find({ studentID: userID }).count();\n    const hasAnswers = MentorAnswers.find({ mentorID: userID }).count();\n    const hasQuestions = MentorQuestions.find({ studentID: userID }).count();\n    const hasOpportunities = Opportunities.find({ sponsorID: userID }).count(); // TODO CAM can this be non-retired?\n    return (hasReviews || hasAnswers || hasQuestions || hasOpportunities);\n  }\n\n  /**\n   * Returns the profile document associated with user, or null if not found.\n   * Assumes that the user is defined. If not, throws an error.\n   * @param user The username or userID.\n   * @returns { Object | Null } The profile document or null if not found.\n   */\n  public hasProfile(user) {\n    const userID = this.getID(user);\n    return StudentProfiles.hasProfile(userID) || FacultyProfiles.hasProfile(userID)\n      || MentorProfiles.hasProfile(userID) || AdvisorProfiles.hasProfile(userID)\n      || AdminProfiles.hasProfile(userID);\n  }\n\n  /**\n   * Returns the profile associated with the passed username, or null if not found.\n   * Does not check to see if the user is defined, which makes this method useful for Accounts.validateNewUser.\n   * @param username A username.\n   * @returns The profile document, or null if not found.\n   */\n  public findProfileFromUsername(username) {\n    return StudentProfiles.findByUsername(username) || FacultyProfiles.findByUsername(username)\n      || MentorProfiles.findByUsername(username) || AdvisorProfiles.findByUsername(username);\n  }\n\n  public count() {\n    return StudentProfiles.count() + FacultyProfiles.count() + MentorProfiles.count() + AdvisorProfiles.count();\n  }\n\n  /**\n   * Returns the admin username from the settings file, or 'radgrad@hawaii.edu' (for testing purposes).\n   * @returns {string} The admin username.\n   * @private\n   */\n  private adminUsername() {\n    return RadGradProperties.getAdminEmail();\n  }\n\n  /**\n   * Returns the admin userID.\n   * @private\n   */\n  private getAdminID() {\n    const username = this.adminUsername();\n    let adminDoc = Meteor.users.findOne({ username });\n    // The admin is user is not created by the startup code during unit testing.\n    // This is kind of a hack to implicitly define the admin user during unit tests.\n    if (!adminDoc && Meteor.isServer && Meteor.isTest) {\n      const userID = Accounts.createUser({ username, email: username, password: 'foo' });\n      Roles.createRole(ROLE.ADMIN, { unlessExists: true });\n      Roles.addUsersToRoles(userID, ROLE.ADMIN);\n      adminDoc = Meteor.users.findOne({ username });\n    }\n    return adminDoc._id;\n  }\n\n  /**\n   * There is only one admin and there is no collection for them. (This might be a mistake).\n   * Anyway, this function returns an object that serves as their profile.\n   * @returns The admin profile.\n   * @private\n   */\n  private getAdminProfile() {\n    const adminUsername = this.adminUsername();\n    const adminID = Meteor.users.findOne({ username: adminUsername })._id;\n    return { username: adminUsername, firstName: 'RadGrad', lastName: 'Admin', role: ROLE.ADMIN, userID: adminID };\n  }\n\n  /**\n   * Returns the profile document associated with user.\n   * @param user The username or userID.\n   * @returns { Object } The profile document.\n   * @throws { Meteor.Error } If the document was not found.\n   */\n  public getProfile(user) {\n    // First, let's check to see if user is actually a profile (or looks like one). If so, just return it.\n    if (_.isObject(user) && _.has(user, 'firstName') && _.has(user, 'lastName') && _.has(user, 'role')) {\n      return user;\n    }\n    const profile = this.hasProfile(user);\n    if (!profile) {\n      console.log(`No profile found for user ${user}`);\n      throw new Meteor.Error(`No profile found for user ${user}`);\n    }\n    return profile;\n  }\n\n  /**\n   * DO NOT USE.\n   * @throws { Meteor.Error } Should not be used. Should remove the profile for the user.\n   */\n  public removeIt(user) {\n    const userID = this.getID(user);\n    if (!this.isReferenced(userID)) {\n      Meteor.users.remove(userID);\n    } else {\n      throw new Meteor.Error(`Attempt to remove ${user} while references to public entities remain.`);\n    }\n  }\n\n  /**\n   * Removes all users except for the admin user.\n   * This is implemented by mapping through all elements because mini-mongo does not implement the remove operation.\n   * So this approach can be used on both client and server side.\n   * removeAll should only used for testing purposes, so it doesn't need to be efficient.\n   */\n  public removeAll() {\n    const users = Meteor.users.find().fetch();\n    _.forEach(users, (i) => {\n      if (!(this.adminUsername() === i.username)) {\n        this.removeIt(i._id);\n      }\n    });\n  }\n\n  /**\n   * Runs find on all the Profile collections, fetches the associated documents, and returns an array containing all\n   * of the matches.\n   * @see {@link http://docs.meteor.com/#/full/find|Meteor Docs on Mongo Find}\n   * @param { Object } selector A MongoDB selector.\n   * @param { Object } options MongoDB options.\n   * @returns { Array } An array of documents matching the selector and options.\n   */\n  public findProfiles(selector, options) {\n    const theSelector = (typeof selector === 'undefined') ? {} : selector;\n    let profiles = [];\n    profiles = profiles.concat(StudentProfiles.findNonRetired(theSelector, options));\n    profiles = profiles.concat(AdvisorProfiles.findNonRetired(theSelector, options));\n    profiles = profiles.concat(FacultyProfiles.findNonRetired(theSelector, options));\n    profiles = profiles.concat(MentorProfiles.findNonRetired(theSelector, options));\n    return profiles;\n  }\n\n  /**\n   * Runs find on all the Profile collections, fetches the associated documents, and returns an array containing all\n   * of the matches.\n   * @see {@link http://docs.meteor.com/#/full/find|Meteor Docs on Mongo Find}\n   * @param { Object } selector A MongoDB selector.\n   * @param { Object } options MongoDB options.\n   * @returns { Array } An array of documents matching the selector and options.\n   */\n  public findProfilesWithRole(role, selector, options) {\n    const theSelector = (typeof selector === 'undefined') ? {} : selector;\n    if (role === ROLE.STUDENT) {\n      theSelector.isAlumni = false;\n      return StudentProfiles.findNonRetired(theSelector, options);\n    }\n    if (role === ROLE.ALUMNI) {\n      theSelector.isAlumni = true;\n      return StudentProfiles.findNonRetired(theSelector, options);\n    }\n    if (role === ROLE.ADVISOR) {\n      return AdvisorProfiles.findNonRetired(theSelector, options);\n    }\n    if (role === ROLE.FACULTY) {\n      return FacultyProfiles.findNonRetired(theSelector, options);\n    }\n    if (role === ROLE.MENTOR) {\n      return MentorProfiles.findNonRetired(theSelector, options);\n    }\n    if (role === ROLE.ADMIN) {\n      return [this.getAdminProfile()];\n    }\n    console.log(`Unknown role: ${role}`);\n    throw new Meteor.Error(`Unknown role: ${role}`);\n  }\n\n  /**\n   * Iterates through all Profile collections, and returns an array of profiles that satisfy filter.\n   * @param filter A function that accepts a profile a document and returns truthy if that document should be included\n   * in the returned array.\n   * @returns {Array} An array of profile documents from across all the Profile collections satisfying filter.\n   */\n  public filterProfiles(filter) {\n    const profiles = [];\n    StudentProfiles.find().forEach((profile) => {\n      if (filter(profile)) {\n        profiles.push(profile);\n      }\n    });\n    AdvisorProfiles.find().forEach((profile) => {\n      if (filter(profile)) {\n        profiles.push(profile);\n      }\n    });\n    FacultyProfiles.find().forEach((profile) => {\n      if (filter(profile)) {\n        profiles.push(profile);\n      }\n    });\n    MentorProfiles.find().forEach((profile) => {\n      if (filter(profile)) {\n        profiles.push(profile);\n      }\n    });\n    return profiles;\n  }\n\n  /**\n   * Returns true if at least one profile satisfies the passed predicate.\n   * @param predicate A function which can be applied to any document in any profile collection and returns true\n   * or false.\n   * @returns {boolean} True if at least one document satisfies the predicate.\n   */\n  public someProfiles(predicate) {\n    let exists = false;\n    StudentProfiles.find().forEach((profile) => {\n      if (predicate(profile)) {\n        exists = true;\n      }\n    });\n    if (exists) {\n      return true;\n    }\n    AdvisorProfiles.find().forEach((profile) => {\n      if (predicate(profile)) {\n        exists = true;\n      }\n    });\n    if (exists) {\n      return true;\n    }\n    FacultyProfiles.find().forEach((profile) => {\n      if (predicate(profile)) {\n        exists = true;\n      }\n    });\n    if (exists) {\n      return true;\n    }\n    MentorProfiles.find().forEach((profile) => {\n      if (predicate(profile)) {\n        exists = true;\n      }\n    });\n    if (exists) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns the user's interests as IDs. It is a union of interestIDs and careerGoal interestIDs.\n   * @param user The username or userID.\n   * @returns {Array} An array of interestIDs.\n   */\n  public getInterestIDs(user) {\n    const profile = this.getProfile(user);\n    const userID = profile.userID;\n    let interestIDs = [];\n    const favoriteInterests = FavoriteInterests.findNonRetired({ userID });\n    _.forEach(favoriteInterests, (fav) => {\n      interestIDs.push(fav.interestID);\n    });\n    const favoriteCareerGoals = FavoriteCareerGoals.findNonRetired({ userID });\n    _.forEach(favoriteCareerGoals, (fav) => {\n      const goal = CareerGoals.findDoc(fav.careerGoalID);\n      interestIDs = _.union(interestIDs, goal.interestIDs);\n    });\n    return interestIDs;\n  }\n\n  /**\n   * Returns the user's interest IDs in an Array with two sub-arrays. The first sub-array is the interest IDs that the\n   * User selected. The second sub-array is the interestIDs from the user's career goals that are not already present\n   * in the first subarray.\n   * @param user The username or userID.\n   * @returns { Array } An array with two subarrays, each containing interestIDs.\n   */\n  public getInterestIDsByType(user) {\n    const profile = this.getProfile(user);\n    const userID = profile.userID;\n    const interestIDs = [];\n    const userInterests = [];\n    const favoriteInterests = FavoriteInterests.findNonRetired({ userID });\n    _.forEach(favoriteInterests, (fav) => {\n      userInterests.push(fav.interestID);\n    });\n    interestIDs.push(userInterests);\n    let careerInterestIDs = [];\n    const favoriteCareerGoals = FavoriteCareerGoals.findNonRetired({ userID });\n    _.forEach(favoriteCareerGoals, (fav) => {\n      const goal = CareerGoals.findDoc(fav.careerGoalID);\n      careerInterestIDs = _.union(careerInterestIDs, goal.interestIDs);\n    });\n    careerInterestIDs = _.difference(careerInterestIDs, userInterests);\n    interestIDs.push(careerInterestIDs);\n    return interestIDs;\n  }\n\n  /**\n   * Publish the username field for all users.\n   */\n  public publish() {\n    if (Meteor.isServer) {\n      Meteor.publish(this.collectionName, () => Meteor.users.find({}, {\n        fields: {\n          username: 1,\n          roles: 1,\n          status: 1,\n        },\n      }));\n    }\n  }\n\n  /**\n   * Default subscription method for entities.\n   * It subscribes to the entire collection.\n   */\n  public subscribe() {\n    if (Meteor.isClient) {\n      return Meteor.subscribe(this.collectionName);\n    }\n    return null;\n  }\n\n  /**\n   * Return the publication name.\n   * @returns { String } The publication name, as a string.\n   */\n  public getPublicationName() {\n    return this.collectionName;\n  }\n}\n\n/**\n * Provides the singleton instance of this class to other entities.\n * @type {api/user.UserCollection}\n * @memberOf api/user\n */\nexport const Users = new UserCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/UserCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1137,
    "kind": "variable",
    "name": "Users",
    "memberof": "api/user/UserCollection.ts",
    "static": true,
    "longname": "api/user/UserCollection.ts~Users",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/UserCollection.ts",
    "importStyle": "{Users}",
    "description": "Provides the singleton instance of this class to other entities.",
    "lineNumber": 583,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/user"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/user.UserCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1138,
    "kind": "class",
    "name": "UserCollection",
    "memberof": "api/user/UserCollection.ts",
    "static": true,
    "longname": "api/user/UserCollection.ts~UserCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/user/UserCollection.ts",
    "importStyle": null,
    "description": "Represents a user, which is someone who has a Meteor account.\n\nUsers are defined when the various Profile collections are initialized, so the User collection is the union\nof Students, Faculty, Advisors, and Mentors, plus the single Admin account who also has a Meteor account.\n\nNote that this collection does not extend any of our Base collections, because it has a very limited API\nwhich should be used by clients to access the various Profile collections.\n\nIt is not saved out or restored when the DB is dumped. It is not listed in RadGrad.collections.\n\nClients provide a \"user\" as a parameter, which is either the username (i.e. email) or userID.",
    "lineNumber": 34,
    "pseudoExport": true,
    "interface": false
  },
  {
    "__docId__": 1139,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 36,
    "undocument": true
  },
  {
    "__docId__": 1140,
    "kind": "member",
    "name": "collectionName",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#collectionName",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1141,
    "kind": "method",
    "name": "generateAdminCredential",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#generateAdminCredential",
    "access": "public",
    "description": "",
    "lineNumber": 40,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1142,
    "kind": "method",
    "name": "define",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#define",
    "access": "public",
    "description": "Define a new user, which means creating an entry in Meteor.Accounts.\nThis is called in the various Profile define() methods.",
    "lineNumber": 64,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1143,
    "kind": "method",
    "name": "generateRandomPassword",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#generateRandomPassword",
    "access": "public",
    "description": "Generate a random password.\nAdapted from: https://stackoverflow.com/questions/1349404/generate-random-string-characters-in-javascript",
    "lineNumber": 101,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1144,
    "kind": "method",
    "name": "assertInRole",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#assertInRole",
    "access": "public",
    "description": "Asserts that the passed user has the specified role.",
    "lineNumber": 119,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "role",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1145,
    "kind": "method",
    "name": "isDefined",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#isDefined",
    "access": "public",
    "description": "Returns true if user is a defined userID or username.",
    "lineNumber": 137,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1146,
    "kind": "method",
    "name": "getID",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#getID",
    "access": "public",
    "description": "Returns the userID associated with user, or throws an error if not defined.",
    "lineNumber": 148,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1147,
    "kind": "method",
    "name": "getIDs",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#getIDs",
    "access": "public",
    "description": "Returns the userIDs associated with users, or throws an error if any cannot be found.",
    "lineNumber": 162,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "users",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1148,
    "kind": "method",
    "name": "getFullName",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#getFullName",
    "access": "public",
    "description": "Returns the full name for the given user.",
    "lineNumber": 178,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1149,
    "kind": "method",
    "name": "isReferenced",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#isReferenced",
    "access": "public",
    "description": "Returns true if user is referenced by other \"public\" entities. Specifically:\nThe user is a student and has published a review.\nThe user is a mentor and has published an answer.\nThe user is a student and has published a question.\nThe user is a faculty member as has sponsored an opportunity.\nUsed to determine if this user can be deleted.\nNote this doesn't test for references to CourseInstances, etc. These are \"private\" and will be deleted\nimplicitly if this user is deleted.",
    "lineNumber": 196,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1150,
    "kind": "method",
    "name": "hasProfile",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#hasProfile",
    "access": "public",
    "description": "Returns the profile document associated with user, or null if not found.\nAssumes that the user is defined. If not, throws an error.",
    "lineNumber": 211,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1151,
    "kind": "method",
    "name": "findProfileFromUsername",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#findProfileFromUsername",
    "access": "public",
    "description": "Returns the profile associated with the passed username, or null if not found.\nDoes not check to see if the user is defined, which makes this method useful for Accounts.validateNewUser.",
    "lineNumber": 224,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "username",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1152,
    "kind": "method",
    "name": "count",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#count",
    "access": "public",
    "description": "",
    "lineNumber": 229,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1153,
    "kind": "method",
    "name": "adminUsername",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#adminUsername",
    "access": "public",
    "description": "Returns the admin username from the settings file, or 'radgrad@hawaii.edu' (for testing purposes).",
    "lineNumber": 238,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1154,
    "kind": "method",
    "name": "getAdminID",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#getAdminID",
    "access": "public",
    "description": "Returns the admin userID.",
    "lineNumber": 246,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1155,
    "kind": "method",
    "name": "getAdminProfile",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#getAdminProfile",
    "access": "public",
    "description": "There is only one admin and there is no collection for them. (This might be a mistake).\nAnyway, this function returns an object that serves as their profile.",
    "lineNumber": 266,
    "params": [],
    "return": {
      "types": [
        "{\"username\": *, \"firstName\": string, \"lastName\": string, \"role\": *, \"userID\": *}"
      ]
    }
  },
  {
    "__docId__": 1156,
    "kind": "method",
    "name": "getProfile",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#getProfile",
    "access": "public",
    "description": "Returns the profile document associated with user.",
    "lineNumber": 278,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1157,
    "kind": "method",
    "name": "removeIt",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#removeIt",
    "access": "public",
    "description": "DO NOT USE.",
    "lineNumber": 295,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1158,
    "kind": "method",
    "name": "removeAll",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#removeAll",
    "access": "public",
    "description": "Removes all users except for the admin user.\nThis is implemented by mapping through all elements because mini-mongo does not implement the remove operation.\nSo this approach can be used on both client and server side.\nremoveAll should only used for testing purposes, so it doesn't need to be efficient.",
    "lineNumber": 310,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1159,
    "kind": "method",
    "name": "findProfiles",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#findProfiles",
    "access": "public",
    "description": "Runs find on all the Profile collections, fetches the associated documents, and returns an array containing all\nof the matches.",
    "lineNumber": 327,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "selector",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1160,
    "kind": "method",
    "name": "findProfilesWithRole",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#findProfilesWithRole",
    "access": "public",
    "description": "Runs find on all the Profile collections, fetches the associated documents, and returns an array containing all\nof the matches.",
    "lineNumber": 345,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "role",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "selector",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    }
  },
  {
    "__docId__": 1161,
    "kind": "method",
    "name": "filterProfiles",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#filterProfiles",
    "access": "public",
    "description": "Iterates through all Profile collections, and returns an array of profiles that satisfy filter.",
    "lineNumber": 377,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "filter",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1162,
    "kind": "method",
    "name": "someProfiles",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#someProfiles",
    "access": "public",
    "description": "Returns true if at least one profile satisfies the passed predicate.",
    "lineNumber": 408,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "predicate",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 1163,
    "kind": "method",
    "name": "getInterestIDs",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#getInterestIDs",
    "access": "public",
    "description": "Returns the user's interests as IDs. It is a union of interestIDs and careerGoal interestIDs.",
    "lineNumber": 450,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1164,
    "kind": "method",
    "name": "getInterestIDsByType",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#getInterestIDsByType",
    "access": "public",
    "description": "Returns the user's interest IDs in an Array with two sub-arrays. The first sub-array is the interest IDs that the\nUser selected. The second sub-array is the interestIDs from the user's career goals that are not already present\nin the first subarray.",
    "lineNumber": 473,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1165,
    "kind": "method",
    "name": "publish",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#publish",
    "access": "public",
    "description": "Publish the username field for all users.",
    "lineNumber": 497,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1166,
    "kind": "method",
    "name": "subscribe",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#subscribe",
    "access": "public",
    "description": "Default subscription method for entities.\nIt subscribes to the entire collection.",
    "lineNumber": 513,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1167,
    "kind": "method",
    "name": "getPublicationName",
    "memberof": "api/user/UserCollection.ts~UserCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/user/UserCollection.ts~UserCollection#getPublicationName",
    "access": "public",
    "description": "Return the publication name.",
    "lineNumber": 524,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1168,
    "kind": "file",
    "name": "api/user/index.ts",
    "content": "/** @namespace api/user */\nimport './BaseProfileCollection';\nimport './AdvisorProfileCollection';\nimport './MentorProfileCollection';\nimport './FacultyProfileCollection';\nimport './StudentProfileCollection';\nimport './UserCollection';\nimport './UserCollection.methods';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/user/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1169,
    "kind": "file",
    "name": "api/utilities/load-fixtures.ts",
    "content": "import _ from 'lodash';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { UserInteractions } from '../analytic/UserInteractionCollection';\nimport BaseCollection from '../base/BaseCollection';\nimport { Courses } from '../course/CourseCollection';\nimport { CourseInstances } from '../course/CourseInstanceCollection';\nimport { Opportunities } from '../opportunity/OpportunityCollection';\nimport { OpportunityInstances } from '../opportunity/OpportunityInstanceCollection';\nimport { Slugs } from '../slug/SlugCollection';\nimport { getDefinitions } from '../test/test-utilities';\nimport { Users } from '../user/UserCollection';\nimport { AdvisorProfiles } from '../user/AdvisorProfileCollection';\nimport { FacultyProfiles } from '../user/FacultyProfileCollection';\nimport { MentorProfiles } from '../user/MentorProfileCollection';\nimport { StudentProfiles } from '../user/StudentProfileCollection';\nimport { AcademicYearInstances } from '../degree-plan/AcademicYearInstanceCollection';\nimport { PlanChoices } from '../degree-plan/PlanChoiceCollection';\nimport { Feeds } from '../feed/FeedCollection';\nimport { FeedbackInstances } from '../feedback/FeedbackInstanceCollection';\nimport { HelpMessages } from '../help/HelpMessageCollection';\nimport { AdvisorLogs } from '../log/AdvisorLogCollection';\nimport { MentorAnswers } from '../mentor/MentorAnswerCollection';\nimport { MentorQuestions } from '../mentor/MentorQuestionCollection';\n\nexport const loadCollectionNewDataOnly = (collection: BaseCollection, loadJSON, printToConsole) => {\n  let retVal = '';\n  // console.log('loadCollectionNewDataOnly', loadJSON, printToConsole, typeof collection);\n  const type = collection.getType();\n  const definitions = getDefinitions(loadJSON, collection.getCollectionName());\n  let count = 0;\n  _.forEach(definitions, (definition) => {\n    let studentID;\n    let termID;\n    switch (type) {\n      case UserInteractions.getType():\n        if (UserInteractions.find({\n          username: definition.username,\n          type: definition.type,\n          typeData: definition.typeData,\n          timestamp: definition.timestamp,\n        }).count() === 0) {\n          collection.define(definition);\n          count++;\n        }\n        break;\n      case CourseInstances.getType():\n        // console.log(definition.student);\n        // eslint-disable-next-line no-case-declarations\n        termID = AcademicTerms.getID(definition.academicTerm);\n        // eslint-disable-next-line no-case-declarations\n        const courseID = Courses.getID(definition.course);\n        // eslint-disable-next-line no-case-declarations\n        studentID = Users.getID(definition.student);\n        if (CourseInstances.find({ termID, courseID, studentID }).count() === 0) {\n          collection.define(definition);\n          count++;\n        }\n        break;\n      case AcademicYearInstances.getType(): {\n        studentID = Users.getID(definition.student);\n        if (AcademicYearInstances.find({ year: definition.year, studentID })\n          .count() === 0) {\n          collection.define(definition);\n          count++;\n        }\n      }\n        break;\n      case PlanChoices.getType():\n        if (PlanChoices.find({ choice: definition.choice })\n          .count() === 0) {\n          collection.define(definition);\n          count++;\n        }\n        break;\n      case Feeds.getType():\n        if (Feeds.find({\n          feedType: definition.feedType,\n          description: definition.description,\n          timestamp: definition.timestamp,\n        }).count() === 0) {\n          collection.define(definition);\n          count++;\n        }\n        break;\n      case FeedbackInstances.getType(): {\n        const userID = Users.getID(definition.user);\n        if (FeedbackInstances.find({\n          userID,\n          functionName: definition.functionName,\n          description: definition.description,\n          feedbackType: definition.feedbackType,\n        })\n          .count() === 0) {\n          collection.define(definition);\n          count++;\n        }\n      }\n        break;\n      case HelpMessages.getType():\n        if (HelpMessages.find({ routeName: definition.routeName })\n          .count() === 0) {\n          collection.define(definition);\n          count++;\n        }\n        break;\n      case AdvisorLogs.getType(): {\n        const advisorID = Users.getID(definition.advisor);\n        studentID = Users.getID(definition.student);\n        if (AdvisorLogs.find({\n          advisorID, studentID, text: definition.text, createdOn: definition.createdOn,\n        })\n          .count() === 0) {\n          collection.define(definition);\n          count++;\n        }\n      }\n        break;\n      case MentorAnswers.getType(): {\n        const questionID = MentorQuestions.getID(definition.question);\n        const mentorID = Users.getID(definition.mentor);\n        if (MentorAnswers.find({ questionID, mentorID, text: definition.text })\n          .count() === 0) {\n          collection.define(definition);\n          count++;\n        }\n      }\n        break;\n      case OpportunityInstances.getType():\n        termID = AcademicTerms.getID(definition.academicTerm);\n        studentID = Users.getID(definition.student);\n        // eslint-disable-next-line no-case-declarations\n        const opportunityID = Opportunities.getID(definition.opportunity);\n        if (OpportunityInstances.find({ termID, studentID, opportunityID }).count() === 0) {\n          collection.define(definition);\n        }\n        break;\n      case AdvisorProfiles.getType():\n      case FacultyProfiles.getType():\n      case MentorProfiles.getType():\n      case StudentProfiles.getType():\n        if (collection.find({ username: definition.username })\n          .count() === 0) {\n          collection.define(definition);\n          count++;\n        }\n        break;\n      default: // Slug collections\n        if ('slug' in definition) {\n          if (!Slugs.isDefined(definition.slug)) {\n            collection.define(definition);\n            count++;\n          }\n        }\n    }\n  });\n  if (count > 1) {\n    retVal += `Defined ${count} ${type}s`;\n  } else if (count === 1) {\n    retVal += `Defined a ${type}`;\n  }\n  return retVal;\n};\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/utilities/load-fixtures.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1170,
    "kind": "function",
    "name": "loadCollectionNewDataOnly",
    "memberof": "api/utilities/load-fixtures.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/utilities/load-fixtures.ts~loadCollectionNewDataOnly",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/utilities/load-fixtures.ts",
    "importStyle": "{loadCollectionNewDataOnly}",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [
      {
        "name": "collection",
        "types": [
          "*"
        ]
      },
      {
        "name": "loadJSON",
        "types": [
          "*"
        ]
      },
      {
        "name": "printToConsole",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1171,
    "kind": "file",
    "name": "api/verification/VerificationRequestCollection.methods.app-test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { processVerificationEventMethod } from './VerificationRequestCollection.methods';\nimport { defineTestFixturesMethod, withRadGradSubscriptions, withLoggedInUser } from '../test/test-utilities';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isClient) {\n  describe('VerificationRequestCollection Meteor Methods ', function test() {\n    before(function b(done) {\n      defineTestFixturesMethod.call(['minimal', 'abi.student', 'opportunities'], done);\n    });\n\n    it('ProcessVerificationEvent Method', async function processVerification() {\n      await withLoggedInUser();\n      await withRadGradSubscriptions();\n      const student = 'abi@hawaii.edu';\n      const opportunity = 'acm-icpc';\n      const academicTerm = AcademicTerms.getAcademicTerm(new Date('2016-11-18T00:00:00.000Z'));\n      await processVerificationEventMethod.callPromise({ student, opportunity, academicTerm });\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/verification/VerificationRequestCollection.methods.app-test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1172,
    "kind": "file",
    "name": "api/verification/VerificationRequestCollection.methods.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { ValidatedMethod } from 'meteor/mdg:validated-method';\nimport { CallPromiseMixin } from 'meteor/didericis:callpromise-mixin';\nimport { VerificationRequests } from './VerificationRequestCollection';\nimport { Feeds } from '../feed/FeedCollection';\nimport { OpportunityInstances } from '../opportunity/OpportunityInstanceCollection';\nimport { Opportunities } from '../opportunity/OpportunityCollection';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { Users } from '../user/UserCollection';\nimport { ROLE } from '../role/Role';\n\n/**\n * The ValidatedMethod for updating the status of VerificationRequests.\n * Passed an object with fields:\n * id: the verificationRequestID\n * status: boolean\n * processed: a project object.\n * @memberOf api/verification\n */\nexport const verificationRequestsUpdateStatusMethod = new ValidatedMethod({\n  name: 'VerificationRequests.updateStatus',\n  validate: null,\n  mixins: [CallPromiseMixin],\n  run(update) {\n    // Verify that currently logged in user is an admin, advisor, or faculty. otherwise no update can occur.\n    VerificationRequests.assertRole(Meteor.userId(), [ROLE.ADMIN, ROLE.ADVISOR, ROLE.FACULTY]);\n    return VerificationRequests.updateStatus(update.id, update.status, update.processed);\n  },\n});\n\n/**\n * Returns the opportunityInstanceID associated with the student and opportunity, or null if not found.\n * @param student The student.\n * @param opportunity The opportunity.\n * @param academicTerm The academicTerm\n * @returns The opportunityInstanceID, or null if it wasn't found.\n * @memberOf api/verification\n */\nfunction getOpportunityInstanceID(student, opportunity, academicTerm) {\n  const studentID = Users.getID(student);\n  const opportunityID = Opportunities.getID(opportunity);\n  const termID = AcademicTerms.getID(academicTerm);\n  const opportunityInstances = OpportunityInstances.findNonRetired({ opportunityID, studentID, termID });\n  return (opportunityInstances.length > 0) ? opportunityInstances[0]._id : null;\n}\n\n/**\n * This Meteor Method processes a request to verify an opportunity for a given user from the VerificationEvent page.\n * The method is passed a student, opportunity, and academicTerm, which should normally be valid.\n * Processing this request involves the following:\n *   * If the student does not have an Opportunity Instance for this opportunity and academicTerm, then one is created\n *     for them.\n *   * If the student has not already submitted a Verification Request for their Opportunity Instance, then one is\n *     created for them.\n *   * If the student has already been verified for this Opportunity, then nothing more is done.\n *   * Once the OpportunityInstance and VerificationRequest exist, then they are updated to indicate that they have\n *     been verified if they are not already verified.\n *   * A status string is returned to the caller to indicate the result of processing.\n * Only faculty, advisors, and admins can invoke this method.\n * @memberOf api/verification\n */\nexport const processVerificationEventMethod = new ValidatedMethod({\n  name: 'VerificationRequests.processVerificationEvent',\n  validate: null,\n  mixins: [CallPromiseMixin],\n  run({ student, opportunity, academicTerm, verified = false }: { student: string; opportunity: string; academicTerm: string; verified?: boolean; }) {\n    // Define a string to hold the result of this process.\n    let resultMessage = '';\n\n    // Verify that currently logged in user is an admin, advisor, or faculty. otherwise no verification can occur.\n    VerificationRequests.assertRole(Meteor.userId(), [ROLE.ADMIN, ROLE.ADVISOR, ROLE.FACULTY]);\n\n    // Make sure there's an opportunity instance for this student.\n    let opportunityInstanceID = getOpportunityInstanceID(student, opportunity, academicTerm);\n    if (!opportunityInstanceID) {\n      resultMessage += '  No opportunity instance found. Defining a new one.\\n';\n      opportunityInstanceID = OpportunityInstances.define({ academicTerm, opportunity, student, verified });\n    }\n\n    // Make sure there's a verification request for this opportunity instance.\n    let verificationRequestID = VerificationRequests.findOne({ opportunityInstanceID });\n    if (!verificationRequestID) {\n      resultMessage += '  No verification request found. Defining a new one.\\n';\n      verificationRequestID = VerificationRequests.define({ student, opportunityInstance: opportunityInstanceID });\n    }\n\n    // If this event has already been verified, then return now.\n    if (OpportunityInstances.findDoc(opportunityInstanceID).verified) {\n      const opp = Opportunities.findDoc(opportunity);\n      return `  Event ${opp.name} is already verified for ${student}\\n`;\n    }\n\n    // Otherwise verify the opportunity instance and the VerificationRequestID.\n    resultMessage += '  Setting the opportunity instance and verification request to verified.\\n';\n    OpportunityInstances.update(opportunityInstanceID, { verified: true });\n    VerificationRequests.setVerified(verificationRequestID, Meteor.userId());\n\n    // Create a Feed entry for this verification event.\n    resultMessage += '  Creating a feed entry.\\n';\n    Feeds.define({ feedType: Feeds.VERIFIED_OPPORTUNITY, user: student, opportunity, academicTerm });\n\n    return resultMessage;\n  },\n});\n\n/**\n * This Meteor Method processes a command from the Pending Verification Request widget.\n * The method is passed a verificationRequestID, a command (ACCEPTED or REJECTED), and an optional feedback string.\n * The method returns a string indicating what happened.\n * Processing this request involves the following:\n *\n *   * Make sure user is a faculty, advisor, or admin. Otherwise throw error.\n *   * If verificationRequestID is not a valid ID, then throw error.\n *   * If command is not VerificationRequests.ACCEPTED or VerificationRequests.REJECTED, then returns an error string.\n *   * Creates a process object to record this command.\n *   * Updates the VerificationRequest with the new process object and the new status.\n *   * Creates a new Feed instance only if the request was accepted.\n *\n * Only faculty, advisors, and admins can invoke this method.\n * @memberOf api/verification\n */\nexport const processPendingVerificationMethod = new ValidatedMethod({\n  name: 'VerificationRequests.processPendingVerification',\n  validate: null,\n  mixins: [CallPromiseMixin],\n  run({ verificationRequestID, command, feedback }) {\n    // Verify that currently logged in user is an admin, advisor, or faculty. otherwise no verification can occur.\n    VerificationRequests.assertRole(Meteor.userId(), [ROLE.ADMIN, ROLE.ADVISOR, ROLE.FACULTY]);\n\n    // Verify that the ID is valid.\n    const requestDoc = VerificationRequests.findDoc(verificationRequestID);\n\n    // Verify that the command is VerificationRequests.ACCEPTED or REJECTED.\n    if ((command !== VerificationRequests.ACCEPTED) && (command !== VerificationRequests.REJECTED)) {\n      throw new Meteor.Error(`VerificationRequest command is invalid: ${command}`);\n    }\n\n    // Update the opportunityInstance corresponding to this verification request.\n    const verified = (command === VerificationRequests.ACCEPTED);\n    OpportunityInstances.update(requestDoc.opportunityInstanceID, { verified });\n\n    // Update the verification request.\n    VerificationRequests.setVerificationStatus(verificationRequestID, Meteor.userId(), command, feedback);\n\n    // Create a feed entry only if it was verified\n    const student = Users.getProfile(requestDoc.studentID).username;\n    if (verified) {\n      const opportunityInstanceID = requestDoc.opportunityInstanceID;\n      const opportunity = OpportunityInstances.getOpportunityDoc(opportunityInstanceID)._id;\n      const academicTermDoc = OpportunityInstances.getAcademicTermDoc(opportunityInstanceID);\n      const academicTerm = `${academicTermDoc.term}-${academicTermDoc.year}`;\n      Feeds.define({ feedType: Feeds.VERIFIED_OPPORTUNITY, user: student, opportunity, academicTerm });\n    }\n    return `Verification request for ${student} was processed`;\n  },\n});\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/verification/VerificationRequestCollection.methods.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1173,
    "kind": "variable",
    "name": "verificationRequestsUpdateStatusMethod",
    "memberof": "api/verification/VerificationRequestCollection.methods.ts",
    "static": true,
    "longname": "api/verification/VerificationRequestCollection.methods.ts~verificationRequestsUpdateStatusMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/verification/VerificationRequestCollection.methods.ts",
    "importStyle": "{verificationRequestsUpdateStatusMethod}",
    "description": "The ValidatedMethod for updating the status of VerificationRequests.\nPassed an object with fields:\nid: the verificationRequestID\nstatus: boolean\nprocessed: a project object.",
    "lineNumber": 19,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/verification"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1174,
    "kind": "function",
    "name": "getOpportunityInstanceID",
    "memberof": "api/verification/VerificationRequestCollection.methods.ts",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "api/verification/VerificationRequestCollection.methods.ts~getOpportunityInstanceID",
    "access": "public",
    "export": false,
    "importPath": "radgrad2/api/verification/VerificationRequestCollection.methods.ts",
    "importStyle": null,
    "description": "Returns the opportunityInstanceID associated with the student and opportunity, or null if not found.",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "student",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "opportunity",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "academicTerm",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 1175,
    "kind": "variable",
    "name": "processVerificationEventMethod",
    "memberof": "api/verification/VerificationRequestCollection.methods.ts",
    "static": true,
    "longname": "api/verification/VerificationRequestCollection.methods.ts~processVerificationEventMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/verification/VerificationRequestCollection.methods.ts",
    "importStyle": "{processVerificationEventMethod}",
    "description": "This Meteor Method processes a request to verify an opportunity for a given user from the VerificationEvent page.\nThe method is passed a student, opportunity, and academicTerm, which should normally be valid.\nProcessing this request involves the following:\n  * If the student does not have an Opportunity Instance for this opportunity and academicTerm, then one is created\n    for them.\n  * If the student has not already submitted a Verification Request for their Opportunity Instance, then one is\n    created for them.\n  * If the student has already been verified for this Opportunity, then nothing more is done.\n  * Once the OpportunityInstance and VerificationRequest exist, then they are updated to indicate that they have\n    been verified if they are not already verified.\n  * A status string is returned to the caller to indicate the result of processing.\nOnly faculty, advisors, and admins can invoke this method.",
    "lineNumber": 71,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/verification"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1176,
    "kind": "variable",
    "name": "processPendingVerificationMethod",
    "memberof": "api/verification/VerificationRequestCollection.methods.ts",
    "static": true,
    "longname": "api/verification/VerificationRequestCollection.methods.ts~processPendingVerificationMethod",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/verification/VerificationRequestCollection.methods.ts",
    "importStyle": "{processPendingVerificationMethod}",
    "description": "This Meteor Method processes a command from the Pending Verification Request widget.\nThe method is passed a verificationRequestID, a command (ACCEPTED or REJECTED), and an optional feedback string.\nThe method returns a string indicating what happened.\nProcessing this request involves the following:\n\n  * Make sure user is a faculty, advisor, or admin. Otherwise throw error.\n  * If verificationRequestID is not a valid ID, then throw error.\n  * If command is not VerificationRequests.ACCEPTED or VerificationRequests.REJECTED, then returns an error string.\n  * Creates a process object to record this command.\n  * Updates the VerificationRequest with the new process object and the new status.\n  * Creates a new Feed instance only if the request was accepted.\n\nOnly faculty, advisors, and admins can invoke this method.",
    "lineNumber": 131,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/verification"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1177,
    "kind": "file",
    "name": "api/verification/VerificationRequestCollection.test.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport { expect } from 'chai';\nimport fc from 'fast-check';\nimport faker from 'faker';\nimport { ROLE } from '../role/Role';\nimport { VerificationRequests } from './VerificationRequestCollection';\nimport { OpportunityInstances } from '../opportunity/OpportunityInstanceCollection';\nimport { removeAllEntities } from '../base/BaseUtilities';\nimport { makeSampleOpportunityInstance } from '../opportunity/SampleOpportunities';\nimport { makeSampleUser } from '../user/SampleUsers';\nimport { Users } from '../user/UserCollection';\nimport { Slugs } from '../slug/SlugCollection';\n\n/* eslint prefer-arrow-callback: \"off\",  @typescript-eslint/no-unused-expressions: \"off\" */\n/* eslint-env mocha */\n\nif (Meteor.isServer) {\n  describe('VerificationRequestCollection', function testSuite() {\n    before(function setup() {\n      removeAllEntities();\n    });\n\n    after(function teardown() {\n      removeAllEntities();\n    });\n\n    it('Can define and removeIt', function test1(done) { // Test the define and removeIt methods\n      this.timeout(25000);\n      fc.assert(\n        fc.property(fc.lorem(1), (fcWord) => {\n          const sponsorID = makeSampleUser(ROLE.FACULTY);\n          const sponsor = Users.getProfile(sponsorID).username;\n          const studentID = makeSampleUser();\n          const student = Users.getProfile(studentID).username;\n          const oiID = makeSampleOpportunityInstance(student, sponsor);\n          const opportunityDoc = OpportunityInstances.getOpportunityDoc(oiID);\n          const opportunity = Slugs.getNameFromID(opportunityDoc.slugID);\n          const academicTermDoc = OpportunityInstances.getAcademicTermDoc(oiID);\n          const academicTerm = Slugs.getNameFromID(academicTermDoc.slugID);\n          // console.log(oiDoc, opportunityDoc, academicTermDoc);\n          // console.log(sponsor, student, opportunity, academicTerm);\n          // define without opportunity instance\n          const docID = VerificationRequests.define({ student, academicTerm, opportunity });\n          expect(VerificationRequests.isDefined(docID)).to.be.true;\n          VerificationRequests.removeIt(docID);\n          expect(VerificationRequests.isDefined(docID)).to.be.false;\n          const docID2 = VerificationRequests.define({ student, opportunityInstance: oiID });\n          expect(VerificationRequests.isDefined(docID2)).to.be.true;\n          VerificationRequests.removeIt(docID2);\n          expect(VerificationRequests.isDefined(docID2)).to.be.false;\n        }),\n      );\n      done();\n    });\n\n    it('Can define duplicates', function test2() { // Test if duplicate documents can be defined\n      const sponsorID = makeSampleUser(ROLE.FACULTY);\n      const sponsor = Users.getProfile(sponsorID).username;\n      const studentID = makeSampleUser();\n      const student = Users.getProfile(studentID).username;\n      const oiID = makeSampleOpportunityInstance(student, sponsor);\n      const docID = VerificationRequests.define({ student, opportunityInstance: oiID });\n      const docID2 = VerificationRequests.define({ student, opportunityInstance: oiID });\n      expect(docID).to.not.equal(docID2);\n      VerificationRequests.removeIt(docID2);\n    });\n\n    it('Can update', function test3(done) { // Test updating documents\n      this.timeout(5000);\n      let doc = VerificationRequests.findOne({});\n      const docID = doc._id;\n      fc.assert(\n        fc.property(fc.boolean(), (fcRetired) => {\n          const rand = faker.random.number({ min: 0, max: 2 });\n          let status;\n          switch (rand) {\n            case 0:\n              status = VerificationRequests.ACCEPTED;\n              break;\n            case 1:\n              status = VerificationRequests.OPEN;\n              break;\n            default:\n              status = VerificationRequests.REJECTED;\n          }\n          VerificationRequests.update(docID, { status, retired: fcRetired });\n          doc = VerificationRequests.findDoc(docID);\n          expect(doc.status).to.equal(status);\n          expect(doc.retired).to.equal(fcRetired);\n        }),\n      );\n      done();\n    });\n\n    it('Can dumpOne, removeIt, and restoreOne', function test4() { // Tests dumpOne and restoreOne\n      const origDoc = VerificationRequests.findOne({});\n      let docID = origDoc._id;\n      const dumpObject = VerificationRequests.dumpOne(docID);\n      VerificationRequests.removeIt(docID);\n      expect(VerificationRequests.isDefined(docID)).to.be.false;\n      docID = VerificationRequests.restoreOne(dumpObject);\n      expect(VerificationRequests.isDefined(docID)).to.be.true;\n    });\n\n    it('Can checkIntegrity no errors', function test5() { // Tests checkIntegrity\n      const problems = VerificationRequests.checkIntegrity();\n      expect(problems).to.have.lengthOf(0);\n    });\n\n    it('Can get documents from VR', function test6() {\n      const origDoc = VerificationRequests.findOne({});\n      const docID = origDoc._id;\n      const opportunityDoc = VerificationRequests.getOpportunityDoc(docID);\n      expect(opportunityDoc).to.exist;\n      const studentDoc = VerificationRequests.getStudentDoc(docID);\n      expect(studentDoc).to.exist;\n      const sponsorDoc = VerificationRequests.getSponsorDoc(docID);\n      expect(sponsorDoc).to.exist;\n      const opportunityInstanceDoc = VerificationRequests.getOpportunityInstanceDoc(docID);\n      expect(opportunityInstanceDoc).to.exist;\n      expect(opportunityInstanceDoc.studentID).to.equal(studentDoc.userID);\n      expect(opportunityDoc.sponsorID).to.equal(sponsorDoc.userID);\n      expect(opportunityInstanceDoc.opportunityID).to.equal(opportunityDoc._id);\n    });\n  });\n}\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/verification/VerificationRequestCollection.test.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1178,
    "kind": "file",
    "name": "api/verification/VerificationRequestCollection.ts",
    "content": "import { Meteor } from 'meteor/meteor';\nimport _ from 'lodash';\nimport SimpleSchema from 'simpl-schema';\nimport moment from 'moment';\nimport BaseCollection from '../base/BaseCollection';\nimport { Opportunities } from '../opportunity/OpportunityCollection';\nimport { OpportunityInstances } from '../opportunity/OpportunityInstanceCollection';\nimport { ROLE } from '../role/Role';\nimport { AcademicTerms } from '../academic-term/AcademicTermCollection';\nimport { Users } from '../user/UserCollection';\nimport { IProcessed, IVerificationRequestDefine, IVerificationRequestUpdate } from '../../typings/radgrad';\nimport { iceSchema } from '../ice/IceProcessor';\n\n/**\n * Schema for the processed information of VerificationRequests.\n * @memberOf api/verification\n */\nexport const ProcessedSchema = new SimpleSchema({\n  date: Date,\n  status: String,\n  verifier: String,\n  feedback: { type: String, optional: true },\n});\n\n/**\n * Represents a Verification Request, such as \"LiveWire Internship\".\n * A student has completed an opportunity (such as an internship or project) and wants to obtain ICE Points by\n * having it verified.\n * @extends api/base.BaseCollection\n * @memberOf api/verification\n */\nclass VerificationRequestCollection extends BaseCollection {\n  public ACCEPTED: string;\n  public REJECTED: string;\n  public OPEN: string;\n\n  /**\n   * Creates the VerificationRequest collection.\n   */\n  constructor() {\n    super('VerificationRequest', new SimpleSchema({\n      studentID: SimpleSchema.RegEx.Id,\n      opportunityInstanceID: SimpleSchema.RegEx.Id,\n      submittedOn: Date,\n      status: String,\n      processed: [ProcessedSchema],\n      ice: { type: iceSchema, optional: true },\n      retired: { type: Boolean, optional: true },\n    }));\n    this.ACCEPTED = 'Accepted';\n    this.REJECTED = 'Rejected';\n    this.OPEN = 'Open';\n    this.defineSchema = new SimpleSchema({\n      student: String,\n      opportunityInstance: { type: String, optional: true },\n      submittedOn: { type: Date, optional: true },\n      status: { type: String, optional: true, allowedValues: [this.REJECTED, this.ACCEPTED, this.OPEN] },\n      academicTerm: { type: String, optional: true },\n      opportunity: { type: String, optional: true },\n      retired: { type: Boolean, optional: true },\n    });\n    this.updateSchema = new SimpleSchema({\n      status: { type: String, optional: true, allowedValues: [this.REJECTED, this.ACCEPTED, this.OPEN] },\n      processed: { type: Array, optional: true },\n      'processed.$': { type: ProcessedSchema },\n      retired: { type: Boolean, optional: true },\n    });\n  }\n\n  /**\n   * Defines a verification request.\n   * @example\n   * VerificationRequests.define({ student: 'joesmith',\n   *                               opportunityInstance: 'EiQYeRP4jyyre28Zw' });\n   * or\n   * VerificationRequests.define({ student: 'joesmith',\n   *                               opportunity: 'TechHui',\n   *                              academicTerm: 'Fall-2015'});\n   * @param { Object } student and opportunity must be slugs or IDs. SubmittedOn defaults to now.\n   * status defaults to OPEN, processed defaults to an empty array and retired defaults to false.\n   * You can either pass the opportunityInstanceID or pass the opportunity and academicTerm slugs. If opportunityInstance\n   * is not defined, then the student, opportunity, and academicTerm arguments are used to look it up.\n   * @throws {Meteor.Error} If academicTerm, opportunity, opportunityInstance or student cannot be resolved,\n   * or if verified is not a boolean.\n   * @returns The newly created docID.\n   */\n  public define({ student, opportunityInstance, submittedOn = moment().toDate(), status = this.OPEN, processed = [], academicTerm, opportunity, retired = false }: IVerificationRequestDefine) {\n    // console.log(student, opportunityInstance, submittedOn, status, processed, academicTerm, opportunity);\n    const studentID = Users.getID(student);\n    const oppInstance = opportunityInstance ? OpportunityInstances.findDoc(opportunityInstance) :\n      OpportunityInstances.findOpportunityInstanceDoc(academicTerm, opportunity, student);\n    if (!oppInstance) {\n      throw new Meteor.Error('Could not find the opportunity instance to associate with this verification request');\n    }\n    const opportunityInstanceID = oppInstance._id;\n    const ice = Opportunities.findDoc(oppInstance.opportunityID).ice;\n    // Define and return the new VerificationRequest\n    const requestID = this.collection.insert({\n      studentID, opportunityInstanceID, submittedOn, status, processed, ice, retired,\n    });\n    return requestID;\n  }\n\n  /**\n   * Updates the VerificationRequest\n   * @param docID the docID to update.\n   * @param {string} status optional\n   * @param {IProcessed[]} processed optional\n   * @param {boolean} retired optional\n   */\n  public update(docID, { status, processed, retired }: IVerificationRequestUpdate) {\n    const updateData: IVerificationRequestUpdate = { status, processed, retired };\n    this.collection.update(docID, { $set: updateData });\n  }\n\n  /**\n   * Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\n   * Student.\n   * This is used in the define, update, and removeIt Meteor methods associated with each class.\n   * @param userId The userId of the logged in user. Can be null or undefined\n   * @throws { Meteor.Error } If there is no logged in user, or the user is not an Admin or Advisor.\n   */\n  public assertValidRoleForMethod(userId: string) {\n    this.assertRole(userId, [ROLE.ADMIN, ROLE.ADVISOR, ROLE.STUDENT]);\n  }\n\n  /**\n   * Returns the VerificationRequestID associated with opportunityInstanceID, or null if not found.\n   * @param opportunityInstanceID The opportunityInstanceID\n   * @returns The VerificationRequestID, or null if not found.\n   */\n  public findVerificationRequest(opportunityInstanceID: string) {\n    const result = this.collection.findOne({ opportunityInstanceID });\n    return result && result._id;\n  }\n\n  /**\n   * Removes all VerificationRequest documents referring to user.\n   * @param user The user, either the ID or the username.\n   * @throws { Meteor.Error } If user is not an ID or username.\n   */\n  public removeUser(user: string) {\n    const studentID = Users.getID(user);\n    this.collection.remove({ studentID });\n  }\n\n  /**\n   * Returns the Opportunity associated with the VerificationRequest with the given instanceID.\n   * @param verificationRequestID The id of the VerificationRequest.\n   * @returns {IOpportunity} The associated Opportunity.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  public getOpportunityDoc(verificationRequestID: string) {\n    this.assertDefined(verificationRequestID);\n    const instance = this.collection.findOne({ _id: verificationRequestID });\n    const opportunity = OpportunityInstances.getOpportunityDoc(instance.opportunityInstanceID);\n    return opportunity;\n  }\n\n  /**\n   * Returns the Opportunity associated with the VerificationRequest with the given instanceID.\n   * @param verificationRequestID The id of the VerificationRequest.\n   * @returns {Object} The associated Opportunity.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  public getOpportunityInstanceDoc(verificationRequestID: string) {\n    this.assertDefined(verificationRequestID);\n    const instance = this.collection.findOne({ _id: verificationRequestID });\n    return OpportunityInstances.findDoc(instance.opportunityInstanceID);\n  }\n\n  /**\n   * Returns the AcademicTerm associated with the VerificationRequest with the given instanceID.\n   * @param instanceID The id of the VerificationRequest.\n   * @returns {IAcademicTerm} The associated AcademicTerm.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  public getAcademicTermDoc(instanceID: string) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    const oppInstance = OpportunityInstances.findDoc(instance.opportunityInstanceID);\n    return AcademicTerms.findDoc(oppInstance.termID);\n  }\n\n  /**\n   * Returns the Sponsor (faculty) profile associated with the VerificationRequest with the given instanceID.\n   * @param instanceID The id of the VerificationRequest.\n   * @returns {Object} The associated Faculty profile.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  public getSponsorDoc(instanceID: string) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    const opportunity = OpportunityInstances.getOpportunityDoc(instance.opportunityInstanceID);\n    return Users.getProfile(opportunity.sponsorID);\n  }\n\n  /**\n   * Returns the Student profile associated with the VerificationRequest with the given instanceID.\n   * @param instanceID The id of the VerificationRequest.\n   * @returns {Object} The associated Student profile.\n   * @throws {Meteor.Error} If instanceID is not a valid ID.\n   */\n  public getStudentDoc(instanceID: string) {\n    this.assertDefined(instanceID);\n    const instance = this.collection.findOne({ _id: instanceID });\n    return Users.getProfile(instance.studentID);\n  }\n\n  /**\n   * Depending on the logged in user publish only their VerificationRequests. If\n   * the user is in the Role.ADMIN, ADVISOR or FACULTY then publish all Verification Requests.\n   */\n  public publish() {\n    if (Meteor.isServer) {\n      const instance = this;\n      // eslint-disable-next-line meteor/audit-argument-checks\n      Meteor.publish(this.collectionName, function publish(studentID) {\n        if (_.isNil(this.userId)) { // https://github.com/meteor/meteor/issues/9619\n          return this.ready();\n        }\n        const profile = Users.getProfile(this.userId);\n        if (profile.role === ROLE.ADMIN || Meteor.isAppTest) {\n          return instance.collection.find();\n        }\n        if (profile.role === ROLE.ADVISOR) {\n          return instance.collection.find({ retired: { $not: { $eq: true } } });\n        }\n        if (profile.role === ROLE.FACULTY) {\n          return instance.collection.find({ sponsorID: studentID, retired: { $not: { $eq: true } } });\n        }\n        return instance.collection.find({ studentID, retired: { $not: { $eq: true } } });\n      });\n    }\n  }\n\n  /**\n   * Updates the VerificationRequest's status and processed array.\n   * @param requestID The VerificationRequest ID.\n   * @param status The new Status.\n   * @param processed The new array of process records.\n   */\n  public updateStatus(requestID: string, status: string, processed: IProcessed[]) {\n    this.assertDefined(requestID);\n    this.collection.update({ _id: requestID }, { $set: { status, processed } });\n  }\n\n  /**\n   * Sets the retired status of the retired flag.\n   * @param requestID the VerificationRequest ID.\n   * @param retired the retired status.\n   */\n  public updateRetired(requestID: string, retired: boolean) {\n    this.assertDefined(requestID);\n    this.collection.update({ _id: requestID }, { $set: { retired } });\n  }\n\n  /**\n   * Sets the passed VerificationRequest to be verified.\n   * @param verificationRequestID The VerificationRequest\n   * @param verifyingUser The user who did the verification.\n   * @throws { Meteor.Error } If verificationRequestID or verifyingUser are not defined.\n   */\n  public setVerified(verificationRequestID: string, verifyingUser: string) {\n    this.assertDefined(verificationRequestID);\n    const userID = Users.getID(verifyingUser);\n    const verifier = Users.getProfile(userID).username;\n    const date = new Date();\n    const status = this.ACCEPTED;\n    const processed = [{ date, status, verifier }];\n    this.collection.update(verificationRequestID, { $set: { status, processed } });\n  }\n\n  /**\n   * Sets the verification status of the passed VerificationRequest.\n   * @param verificationRequestID The ID of the verification request.\n   * @param verifyingUser The user who is doing the verification.\n   * @param status The status (ACCEPTED, REJECTED, OPEN).\n   * @param feedback An optional feedback string.\n   * @throws { Meteor.Error } If the verification request or user is not defined.\n   */\n  public setVerificationStatus(verificationRequestID: string, verifyingUser: string, status: string, feedback?: string) {\n    this.assertDefined(verificationRequestID);\n    const userID = Users.getID(verifyingUser);\n    const verifier = Users.getProfile(userID).username;\n    const date = new Date();\n    const processRecord = { date, status, verifier, feedback };\n    this.collection.update(verificationRequestID, { $set: { status }, $push: { processed: processRecord } });\n  }\n\n  /**\n   * Returns an array of strings, each one representing an integrity problem with this collection.\n   * Returns an empty array if no problems were found.\n   * Checks studentID, opportunityInstanceID, termID.\n   * @returns {Array} A (possibly empty) array of strings indicating integrity issues.\n   */\n  public checkIntegrity() {\n    const problems = [];\n    this.find().forEach((doc) => {\n      if (!Users.isDefined(doc.studentID)) {\n        problems.push(`Bad studentID: ${doc.studentID}`);\n      }\n      if (!OpportunityInstances.isDefined(doc.opportunityInstanceID)) {\n        problems.push(`Bad opportunityInstanceID: ${doc.opportunityInstanceID}`);\n      }\n      if (!AcademicTerms.isDefined(doc.termID)) {\n        problems.push(`Bad termID: ${doc.termID}`);\n      }\n    });\n    return problems;\n  }\n\n  /**\n   * Returns an object representing the VerificationRequest docID in a format acceptable to define().\n   * @param docID The docID of an VerificationRequest.\n   * @returns { Object } An object representing the definition of docID.\n   */\n  public dumpOne(docID: string): IVerificationRequestDefine {\n    const doc = this.findDoc(docID);\n    const student = Users.getProfile(doc.studentID).username;\n    const opportunityInstance = OpportunityInstances.findDoc(doc.opportunityInstanceID);\n    const academicTerm = AcademicTerms.findSlugByID(opportunityInstance.termID);\n    const opportunity = Opportunities.findSlugByID(opportunityInstance.opportunityID);\n    const submittedOn = doc.submittedOn;\n    const status = doc.status;\n    const processed = doc.processed;\n    const retired = doc.retired;\n    return { student, academicTerm, opportunity, submittedOn, status, processed, retired };\n  }\n\n  /**\n   * Internal helper function to simplify definition of the assertValidRoleForMethod method.\n   * @param userId The userID.\n   * @param roles An array of roles.\n   * @throws { Meteor.Error } If userId is not defined or user is not in the specified roles.\n   * @returns True if no error is thrown.\n   * @ignore\n   */\n  public assertRole(userId: string, roles: string[]): boolean {\n    if (!userId) {\n      throw new Meteor.Error('unauthorized', 'You must be logged in.');\n    } else {\n      const profile = Users.getProfile(userId);\n      if (!_.includes(roles, profile.role)) {\n        throw new Meteor.Error('unauthorized', `You must be one of the following roles: ${roles}`);\n      }\n\n    }\n    return true;\n  }\n}\n\n/**\n * Provides the singleton instance of this class to all other entities.\n * @memberOf api/verification\n * @type {api/verification.VerificationRequestCollection}\n */\nexport const VerificationRequests = new VerificationRequestCollection();\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/verification/VerificationRequestCollection.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1179,
    "kind": "variable",
    "name": "ProcessedSchema",
    "memberof": "api/verification/VerificationRequestCollection.ts",
    "static": true,
    "longname": "api/verification/VerificationRequestCollection.ts~ProcessedSchema",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/verification/VerificationRequestCollection.ts",
    "importStyle": "{ProcessedSchema}",
    "description": "Schema for the processed information of VerificationRequests.",
    "lineNumber": 16,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/verification"
      }
    ],
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1180,
    "kind": "variable",
    "name": "VerificationRequests",
    "memberof": "api/verification/VerificationRequestCollection.ts",
    "static": true,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequests",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/verification/VerificationRequestCollection.ts",
    "importStyle": "{VerificationRequests}",
    "description": "Provides the singleton instance of this class to all other entities.",
    "lineNumber": 381,
    "unknown": [
      {
        "tagName": "@memberOf",
        "tagValue": "api/verification"
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "api/verification.VerificationRequestCollection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 1181,
    "kind": "class",
    "name": "VerificationRequestCollection",
    "memberof": "api/verification/VerificationRequestCollection.ts",
    "static": true,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "access": "public",
    "export": true,
    "importPath": "radgrad2/api/verification/VerificationRequestCollection.ts",
    "importStyle": null,
    "description": "Represents a Verification Request, such as \"LiveWire Internship\".\nA student has completed an opportunity (such as an internship or project) and wants to obtain ICE Points by\nhaving it verified.",
    "lineNumber": 32,
    "pseudoExport": true,
    "interface": false,
    "extends": [
      "api/base/BaseCollection.js~BaseCollection"
    ]
  },
  {
    "__docId__": 1182,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#constructor",
    "access": "public",
    "description": "Creates the VerificationRequest collection.",
    "lineNumber": 34
  },
  {
    "__docId__": 1183,
    "kind": "member",
    "name": "ACCEPTED",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#ACCEPTED",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1184,
    "kind": "member",
    "name": "REJECTED",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#REJECTED",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1185,
    "kind": "member",
    "name": "OPEN",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#OPEN",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 1186,
    "kind": "member",
    "name": "defineSchema",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#defineSchema",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1187,
    "kind": "member",
    "name": "updateSchema",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#updateSchema",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1188,
    "kind": "method",
    "name": "define",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#define",
    "access": "public",
    "description": "Defines a verification request.",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "IVerificationRequestDefine"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1189,
    "kind": "method",
    "name": "update",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#update",
    "access": "public",
    "description": "Updates the VerificationRequest",
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "IVerificationRequestUpdate"
        ],
        "spread": false,
        "optional": false,
        "name": "undefined",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1190,
    "kind": "method",
    "name": "assertValidRoleForMethod",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#assertValidRoleForMethod",
    "access": "public",
    "description": "Implementation of assertValidRoleForMethod. Asserts that userId is logged in as an Admin, Advisor or\nStudent.\nThis is used in the define, update, and removeIt Meteor methods associated with each class.",
    "lineNumber": 123,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1191,
    "kind": "method",
    "name": "findVerificationRequest",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#findVerificationRequest",
    "access": "public",
    "description": "Returns the VerificationRequestID associated with opportunityInstanceID, or null if not found.",
    "lineNumber": 132,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "opportunityInstanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1192,
    "kind": "method",
    "name": "removeUser",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#removeUser",
    "access": "public",
    "description": "Removes all VerificationRequest documents referring to user.",
    "lineNumber": 142,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "user",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1193,
    "kind": "method",
    "name": "getOpportunityDoc",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#getOpportunityDoc",
    "access": "public",
    "description": "Returns the Opportunity associated with the VerificationRequest with the given instanceID.",
    "lineNumber": 153,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "verificationRequestID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1194,
    "kind": "method",
    "name": "getOpportunityInstanceDoc",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#getOpportunityInstanceDoc",
    "access": "public",
    "description": "Returns the Opportunity associated with the VerificationRequest with the given instanceID.",
    "lineNumber": 166,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "verificationRequestID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1195,
    "kind": "method",
    "name": "getAcademicTermDoc",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#getAcademicTermDoc",
    "access": "public",
    "description": "Returns the AcademicTerm associated with the VerificationRequest with the given instanceID.",
    "lineNumber": 178,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1196,
    "kind": "method",
    "name": "getSponsorDoc",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#getSponsorDoc",
    "access": "public",
    "description": "Returns the Sponsor (faculty) profile associated with the VerificationRequest with the given instanceID.",
    "lineNumber": 191,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1197,
    "kind": "method",
    "name": "getStudentDoc",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#getStudentDoc",
    "access": "public",
    "description": "Returns the Student profile associated with the VerificationRequest with the given instanceID.",
    "lineNumber": 204,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "instanceID",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1198,
    "kind": "method",
    "name": "publish",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#publish",
    "access": "public",
    "description": "Depending on the logged in user publish only their VerificationRequests. If\nthe user is in the Role.ADMIN, ADVISOR or FACULTY then publish all Verification Requests.",
    "lineNumber": 214,
    "params": [],
    "return": null
  },
  {
    "__docId__": 1199,
    "kind": "method",
    "name": "updateStatus",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#updateStatus",
    "access": "public",
    "description": "Updates the VerificationRequest's status and processed array.",
    "lineNumber": 243,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "status",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "processed",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1200,
    "kind": "method",
    "name": "updateRetired",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#updateRetired",
    "access": "public",
    "description": "Sets the retired status of the retired flag.",
    "lineNumber": 253,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "requestID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "retired",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1201,
    "kind": "method",
    "name": "setVerified",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#setVerified",
    "access": "public",
    "description": "Sets the passed VerificationRequest to be verified.",
    "lineNumber": 264,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "verificationRequestID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "verifyingUser",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1202,
    "kind": "method",
    "name": "setVerificationStatus",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#setVerificationStatus",
    "access": "public",
    "description": "Sets the verification status of the passed VerificationRequest.",
    "lineNumber": 282,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "verificationRequestID",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "verifyingUser",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "status",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "feedback",
        "description": ""
      }
    ],
    "return": null
  },
  {
    "__docId__": 1203,
    "kind": "method",
    "name": "checkIntegrity",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#checkIntegrity",
    "access": "public",
    "description": "Returns an array of strings, each one representing an integrity problem with this collection.\nReturns an empty array if no problems were found.\nChecks studentID, opportunityInstanceID, termID.",
    "lineNumber": 297,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 1204,
    "kind": "method",
    "name": "dumpOne",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#dumpOne",
    "access": "public",
    "description": "Returns an object representing the VerificationRequest docID in a format acceptable to define().",
    "lineNumber": 318,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "docID",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "IVerificationRequestDefine"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1205,
    "kind": "method",
    "name": "assertRole",
    "memberof": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "api/verification/VerificationRequestCollection.ts~VerificationRequestCollection#assertRole",
    "access": "public",
    "description": "Internal helper function to simplify definition of the assertValidRoleForMethod method.",
    "lineNumber": 339,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "userId",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "undefined"
        ],
        "spread": false,
        "optional": false,
        "name": "roles",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 1206,
    "kind": "file",
    "name": "api/verification/index.ts",
    "content": "/** @namespace api/verification */\nimport './VerificationRequestCollection';\nimport './VerificationRequestCollection.methods';\n",
    "static": true,
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/imports/api/verification/index.ts",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "kind": "index",
    "content": "",
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"radgrad2\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"cross-env METEOR_NO_RELEASE_CHECK=1 meteor --settings ../config/settings.development.json --port 3200\",\n    \"start-custom\": \"cross-env METEOR_NO_RELEASE_CHECK=1 meteor --settings ../custom/settings.development.json --port 3200\",\n    \"start-production\": \"meteor --production --no-release-check --settings ../config/settings.development.json --port 3200\",\n    \"lint\": \"eslint --fix --quiet --ext .tsx --ext .ts ./imports\",\n    \"lint-console\": \"eslint --fix --ext .tsx --ext .ts ./imports\",\n    \"pretest\": \"npm run lint\",\n    \"test\": \"cross-env METEOR_NO_RELEASE_CHECK=1 TEST_BROWSER_DRIVER=puppeteer meteor test --once --driver-package meteortesting:mocha --port 3300\",\n    \"test-no-lint\": \"cross-env METEOR_NO_RELEASE_CHECK=1 TEST_BROWSER_DRIVER=puppeteer meteor test --once --driver-package meteortesting:mocha --port 3300\",\n    \"test-app\": \"cross-env METEOR_NO_RELEASE_CHECK=1 TEST_BROWSER_DRIVER=puppeteer meteor test --full-app --once --driver-package meteortesting:mocha --port 3300\",\n    \"test-e2e\": \"testcafe chrome:headless imports/ui/**/*.test-e2e.ts\",\n    \"test-e2e-v\": \"testcafe chrome imports/ui/**/*.test-e2e.ts\",\n    \"deploy\": \"DEPLOY_HOSTNAME=galaxy.meteor.com meteor deploy radgrad2.meteorapp.com --settings ../config/settings.production.json --owner radgrad\",\n    \"api-doc\": \"./node_modules/.bin/esdoc -c .esdoc-api.json\",\n    \"ui-doc\": \"./node_modules/.bin/esdoc -c .esdoc-ui.json\"\n  },\n  \"dependencies\": {\n    \"@babel/runtime\": \"^7.10.3\",\n    \"acorn\": \"^7.3.1\",\n    \"bcrypt\": \"^4.0.1\",\n    \"chart.js\": \"^2.9.3\",\n    \"classnames\": \"^2.2.6\",\n    \"connected-react-router\": \"^6.8.0\",\n    \"core-js\": \"^3.6.5\",\n    \"cosmiconfig\": \"^6.0.0\",\n    \"deepmerge\": \"^4.2.2\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-ecmascript-proposal-plugin\": \"^1.0.0\",\n    \"esdoc-jsx-plugin\": \"^1.0.0\",\n    \"esdoc-react-plugin\": \"^1.0.1\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"esdoc-typescript-plugin\": \"^1.0.1\",\n    \"graphql\": \"^15.1.0\",\n    \"highcharts\": \"^8.1.2\",\n    \"highcharts-react-official\": \"^3.0.0\",\n    \"history\": \"^4.10.1\",\n    \"immutable\": \"^4.0.0-rc.12\",\n    \"meteor-node-stubs\": \"^1.0.0\",\n    \"moment\": \"^2.27.0\",\n    \"prop-types\": \"^15.7.2\",\n    \"react\": \"^16.13.1\",\n    \"react-addons-pure-render-mixin\": \"^15.6.2\",\n    \"react-beautiful-dnd\": \"^13.0.0\",\n    \"react-chartjs-2\": \"^2.9.0\",\n    \"react-content-loader\": \"^5.1.0\",\n    \"react-datepicker\": \"^2.16.0\",\n    \"react-dnd\": \"^10.0.2\",\n    \"react-dnd-html5-backend\": \"^10.0.2\",\n    \"react-dom\": \"^16.13.1\",\n    \"react-images-upload\": \"^1.2.8\",\n    \"react-is\": \"^16.13.1\",\n    \"react-markdown\": \"^4.3.1\",\n    \"react-native\": \"^0.62.2\",\n    \"react-redux\": \"^7.2.0\",\n    \"react-router\": \"^5.2.0\",\n    \"react-router-dom\": \"^5.2.0\",\n    \"react-scroll-up-button\": \"^1.6.4\",\n    \"react-slick\": \"^0.25.2\",\n    \"redux\": \"^4.0.5\",\n    \"seamless-immutable\": \"^7.1.4\",\n    \"semantic-ui-css\": \"^2.4.1\",\n    \"semantic-ui-react\": \"^0.88.2\",\n    \"showdown\": \"^1.9.1\",\n    \"simpl-schema\": \"^1.8.0\",\n    \"slick-carousel\": \"^1.8.1\",\n    \"styled-components\": \"^5.1.1\",\n    \"sweetalert2\": \"^9.15.2\",\n    \"sweetalert2-react-content\": \"^3.0.1\",\n    \"typesafe-actions\": \"^5.1.0\",\n    \"uniforms\": \"^3.0.0-alpha.5\",\n    \"uniforms-bridge-simple-schema-2\": \"^3.0.0-alpha.5\",\n    \"uniforms-semantic\": \"^3.0.0-alpha.5\"\n  },\n  \"devDependencies\": {\n    \"@babel/helper-call-delegate\": \"^7.10.3\",\n    \"@hapi/joi\": \"^17.1.1\",\n    \"@react-native-community/cli-debugger-ui\": \"^4.9.0\",\n    \"@react-native-community/cli-types\": \"^4.10.1\",\n    \"@types/chai\": \"^4.2.11\",\n    \"@types/jasmine\": \"^3.5.11\",\n    \"@types/lodash\": \"^4.14.157\",\n    \"@types/meteor\": \"^1.4.47\",\n    \"@types/meteor-roles\": \"^1.2.32\",\n    \"@types/mocha\": \"^7.0.2\",\n    \"@types/node\": \"^13.13.12\",\n    \"@types/react\": \"^16.9.41\",\n    \"@types/react-dom\": \"^16.9.8\",\n    \"@types/react-slick\": \"^0.23.4\",\n    \"@typescript-eslint/eslint-plugin\": \"^2.34.0\",\n    \"@typescript-eslint/parser\": \"^2.34.0\",\n    \"ansi-escapes\": \"^4.3.1\",\n    \"art\": \"^0.10.3\",\n    \"babel-eslint\": \"^10.1.0\",\n    \"basic-auth\": \"^2.0.1\",\n    \"chai\": \"^4.2.0\",\n    \"chromedriver\": \"^81.0.0\",\n    \"command-exists\": \"^1.2.9\",\n    \"compression\": \"^1.7.4\",\n    \"cross-env\": \"^7.0.2\",\n    \"eslint\": \"^6.8.0\",\n    \"eslint-config-airbnb\": \"^18.2.0\",\n    \"eslint-config-react-app\": \"^5.2.1\",\n    \"eslint-plugin-flowtype\": \"^4.7.0\",\n    \"eslint-plugin-import\": \"^2.21.2\",\n    \"eslint-plugin-jsx-a11y\": \"^6.3.1\",\n    \"eslint-plugin-meteor\": \"^7.0.0\",\n    \"eslint-plugin-react\": \"^7.20.0\",\n    \"eslint-plugin-react-hooks\": \"^4.0.4\",\n    \"faker\": \"^4.1.0\",\n    \"fast-check\": \"^1.25.1\",\n    \"fs-extra\": \"^9.0.1\",\n    \"growly\": \"^1.3.0\",\n    \"mime-db\": \"^1.44.0\",\n    \"mime-types\": \"^2.1.27\",\n    \"mocha\": \"^7.2.0\",\n    \"morgan\": \"^1.10.0\",\n    \"node-notifier\": \"^7.0.1\",\n    \"puppeteer\": \"^3.3.0\",\n    \"selenium-webdriver\": \"^4.0.0-alpha.7\",\n    \"testcafe\": \"^1.8.7\",\n    \"through2\": \"^3.0.2\",\n    \"ts-node\": \"^8.10.2\",\n    \"typescript\": \"^3.9.5\",\n    \"xtend\": \"^4.0.2\"\n  },\n  \"eslintConfig\": {\n    \"settings\": {\n      \"import/extensions\": [\n        \".js\",\n        \".jsx\",\n        \".ts\",\n        \".tsx\"\n      ],\n      \"import/parsers\": {\n        \"@typescript-eslint/parser\": [\n          \".ts\",\n          \".tsx\"\n        ]\n      },\n      \"import/resolver\": {\n        \"node\": {\n          \"extensions\": [\n            \".js\",\n            \".jsx\",\n            \".ts\",\n            \".tsx\"\n          ]\n        }\n      }\n    },\n    \"parser\": \"@typescript-eslint/parser\",\n    \"plugins\": [\n      \"@typescript-eslint\",\n      \"meteor\",\n      \"react\"\n    ],\n    \"extends\": [\n      \"airbnb\",\n      \"plugin:meteor/recommended\",\n      \"react-app\"\n    ],\n    \"rules\": {\n      \"arrow-parens\": \"off\",\n      \"camelcase\": \"off\",\n      \"class-methods-use-this\": \"off\",\n      \"func-names\": \"off\",\n      \"jsx-a11y/anchor-is-valid\": \"off\",\n      \"import/extensions\": \"off\",\n      \"import/no-cycle\": \"warn\",\n      \"import/no-unresolved\": \"off\",\n      \"import/no-absolute-path\": \"off\",\n      \"import/imports-first\": \"off\",\n      \"import/prefer-default-export\": \"off\",\n      \"import/no-extraneous-dependencies\": \"off\",\n      \"indent\": \"off\",\n      \"linebreak-style\": \"off\",\n      \"lines-between-class-members\": \"off\",\n      \"max-len\": \"off\",\n      \"meteor/eventmap-params\": [\n        2,\n        {\n          \"eventParamName\": \"event\",\n          \"templateInstanceParamName\": \"instance\"\n        }\n      ],\n      \"meteor/template-names\": \"off\",\n      \"no-confusing-arrow\": [\n        \"error\",\n        {\n          \"allowParens\": true\n        }\n      ],\n      \"no-console\": [\n        \"warn\",\n        {\n          \"allow\": [\n            \"off\",\n            \"error\"\n          ]\n        }\n      ],\n      \"no-plusplus\": \"off\",\n      \"no-underscore-dangle\": \"off\",\n      \"no-nested-ternary\": \"off\",\n      \"no-unused-vars\": \"off\",\n      \"@typescript-eslint/no-unused-vars\": \"error\",\n      \"no-useless-constructor\": \"off\",\n      \"@typescript-eslint/no-useless-constructor\": \"error\",\n      \"object-curly-newline\": \"off\",\n      \"object-property-newline\": \"off\",\n      \"object-shorthand\": \"off\",\n      \"operator-linebreak\": \"off\",\n      \"padded-blocks\": \"off\",\n      \"prefer-arrow-callback\": \"off\",\n      \"prefer-destructuring\": \"off\",\n      \"prefer-promise-reject-errors\": \"off\",\n      \"react/destructuring-assignment\": \"off\",\n      \"react/jsx-filename-extension\": [\n        1,\n        {\n          \"extensions\": [\n            \"js\",\n            \".jsx\",\n            \"ts\",\n            \".tsx\"\n          ]\n        }\n      ],\n      \"react/jsx-fragments\": \"off\",\n      \"react/jsx-props-no-spreading\": \"off\",\n      \"react/prefer-stateless-function\": \"off\",\n      \"react/sort-comp\": \"off\",\n      \"react/jsx-one-expression-per-line\": \"off\",\n      \"react/jsx-closing-tag-location\": \"off\"\n    }\n  }\n}\n",
    "longname": "/Users/carletonmoore/RadGrad/radgrad2/app/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]